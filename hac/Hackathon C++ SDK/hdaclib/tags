!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACTMONSET	libstar/xdebug.h	239;"	d
ACTMON_XNMS	libstar/xdebug.h	/^	ACTMON_XNMS,$/;"	e	enum:__anon123
ACTMON_XPING	libstar/xdebug.h	/^	ACTMON_XPING = 90,$/;"	e	enum:__anon123
AGG_TYPE_AS	libstar/nflowlib.h	242;"	d
AGG_TYPE_DSTNET	libstar/nflowlib.h	245;"	d
AGG_TYPE_MAX	libstar/nflowlib.h	248;"	d
AGG_TYPE_NETMATRIX	libstar/nflowlib.h	246;"	d
AGG_TYPE_NUM	libstar/nflowlib.h	249;"	d
AGG_TYPE_PROTO_PORT	libstar/nflowlib.h	243;"	d
AGG_TYPE_SRCNET	libstar/nflowlib.h	244;"	d
ALIGN_4BYTE	libstar/xdebug.h	28;"	d
ALIGN_8BYTE	libstar/array.c	16;"	d	file:
ALIGN_8BYTE	libstar/array.h	21;"	d
ALIGN_8BYTE	libstar/hash.c	68;"	d	file:
ALIGN_8BYTE	libstar/vhash.c	63;"	d	file:
ALIGN_8BYTE	libstar/xdebug.h	32;"	d
ALIGN_8BYTE	libstar/xindex.h	21;"	d
AO	libstar/xtn.c	194;"	d	file:
ARIA_128BIT	libstar/aria.h	/^	ARIA_128BIT = 128,$/;"	e	enum:__anon26
ARIA_192BIT	libstar/aria.h	/^	ARIA_192BIT = 192,$/;"	e	enum:__anon26
ARIA_256BIT	libstar/aria.h	/^	ARIA_256BIT = 256,$/;"	e	enum:__anon26
ARIA_ALIGN16	libstar/aria.h	34;"	d
ARRAY	json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::final::Type
ARRAYSIZE	libstar/xstr.h	35;"	d
ASPI_BUF_SIZE	libstar/dvdlib.c	464;"	d	file:
ASPI_BUF_SIZE	libstar/oddlibwin.c	304;"	d	file:
AVG_IFVAL	libstar/snmpsub.c	1177;"	d	file:
AYT	libstar/xtn.c	195;"	d	file:
Adapter	libstar/dvdlib.c	/^	char		Adapter;$/;"	m	struct:__anon28	file:
Adapter	libstar/oddlibwin.c	/^	char            Adapter;$/;"	m	struct:__anon65	file:
Add	libstar/xnms.h	/^	int		Add(xnmsnode_t *xn)		{ xnms_add(m_xnms, xn);	}$/;"	f	class:CXNms
AddHead	libstar/xlist.h	/^	xlistnode_t	*AddHead()			{ return xlist_addhead(m_xl); }$/;"	f	class:CXList
AddNext	libstar/xlist.h	/^	xlistnode_t	*AddNext(xlistnode_t *node)	{ return xlist_addnext(m_xl, node); }$/;"	f	class:CXList
AddOid	libstar/xsnmp.h	/^	BOOL		AddOid(oid *oidval, int oidsz)	{ return xsnmp_addoid(m_xs, oidval, oidsz); }$/;"	f	class:CXSnmp
AddPrev	libstar/xlist.h	/^	xlistnode_t	*AddPrev(xlistnode_t *node)	{ return xlist_addprev(m_xl, node); }$/;"	f	class:CXList
AddTail	libstar/xlist.h	/^	xlistnode_t	*AddTail()			{ return xlist_addtail(m_xl); }$/;"	f	class:CXList
AriaCrypt	libstar/aria.c	/^static	void AriaCrypt(const uint8 *i, int Nr, const uint8 *rk, uint8 *o)$/;"	f	file:
AspiCommBuf	libstar/oddlibwin.c	/^static BYTE    *AspiCommBuf = NULL;$/;"	v	file:
AttachHead	libstar/xlist.h	/^	xlistnode_t	*AttachHead(xlistnode_t *node)	{ return xlist_attachhead(m_xl, node); }$/;"	f	class:CXList
AttachTail	libstar/xlist.h	/^	xlistnode_t	*AttachTail(xlistnode_t *node)	{ return xlist_attachtail(m_xl, node); }$/;"	f	class:CXList
Authtype	libstar/ssmtp.h	/^	int             Authtype;		\/\/ Support ESMTP AUTH command $/;"	m	struct:__anon101
BACKGROUND_BLUE	libstar/xtn.c	115;"	d	file:
BACKGROUND_GREEN	libstar/xtn.c	116;"	d	file:
BACKGROUND_INTENSITY	libstar/xtn.c	118;"	d	file:
BACKGROUND_RED	libstar/xtn.c	117;"	d	file:
BCC	libstar/ssmtp.h	/^	SRECV          BCC;			\/\/ All Blind Carbon Copy recipients addresses $/;"	m	struct:__anon101
BCCResponse	libstar/ssmtp.h	/^	SRECV          BCCResponse;		\/\/ And for BCC recipients $/;"	m	struct:__anon101
BEL	libstar/xtn.c	182;"	d	file:
BLOCK_SIZE	lib/sha256.c	54;"	d	file:
BLOCK_SIZE	lib/sha512.c	57;"	d	file:
BOOL	json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::final::Type
BOOL_STR	json2.h	26;"	d
BOOL_STR	myjson/json.h	26;"	d
BOOL_STR	myjson/json2.h	26;"	d
BRF	libstar/aria.c	145;"	d	file:
BRK	libstar/xtn.c	192;"	d	file:
BS	libstar/xtn.c	183;"	d	file:
BUFFER_SIZE	lib/test_rc4.c	22;"	d	file:
BUFFSIZE	libstar/netbios.c	598;"	d	file:
BY	libstar/aria.c	144;"	d	file:
BYTE_ORDER	libstar/md5.c	59;"	d	file:
BYTE_ORDER	libstar/md5.c	61;"	d	file:
BYTE_ORDER	libstar/md5.c	63;"	d	file:
BodyBytes	libstar/ssmtp.h	/^	unsigned long BodyBytes;		\/\/ Bytes of body data sent $/;"	m	struct:__anon101
Boundary	libstar/ssmtp.h	/^	char           *Boundary;		\/\/ optional Multipart boundary string $/;"	m	struct:__anon100
Buffer	lib/sha1.h	/^    uint8_t         Buffer[64];$/;"	m	struct:__anon20
CALC_VAL	libstar/snmpsub.c	1281;"	d	file:
CC	libstar/ssmtp.h	/^	SRECV          CC;			\/\/ All Carbon Copy recipients addresses $/;"	m	struct:__anon101
CCResponse	libstar/ssmtp.h	/^	SRECV          CCResponse;		\/\/ The same for CC recipients $/;"	m	struct:__anon101
CHAR64LONG16	lib/sha1.c	/^} CHAR64LONG16;$/;"	t	typeref:union:__anon19	file:
CHECK_TRAIT	json11/test.cpp	53;"	d	file:
CHash	libstar/hash.h	/^	CHash() 	{ m_ht = NULL; }$/;"	f	class:CHash
CHash	libstar/hash.h	/^class CHash {$/;"	c
CMU_COMPATIBLE	libstar/xsnmp.h	46;"	d
COMMENTS	json11/json11.hpp	/^    STANDARD, COMMENTS$/;"	e	enum:json11::JsonParse
CPU_TYPE	libstar/osconfig.h	17;"	d
CR	libstar/xtn.c	188;"	d	file:
CRYPT_DECODE	libstar/aria.h	26;"	d
CRYPT_DECODE	libstar/idea.h	20;"	d
CRYPT_ENCODE	libstar/aria.h	22;"	d
CRYPT_ENCODE	libstar/idea.h	16;"	d
CXList	libstar/xlist.h	/^	CXList(int instsize)				{ m_xl = xlist_init(instsize); }$/;"	f	class:CXList
CXList	libstar/xlist.h	/^class CXList {$/;"	c
CXNms	libstar/xnms.h	/^	CXNms(int max_nodes, uint snmpthreads = 1)	{ m_xnms = xnms_init(max_nodes, snmpthreads); }$/;"	f	class:CXNms
CXNms	libstar/xnms.h	/^class CXNms$/;"	c
CXPing	libstar/xping.h	/^class CXPing {$/;"	c
CXSnmp	libstar/xsnmp.h	/^	CXSnmp()									{ m_xs = xsnmp_init(); }$/;"	f	class:CXSnmp
CXSnmp	libstar/xsnmp.h	/^class CXSnmp$/;"	c
Ch	lib/sha256.c	58;"	d	file:
Ch	lib/sha512.c	65;"	d	file:
Charset	libstar/ssmtp.h	/^	int             Charset;		\/\/ optional charset for text MIME types $/;"	m	struct:__anon100
CheckSum	libstar/xicmp.h	/^	ushort		CheckSum;		\/\/ IP Header checksum$/;"	m	struct:__anon131
Close	libstar/xsnmp.h	/^	void		Close()							{ xsnmp_close(m_xs); }$/;"	f	class:CXSnmp
Count	lib/sha1.h	/^    uint32_t        Count[2];$/;"	m	struct:__anon20
Current	libstar/xlist.h	/^	xlistnode_t	*Current()			{ return xlist_current(m_xl, &m_xloop); }$/;"	f	class:CXList
CustomSubtype	libstar/ssmtp.h	/^	char           *CustomSubtype;		\/\/ optional custom MIME subtype $/;"	m	struct:__anon100
CustomType	libstar/ssmtp.h	/^	char           *CustomType;		\/\/ optional custom MIME type $/;"	m	struct:__anon100
DB2_DB	libstar/xdb.h	/^	DB2_DB,$/;"	e	enum:__anon114
DEFAULT_DOTCOM_HOST	libstar/whois.c	24;"	d	file:
DEFAULT_DOTKR_HOST	libstar/whois.c	23;"	d	file:
DEFAULT_FLOW_PORT	libstar/nflowlib.h	18;"	d
DEFAULT_NETFLOW_PORT	libstar/xflowlib.h	23;"	d
DEFAULT_NFACCTD_PORT	libstar/nflowlib.h	548;"	d
DEFAULT_SFACCTD_PORT	libstar/sflowlib.h	728;"	d
DEFAULT_SFLOW_PORT	libstar/xflowlib.h	24;"	d
DEFAULT_WHOIS_PORT	libstar/whois.c	26;"	d	file:
DEFAULT_WORM_PORT	libstar/worm.h	25;"	d
DEMO_MONTH	libstar/lock.c	57;"	d	file:
DEMO_YEAR	libstar/lock.c	56;"	d	file:
DEV_UDP	libstar/udp.h	25;"	d
DM	libstar/xtn.c	191;"	d	file:
DO	libstar/xtn.c	202;"	d	file:
DONT	libstar/xtn.c	203;"	d	file:
DRIVE_SCAN_METHOD	libstar/dvdlib.h	33;"	d
DRIVE_SCAN_METHOD	libstar/oddlib.h	33;"	d
DS_APP_NUMERIC_IP	libstar/xsnmptrap.c	51;"	d	file:
DVDLIB_API	libstar/dvdlib.h	25;"	d
DVDLIB_API	libstar/dvdlib.h	26;"	d
DVDLIB_API	libstar/dvdlib.h	7;"	d
DVDLIB_API	libstar/dvdlib.h	9;"	d
DVDLIB_EXPORTS	libstar/dvdlib.c	6;"	d	file:
DVD_MARK	libstar/dvdlib.h	38;"	d
DVD_MUST_RECORD	libstar/dvdlib.h	/^	DVD_MUST_RECORD		= 1,$/;"	e	enum:__anon30
DVD_RECORD_OK	libstar/dvdlib.h	/^	DVD_RECORD_OK		= 0$/;"	e	enum:__anon30
DVD_RECORD_WAIT	libstar/dvdlib.h	/^	DVD_RECORD_WAIT		= 2,		\/\/ queue에서 레코딩 기다리는 중..$/;"	e	enum:__anon30
DVD_TYPE_FOLDER	libstar/dvdlib.h	/^	DVD_TYPE_FOLDER		= -1,		\/\/ Folder 같이 레코딩하면 안되는 것..$/;"	e	enum:__anon30
DataProc	libstar/xtn.c	/^	LPDATAPROC DataProc;	\/\/ = ansi;	\/\/ DataProc = terminal[(term_index==NUM_TERMINALS)?(NUM_TERMINALS-1):term_index].termproc;$/;"	m	struct:__anon177	file:
DataProc	libstar/xtn.c	/^	LPDATAPROC DataProc;$/;"	m	struct:ol_st	file:
DecKeySetup	libstar/aria.c	/^static	int DecKeySetup(const uint8 *mk, uint8 *rk, int keyBits)$/;"	f	file:
Delete	libstar/hash.h	/^	void            Delete(hashent_t *he)		{ hash_delete(he); }$/;"	f	class:CHash
Delete	libstar/xlist.h	/^	xlistnode_t	*Delete()			{ return xlist_delete(m_xl, &m_xloop); }$/;"	f	class:CXList
Delete	libstar/xnms.h	/^	int		Delete(uint addr)		{ xnms_delete(m_xnms, addr); }$/;"	f	class:CXNms
DeleteAll	libstar/hash.h	/^	void            DeleteAll(hash_t *ht)		{ hash_deleteall(ht); }$/;"	f	class:CHash
DeleteAll	libstar/xlist.h	/^	void		DeleteAll()			{ xlist_deleteall(m_xl); }$/;"	f	class:CXList
DeleteNode	libstar/xlist.h	/^	xlistnode_t	*DeleteNode(xlistnode_t *node)	{ return xlist_delnode(m_xl, node, &m_xloop); }$/;"	f	class:CXList
Description	libstar/ssmtp.h	/^	char           *Description;		\/\/ MIME part description $/;"	m	struct:__anon100
Detach	libstar/xlist.h	/^	xlistnode_t	*Detach(xlistnode_t *node)	{ return xlist_detach(m_xl, node); }$/;"	f	class:CXList
DialogueBytes	libstar/ssmtp.h	/^	unsigned int    DialogueBytes;		\/\/ Bytes of SMTP dialogue data sent $/;"	m	struct:__anon101
DialogueSent	libstar/ssmtp.h	/^	unsigned int    DialogueSent;		\/\/ Number of SMTP dialogue lines sent $/;"	m	struct:__anon101
DllMain	libstar/dvdlib.c	/^BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)$/;"	f
DllMain	libstar/oddlibwin.c	/^BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)$/;"	f
DriveName	libstar/dvdlib.c	/^	BYTE		DriveName[20];$/;"	m	struct:__anon28	file:
DriveName	libstar/oddlibwin.c	/^	BYTE            DriveName[20];$/;"	m	struct:__anon65	file:
Dump	libstar/hash.h	/^	void            Dump()				{ hash_dump(m_ht); }$/;"	f	class:CHash
EC	libstar/xtn.c	196;"	d	file:
EL	libstar/xtn.c	197;"	d	file:
ENABLE_ECHO_INPUT	libstar/xtn.c	125;"	d	file:
ENABLE_LINE_INPUT	libstar/xtn.c	124;"	d	file:
ENABLE_MOUSE_INPUT	libstar/xtn.c	127;"	d	file:
ENABLE_PROCESSED_INPUT	libstar/xtn.c	123;"	d	file:
ENABLE_WINDOW_INPUT	libstar/xtn.c	126;"	d	file:
ERR_ASPI_BUF_ALLOC_ERROR	libstar/dvdlib.h	/^	ERR_ASPI_BUF_ALLOC_ERROR		,$/;"	e	enum:__anon29
ERR_ASPI_BUF_ALLOC_ERROR	libstar/oddlib.h	/^	  ERR_ASPI_BUF_ALLOC_ERROR                   ,$/;"	e	enum:__anon63
ERR_ASPI_LOAD_FAIL	libstar/dvdlib.h	/^	ERR_ASPI_LOAD_FAIL		= 0x20000000,$/;"	e	enum:__anon29
ERR_ASPI_LOAD_FAIL	libstar/oddlib.h	/^	  ERR_ASPI_LOAD_FAIL             = 0x20000000, \/\/#$/;"	e	enum:__anon63
ERR_CHECK_SENSE	libstar/dvdlib.h	/^	ERR_CHECK_SENSE			= 0x42000000,$/;"	e	enum:__anon29
ERR_CHECK_SENSE	libstar/oddlib.h	/^	  ERR_CHECK_SENSE                = 0x42000000,$/;"	e	enum:__anon63
ERR_DISCK_FULL	libstar/oddlib.h	/^	  ERR_DISCK_FULL                             ,$/;"	e	enum:__anon63
ERR_DISC_NOT_EMPTY	libstar/dvdlib.h	/^	ERR_DISC_NOT_EMPTY			,$/;"	e	enum:__anon29
ERR_DISC_NOT_EMPTY	libstar/oddlib.h	/^	  ERR_DISC_NOT_EMPTY                         ,$/;"	e	enum:__anon63
ERR_DISK_FULL	libstar/dvdlib.h	/^	ERR_DISK_FULL				,$/;"	e	enum:__anon29
ERR_DRIVE_NOT_READY	libstar/dvdlib.h	/^	ERR_DRIVE_NOT_READY		= 0x80020400,$/;"	e	enum:__anon29
ERR_DRIVE_NOT_READY	libstar/oddlib.h	/^	  ERR_DRIVE_NOT_READY            = 0x80020400,$/;"	e	enum:__anon63
ERR_DRV_HANLDE_ERROR	libstar/dvdlib.h	/^	ERR_DRV_HANLDE_ERROR			,$/;"	e	enum:__anon29
ERR_DRV_HANLDE_ERROR	libstar/oddlib.h	/^	  ERR_DRV_HANLDE_ERROR                       ,  \/\/#$/;"	e	enum:__anon63
ERR_DVD_DRIVE_NOT_FOUND	libstar/dvdlib.h	/^	ERR_DVD_DRIVE_NOT_FOUND		= 0x10000000,$/;"	e	enum:__anon29
ERR_EV_BUF_UPDATE_FAIL	libstar/dvdlib.h	/^	ERR_EV_BUF_UPDATE_FAIL		= 0x44000000,$/;"	e	enum:__anon29
ERR_EV_BUF_UPDATE_FAIL	libstar/oddlib.h	/^	  ERR_EV_BUF_UPDATE_FAIL         = 0x44000000,$/;"	e	enum:__anon63
ERR_MEDIA_FAIL	libstar/dvdlib.h	/^	ERR_MEDIA_FAIL			= 0x80020408,$/;"	e	enum:__anon29
ERR_NOT_DVD_MR	libstar/dvdlib.h	/^	ERR_NOT_DVD_MR				,$/;"	e	enum:__anon29
ERR_NOT_DVD_MR	libstar/oddlib.h	/^	  ERR_NOT_DVD_MR                             , \/\/#$/;"	e	enum:__anon63
ERR_NOT_RECORDABLE	libstar/dvdlib.h	/^	ERR_NOT_RECORDABLE		= 0x10000100,$/;"	e	enum:__anon29
ERR_NOT_RECORDABLE	libstar/oddlib.h	/^	  ERR_NOT_RECORDABLE             = 0x10000100,$/;"	e	enum:__anon63
ERR_NOT_RECORDABLE_NOT_BLANK	libstar/dvdlib.h	/^	ERR_NOT_RECORDABLE_NOT_BLANK	= 0x10000200,$/;"	e	enum:__anon29
ERR_NOT_RECORDABLE_NOT_BLANK	libstar/oddlib.h	/^	  ERR_NOT_RECORDABLE_NOT_BLANK   = 0x10000200,$/;"	e	enum:__anon63
ERR_NOT_SUPPORT_LINKSIZE_2K	libstar/dvdlib.h	/^	ERR_NOT_SUPPORT_LINKSIZE_2K		,$/;"	e	enum:__anon29
ERR_NOT_SUPPORT_LINKSIZE_2K	libstar/oddlib.h	/^	  ERR_NOT_SUPPORT_LINKSIZE_2K                ,$/;"	e	enum:__anon63
ERR_NO_MEDIA	libstar/dvdlib.h	/^	ERR_NO_MEDIA			= 0x80023a01,$/;"	e	enum:__anon29
ERR_NO_MEDIA	libstar/oddlib.h	/^	  ERR_NO_MEDIA                   = 0x80023a01,$/;"	e	enum:__anon63
ERR_ODD_DRIVE_NOT_FOUND	libstar/oddlib.h	/^	  ERR_ODD_DRIVE_NOT_FOUND        = 0x10000000,  \/\/#$/;"	e	enum:__anon63
ERR_OK	libstar/dvdlib.h	/^	ERR_OK				= 0,$/;"	e	enum:__anon29
ERR_OK	libstar/oddlib.h	/^	  ERR_OK                         = 0         , \/\/#$/;"	e	enum:__anon63
ERR_SENSE_CODE_MASK	libstar/dvdlib.h	/^	ERR_SENSE_CODE_MASK		= 0x80000000,$/;"	e	enum:__anon29
ERR_SENSE_CODE_MASK	libstar/oddlib.h	/^	  ERR_SENSE_CODE_MASK            = 0x80000000,$/;"	e	enum:__anon63
ERR_SRB_STATUS_MASK	libstar/dvdlib.h	/^	ERR_SRB_STATUS_MASK		= 0x41000000,	\/\/ ~0xFF 까지 마지막 바이트는 SRB Status 값임$/;"	e	enum:__anon29
ERR_SRB_STATUS_MASK	libstar/oddlib.h	/^	  ERR_SRB_STATUS_MASK            = 0x41000000, \/\/ ~0xFF 까지 마지막 바이트는 SRB Status 값임$/;"	e	enum:__anon63
ERR_SRB_TIMEOUT	libstar/dvdlib.h	/^	ERR_SRB_TIMEOUT			= 0x8FFFFFFF$/;"	e	enum:__anon29
ERR_SRB_TIMEOUT	libstar/oddlib.h	/^	  ERR_SRB_TIMEOUT                = 0x8FFFFFFF$/;"	e	enum:__anon63
ERR_SRB_UNIT_ATTENTION	libstar/dvdlib.h	/^	ERR_SRB_UNIT_ATTENTION		= 0x88000000,	\/\/ UNIT Attention code$/;"	e	enum:__anon29
ERR_SRB_UNIT_ATTENTION	libstar/oddlib.h	/^	  ERR_SRB_UNIT_ATTENTION         = 0x88000000, \/\/ UNIT Attention code$/;"	e	enum:__anon63
ERR_TRACK_NUM_WRONG	libstar/dvdlib.h	/^	ERR_TRACK_NUM_WRONG			,$/;"	e	enum:__anon29
ERR_TRACK_NUM_WRONG	libstar/oddlib.h	/^	  ERR_TRACK_NUM_WRONG                        ,$/;"	e	enum:__anon63
ERR_UNKOWN_ERROR	libstar/dvdlib.h	/^	ERR_UNKOWN_ERROR		= 0x48000000,$/;"	e	enum:__anon29
ERR_UNKOWN_ERROR	libstar/oddlib.h	/^	  ERR_UNKOWN_ERROR               = 0x48000000, \/\/#$/;"	e	enum:__anon63
ERR_WRONG_DRIVE_LETTER	libstar/dvdlib.h	/^	ERR_WRONG_DRIVE_LETTER			,$/;"	e	enum:__anon29
ERR_WRONG_DRIVE_LETTER	libstar/oddlib.h	/^	  ERR_WRONG_DRIVE_LETTER                     ,$/;"	e	enum:__anon63
ERR_WRONG_DRIVE_NAME	libstar/dvdlib.h	/^	ERR_WRONG_DRIVE_NAME,$/;"	e	enum:__anon29
ERR_WRONG_DRIVE_NAME	libstar/oddlib.h	/^	  ERR_WRONG_DRIVE_NAME   ,$/;"	e	enum:__anon63
ESC_KEY	libstar/xtn.c	31;"	d	file:
ETHERTYPE_8021Q	libstar/sflowlib.c	869;"	d	file:
ETHERTYPE_MPLS	libstar/sflowlib.c	870;"	d	file:
ETHERTYPE_MPLS_MULTI	libstar/sflowlib.c	871;"	d	file:
EV_CLOSE	libstar/gw.h	/^	EV_CLOSE,			\/\/ Event type: 소켓 종료됨 $/;"	e	enum:__anon37
EV_CONNECT	libstar/gw.h	/^	EV_CONNECT = 0,			\/\/ Event type: 정상 연결이 이루어짐 $/;"	e	enum:__anon37
EV_FAIL_DUP	libstar/gw.h	/^	EV_FAIL_DUP,			\/\/ Event type: 이미 연결이 이루어져 있고 동일 IP에서 재연결은$/;"	e	enum:__anon37
EV_FAIL_FULL	libstar/gw.h	/^	EV_FAIL_FULL,			\/\/ 최대 허용한도를 초과해서 연결을 하려는 경우.. (numaccepted >= maxclients)$/;"	e	enum:__anon37
EV_HW_DEL_IFINDEX	libstar/xnms.h	/^	EV_HW_DEL_IFINDEX,$/;"	e	enum:__anon144
EV_HW_IFALIAS_CHANGE	libstar/xnms.h	/^	EV_HW_IFALIAS_CHANGE,$/;"	e	enum:__anon144
EV_HW_IFDESCR_CHANGE	libstar/xnms.h	/^	EV_HW_IFDESCR_CHANGE,$/;"	e	enum:__anon144
EV_HW_IFMAC_CHANGE	libstar/xnms.h	/^	EV_HW_IFMAC_CHANGE,$/;"	e	enum:__anon144
EV_HW_IFMTU_CHANGE	libstar/xnms.h	/^	EV_HW_IFMTU_CHANGE,$/;"	e	enum:__anon144
EV_HW_IFSPEED_CHANGE	libstar/xnms.h	/^	EV_HW_IFSPEED_CHANGE,$/;"	e	enum:__anon144
EV_HW_IFTYPE_CHANGE	libstar/xnms.h	/^	EV_HW_IFTYPE_CHANGE,$/;"	e	enum:__anon144
EV_HW_NEW_IFINDEX	libstar/xnms.h	/^	EV_HW_NEW_IFINDEX,$/;"	e	enum:__anon144
EV_HW_NUMIF_CHANGE	libstar/xnms.h	/^	EV_HW_NUMIF_CHANGE,$/;"	e	enum:__anon144
EV_IF_ADMIN_DOWN	libstar/xnms.h	/^	EV_IF_ADMIN_DOWN,$/;"	e	enum:__anon144
EV_IF_ADMIN_ETC	libstar/xnms.h	/^	EV_IF_ADMIN_ETC,	\/\/ Up\/Down 외의 기타 상태$/;"	e	enum:__anon144
EV_IF_ADMIN_UP	libstar/xnms.h	/^	EV_IF_ADMIN_UP,$/;"	e	enum:__anon144
EV_IF_BPS	libstar/xnms.h	/^	EV_IF_BPS,		\/\/ BPS 트래픽 임계치 초과$/;"	e	enum:__anon144
EV_IF_OPER_DOWN	libstar/xnms.h	/^	EV_IF_OPER_DOWN,$/;"	e	enum:__anon144
EV_IF_OPER_ETC	libstar/xnms.h	/^	EV_IF_OPER_ETC,		\/\/ Up\/Down 외의 기타 상태$/;"	e	enum:__anon144
EV_IF_OPER_UP	libstar/xnms.h	/^	EV_IF_OPER_UP,$/;"	e	enum:__anon144
EV_IF_PPS	libstar/xnms.h	/^	EV_IF_PPS,		\/\/ PPS 트래픽 임계치 초과$/;"	e	enum:__anon144
EV_NODE_ADD	libstar/xnms.h	/^	EV_NODE_ADD,		\/\/ 신규 노드 추가$/;"	e	enum:__anon144
EV_NODE_DEL	libstar/xnms.h	/^	EV_NODE_DEL,		\/\/ 노드 제거$/;"	e	enum:__anon144
EV_PING_FAIL	libstar/xnms.h	/^	EV_PING_FAIL,		\/\/ PING 실패$/;"	e	enum:__anon144
EV_PING_FAIL1	libstar/xnms.h	/^	EV_PING_FAIL1,		\/\/ PING 실패 1회 => MINOR (ping_fail_step_event 설정된 경우)$/;"	e	enum:__anon144
EV_PING_FAIL2	libstar/xnms.h	/^	EV_PING_FAIL2,		\/\/ PING 실패 2회 => MINOR (ping_fail_step_event 설정된 경우) 3회는 EV_PING_FAIL임 $/;"	e	enum:__anon144
EV_PING_OFF	libstar/xnms.h	/^	EV_PING_OFF,		\/\/ PING pingstop번 연속 실패로 해당 노드에 대해 PING 기능 영구 정지$/;"	e	enum:__anon144
EV_PING_OK	libstar/xnms.h	/^	EV_PING_OK,		\/\/ PING 성공$/;"	e	enum:__anon144
EV_PORT_DOWN	libstar/xnms.h	/^	EV_PORT_DOWN,$/;"	e	enum:__anon144
EV_PORT_ETC	libstar/xnms.h	/^	EV_PORT_ETC,$/;"	e	enum:__anon144
EV_PORT_UP	libstar/xnms.h	/^	EV_PORT_UP,$/;"	e	enum:__anon144
EV_RECONNECT	libstar/gw.h	/^	EV_RECONNECT,			\/\/ 동일한 IP, port에서 재연결이 온 경우..$/;"	e	enum:__anon37
EV_RECV	libstar/gw.h	/^	EV_RECV,			\/\/ Event type: 데이터 도착함 $/;"	e	enum:__anon37
EV_SEND	libstar/gw.h	/^	EV_SEND,			\/\/ Event type: 데이터 전송함 $/;"	e	enum:__anon37
EV_SNMP_FAIL	libstar/xnms.h	/^	EV_SNMP_FAIL,		\/\/ SNMP 실패$/;"	e	enum:__anon144
EV_SNMP_OFF	libstar/xnms.h	/^	EV_SNMP_OFF,		\/\/ SNMP snmpstop번 연속 실패로 해당 노드에 대해 SNMP 기능 영구 정지$/;"	e	enum:__anon144
EV_SNMP_OK	libstar/xnms.h	/^	EV_SNMP_OK,		\/\/ SNMP 성공$/;"	e	enum:__anon144
EV_SNMP_RETRY	libstar/xnms.h	/^	EV_SNMP_RETRY,		\/\/ SNMP 재시도$/;"	e	enum:__anon144
EV_VPN_TNL_DOWN	libstar/xnms.h	/^	EV_VPN_TNL_DOWN,$/;"	e	enum:__anon144
EV_VPN_TNL_ETC	libstar/xnms.h	/^	EV_VPN_TNL_ETC,$/;"	e	enum:__anon144
EV_VPN_TNL_UP	libstar/xnms.h	/^	EV_VPN_TNL_UP,$/;"	e	enum:__anon144
EV_XPING_BEGIN	libstar/xping.h	/^	EV_XPING_BEGIN = 0,			\/\/ 해당 IP에 대해 Ping이 시작된 경우$/;"	e	enum:__anon155
EV_XPING_END	libstar/xping.h	/^	EV_XPING_END,				\/\/ 해당 IP에 대해 Ping이 끝난 경우$/;"	e	enum:__anon155
EV_XPING_FAIL	libstar/xping.h	/^	EV_XPING_FAIL,				\/\/ Ping 실패$/;"	e	enum:__anon155
EV_XPING_OK	libstar/xping.h	/^	EV_XPING_OK,				\/\/ Ping 성공$/;"	e	enum:__anon155
EV_XPING_RETRY	libstar/xping.h	/^	EV_XPING_RETRY,				\/\/ Ping 재시도 중$/;"	e	enum:__anon155
EV_XPING_SYNC	libstar/xnms.h	/^	EV_XPING_SYNC,		\/\/ XPING으로 전달..$/;"	e	enum:__anon144
EXP_MASK	libstar/sflowlib.h	947;"	d
EXP_SHIFT	libstar/sflowlib.h	948;"	d
E_CREATE_RAW_SEND	hdaclib.h	/^	E_CREATE_RAW_SEND	= -202,$/;"	e	enum:__anon2
E_CREATE_STREAM	hdaclib.h	/^	E_CREATE_STREAM		= -102,$/;"	e	enum:__anon2
E_END_ERROR	hdaclib.h	/^	E_END_ERROR		= -999$/;"	e	enum:__anon2
E_EXIST	hdaclib.h	/^	E_EXIST			= -2,$/;"	e	enum:__anon2
E_FAIL	hdaclib.h	/^	E_FAIL			= -5,$/;"	e	enum:__anon2
E_GRANT_PERM	hdaclib.h	/^	E_GRANT_PERM		= -103,$/;"	e	enum:__anon2
E_HDAC_SEND_LIMIT	hdaclib.h	/^	E_HDAC_SEND_LIMIT	= -9,$/;"	e	enum:__anon2
E_IMPORT_ADDRESS	hdaclib.h	/^	E_IMPORT_ADDRESS	= -201,$/;"	e	enum:__anon2
E_ISSUE	hdaclib.h	/^	E_ISSUE			= -301,$/;"	e	enum:__anon2
E_MULTISIG_ADDRESS	hdaclib.h	/^	E_MULTISIG_ADDRESS	= -200,$/;"	e	enum:__anon2
E_NOT_FOUND	hdaclib.h	/^	E_NOT_FOUND		= -1,$/;"	e	enum:__anon2
E_NULL_ARG	hdaclib.h	/^	E_NULL_ARG		= -100,$/;"	e	enum:__anon2
E_OK	hdaclib.h	/^	E_OK			= 0,$/;"	e	enum:__anon2
E_READ_ERROR	hdaclib.h	/^	E_READ_ERROR		= -4,$/;"	e	enum:__anon2
E_SEND_RAW_TX	hdaclib.h	/^	E_SEND_RAW_TX		= -204,$/;"	e	enum:__anon2
E_SIGN_RAW_TX	hdaclib.h	/^	E_SIGN_RAW_TX		= -203,$/;"	e	enum:__anon2
E_STREAM_NOT_FOUND	hdaclib.h	/^	E_STREAM_NOT_FOUND	= -104,$/;"	e	enum:__anon2
E_STREAM_NO_PERM	hdaclib.h	/^	E_STREAM_NO_PERM	= -105,$/;"	e	enum:__anon2
E_WRITE_ERROR	hdaclib.h	/^	E_WRITE_ERROR		= -3,$/;"	e	enum:__anon2
E_WRONG_PERM	hdaclib.h	/^	E_WRONG_PERM		= -101,$/;"	e	enum:__anon2
EncKeySetup	libstar/aria.c	/^static	int EncKeySetup(const uint8 *mk, uint8 *rk, int keyBits)$/;"	f	file:
Encoding	libstar/ssmtp.h	/^	int             Encoding;		\/\/ MIME transfer encoding $/;"	m	struct:__anon100
F	lib/md5.c	22;"	d	file:
F	libstar/md5.c	204;"	d	file:
FALSE	libstar/type.h	29;"	d
FE	libstar/aria.c	222;"	d	file:
FF	libstar/xtn.c	187;"	d	file:
FHASH_ALLOC	libstar/fhash.c	22;"	d	file:
FHASH_ALLOC	libstar/fhash.c	25;"	d	file:
FHASH_FREE	libstar/fhash.c	23;"	d	file:
FHASH_FREE	libstar/fhash.c	26;"	d	file:
FHASH_FUNC	libstar/fhash.c	32;"	d	file:
FHASH_FUNC	libstar/fhash.c	34;"	d	file:
FHASH_HDRSZ	libstar/fhash.h	26;"	d
FLOW_RAW_VER	libstar/xflowlib.h	28;"	d
FLOW_SAVE_SIZE	libstar/xflowlib.h	29;"	d
FL_BROADCAST	libstar/netbios.c	43;"	d	file:
FL_DGRAM_NOT_TRUNCATED	libstar/netbios.c	38;"	d	file:
FL_NON_AUTH_ANSWER	libstar/netbios.c	37;"	d	file:
FL_QUERY	libstar/netbios.c	36;"	d	file:
FL_RECURSION_NOT_AVAIl	libstar/netbios.c	40;"	d	file:
FL_RECURSION_NOT_DESIRED	libstar/netbios.c	39;"	d	file:
FL_REQUEST	libstar/netbios.c	35;"	d	file:
FL_RESERVED1	libstar/netbios.c	41;"	d	file:
FL_RESERVED2	libstar/netbios.c	42;"	d	file:
FL_SUCCESS	libstar/netbios.c	44;"	d	file:
FO	libstar/aria.c	221;"	d	file:
FOREGROUND_BLUE	libstar/xtn.c	111;"	d	file:
FOREGROUND_GREEN	libstar/xtn.c	112;"	d	file:
FOREGROUND_INTENSITY	libstar/xtn.c	114;"	d	file:
FOREGROUND_RED	libstar/xtn.c	113;"	d	file:
FREEASPI32BUFFER	libstar/dvdlib.c	/^typedef BOOL(*FREEASPI32BUFFER) (PASPI32BUFF);$/;"	t	file:
FREEASPI32BUFFER	libstar/oddlibwin.c	/^typedef         BOOL(*FREEASPI32BUFFER) (PASPI32BUFF);$/;"	t	file:
FROM_CLIENT	libstar/gw.h	/^	FROM_CLIENT	= 0,$/;"	e	enum:__anon37
FROM_GATEWAY	libstar/gw.h	/^	FROM_GATEWAY,$/;"	e	enum:__anon37
FTP_APPEND	libstar/xapp.h	/^	FTP_APPEND	= 2,$/;"	e	enum:__anon112
FTP_ASCII	libstar/xapp.h	/^	FTP_ASCII	= 0,$/;"	e	enum:__anon112
FTP_BINARY	libstar/xapp.h	/^	FTP_BINARY	= 1,$/;"	e	enum:__anon112
FTP_FAIL	libstar/xapp.h	56;"	d
FTP_GET	libstar/xapp.h	/^	FTP_GET		= 0,$/;"	e	enum:__anon112
FTP_LIST	libstar/xapp.h	/^	FTP_LIST	= 3,$/;"	e	enum:__anon112
FTP_OK	libstar/xapp.h	55;"	d
FTP_PUT	libstar/xapp.h	/^	FTP_PUT		= 1,$/;"	e	enum:__anon112
F_ALLSUM	libstar/snoop.h	66;"	d
F_DETAIL	libstar/snoop.h	67;"	d
F_GETNAME	libstar/xpcap.h	61;"	d
F_SUM	libstar/snoop.h	65;"	d
F_XPING_EXIT	libstar/xping.h	/^	F_XPING_EXIT		= 0x0010,$/;"	e	enum:__anon155
F_XPING_RECV_START	libstar/xping.h	/^	F_XPING_RECV_START	= 0x0008,$/;"	e	enum:__anon155
F_XPING_SEND_START	libstar/xping.h	/^	F_XPING_SEND_START	= 0x0004,$/;"	e	enum:__anon155
F_XPING_START	libstar/xping.h	/^	F_XPING_START		= 0x0001,$/;"	e	enum:__anon155
F_XPING_STOP	libstar/xping.h	/^	F_XPING_STOP		= 0x0002,$/;"	e	enum:__anon155
Find	libstar/hash.h	/^	hashent_t	*Find(void *key, uint keylen)	{ return hash_find(m_ht, key, keylen); }$/;"	f	class:CHash
FindIf	libstar/xsnmp.h	/^	snmpif_t	*FindIf(char *ipaddr)				{ return xsnmp_findifbyaddr(m_xs, ipaddr); }$/;"	f	class:CXSnmp
FindIf	libstar/xsnmp.h	/^	snmpif_t	*FindIf(int ifIndex)				{ return xsnmp_findifbyidx(m_xs, ifIndex); }$/;"	f	class:CXSnmp
FindLoop	libstar/hash.h	/^	hashent_t	*FindLoop(hashloop_t *lp, void *key, uint keylen)	{ return hash_findloop(m_ht, lp, key, keylen); }$/;"	f	class:CHash
FindNext	libstar/hash.h	/^	hashent_t	*FindNext(hashloop_t *lp)			{ return hash_findnext(m_ht, lp); }$/;"	f	class:CHash
First	libstar/hash.h	/^	hashent_t	*First(hashloop_t *lp)			{ return hash_first(m_ht, lp); }$/;"	f	class:CHash
First	libstar/xlist.h	/^	xlistnode_t	*First()			{ return xlist_first(m_xl, &m_xloop); }$/;"	f	class:CXList
FragmentationFlags	libstar/xicmp.h	/^	ushort		FragmentationFlags;	\/\/ flags$/;"	m	struct:__anon131
From	libstar/ssmtp.h	/^	char            From[MAX_DOMAIN_LEN];	\/\/ From address $/;"	m	struct:__anon101
G	lib/md5.c	23;"	d	file:
G	libstar/md5.c	230;"	d	file:
GA	libstar/xtn.c	198;"	d	file:
GATEWAY_PORT	libstar/gw.h	47;"	d
GET	lib/md5.c	40;"	d	file:
GETASPI32BUFFER	libstar/dvdlib.c	/^typedef BOOL(*GETASPI32BUFFER) (PASPI32BUFF);$/;"	t	file:
GETASPI32BUFFER	libstar/oddlibwin.c	/^typedef         BOOL(*GETASPI32BUFFER) (PASPI32BUFF);$/;"	t	file:
GETASPI32SUPPORTINFO	libstar/dvdlib.c	/^typedef DWORD(*GETASPI32SUPPORTINFO) (void);$/;"	t	file:
GETASPI32SUPPORTINFO	libstar/oddlibwin.c	/^typedef         DWORD(*GETASPI32SUPPORTINFO) (void);$/;"	t	file:
GSRK	libstar/aria.c	226;"	d	file:
GW_AGENT	libstar/gw.h	/^	GW_AGENT	= 0x0002,	\/\/ 고정된 노드 타입 : Agent$/;"	e	enum:__anon37
GW_GATEWAY	libstar/gw.h	/^	GW_GATEWAY	= 0x0001,	\/\/ 고정된 노드 타입 : Gateway$/;"	e	enum:__anon37
GW_MANAGER	libstar/gw.h	/^	GW_MANAGER	= 0x0004,	\/\/ 고정된 노드 타입 : Manager$/;"	e	enum:__anon37
GW_NOTIFY	libstar/gw.h	/^	GW_NOTIFY	= 0x8000000,	\/\/ 최초로 G\/W 시스템에 접속하는 모든 address는 해당 접속자와 ID에 대해 상호 교환 $/;"	e	enum:__anon37
GW_ROUTE_ADD	libstar/gw.h	/^	GW_ROUTE_ADD	= 0x0008,	\/\/ 라우팅 테이블에서 첨부된 주소를 포함 (하위에서 Master까지만 전송)$/;"	e	enum:__anon37
GW_ROUTE_DEL	libstar/gw.h	/^	GW_ROUTE_DEL	= 0x0010,	\/\/ 라우팅 테이블에서 첨부된 주소를 제거 (하위에서 Master까지만 전송)$/;"	e	enum:__anon37
GW_TYPE_MASK	libstar/gw.h	/^	GW_TYPE_MASK	= 0x0000FFFF,	\/\/ 아래 타입만 골라낼 때 $/;"	e	enum:__anon37
GW_UNIQ_MASK	libstar/gw.h	46;"	d
GW__DEBUG	libstar/gw.h	/^	GW__DEBUG	= 0x4000000,	\/\/ 디버깅용 $/;"	e	enum:__anon37
Gamma0	lib/sha256.c	64;"	d	file:
Gamma0	lib/sha512.c	71;"	d	file:
Gamma1	lib/sha256.c	65;"	d	file:
Gamma1	lib/sha512.c	72;"	d	file:
Gbytes	libstar/xflowlib.h	/^	uint32		Gbytes;$/;"	m	struct:__anon129
Get	libstar/xlist.h	/^	xlistnode_t	*Get(int nth)			{ return xlist_get(m_xl, nth); }$/;"	f	class:CXList
Get	libstar/xnms.h	/^	xnmsnode_t	*Get(uint addr)			{ xnms_get(m_xnms, addr); }$/;"	f	class:CXNms
Get	libstar/xsnmp.h	/^	BOOL		Get()							{ return xsnmp_get(m_xs); }$/;"	f	class:CXSnmp
GetAddrStr	libstar/xsnmp.h	/^	CString		GetAddrStr(uint idx)			{ CString str = xsnmp_getaddrstr(m_xs, m_buf1, sizeof(m_buf1), idx); return str; }$/;"	f	class:CXSnmp
GetAll	libstar/xsnmp.h	/^	snmpinfo_t	*GetAll()						{ return xsnmp_getallsnmp(m_xs); }$/;"	f	class:CXSnmp
GetAt	libstar/xsnmp.h	/^	snmpat_t	*GetAt(int *retnat)					{ return xsnmp_getat(m_xs, retnat); }$/;"	f	class:CXSnmp
GetAt	libstar/xsnmp.h	/^	snmpinfo_t	*GetAt(snmpinfo_t *snmpi)			{ return xsnmp_getsnmpat(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetAtCount	libstar/xsnmp.h	/^	uint		GetAtCount()						{ return xsnmp_getatcount(m_xs); }$/;"	f	class:CXSnmp
GetConsoleMode	libstar/xtn.c	103;"	d	file:
GetCounter	libstar/xsnmp.h	/^	uint		GetCounter(uint idx)			{ return GetInt(idx); }$/;"	f	class:CXSnmp
GetData	libstar/hash.h	/^	void		*GetData(hashent_t *he, int *datalen)	{ return hash_getdata(he, datalen); }$/;"	f	class:CHash
GetData	libstar/xlist.h	/^	void		*GetData(xlistnode_t *node, int *datalen)		{ return xlist_getdata(node, datalen); }$/;"	f	class:CXList
GetDataStr	libstar/xsnmp.h	/^	CString		GetDataStr(uint idx)			{ CString str = xsnmp_getdatastr(m_xs, m_buf1, sizeof(m_buf1), idx); return str; }$/;"	f	class:CXSnmp
GetDouble	libstar/xsnmp.h	/^	double		GetDouble(uint idx)				{ xsnmp_getdouble(m_xs, idx); }$/;"	f	class:CXSnmp
GetEntry	libstar/xsnmp.h	/^	void		GetEntry(snmpinfo_t *numi)		{ xsnmp_getentry(m_xs, numi); }$/;"	f	class:CXSnmp
GetFloat	libstar/xsnmp.h	/^	float		GetFloat(uint idx)				{ xsnmp_getfloat(m_xs, idx); }$/;"	f	class:CXSnmp
GetGauge	libstar/xsnmp.h	/^	uint		GetGauge(uint idx)				{ return GetInt(idx); }$/;"	f	class:CXSnmp
GetIcmp	libstar/xsnmp.h	/^	snmpicmp_t	*GetIcmp()							{ return xsnmp_geticmp(m_xs); }$/;"	f	class:CXSnmp
GetIcmp	libstar/xsnmp.h	/^	snmpinfo_t	*GetIcmp(snmpinfo_t *snmpi)			{ return xsnmp_getsnmpicmp(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetIf	libstar/xsnmp.h	/^	snmpif_t	*GetIf(int *retnif)				{ return xsnmp_getif(m_xs, retnif); }$/;"	f	class:CXSnmp
GetIf	libstar/xsnmp.h	/^	snmpinfo_t	*GetIf(snmpinfo_t *snmpi)		{ return xsnmp_getsnmpif(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetIfCount	libstar/xsnmp.h	/^	uint		GetIfCount()					{ return xsnmp_getifcount(m_xs); }$/;"	f	class:CXSnmp
GetInt	libstar/xsnmp.h	/^	int			GetInt(uint idx)				{ return xsnmp_getint(m_xs, idx); }$/;"	f	class:CXSnmp
GetInt64	libstar/xsnmp.h	/^	LONGLONG	GetInt64(uint idx)				{ xsnmp_getint64(m_xs, idx); }$/;"	f	class:CXSnmp
GetIp	libstar/xsnmp.h	/^	snmpinfo_t	*GetIp(snmpinfo_t *snmpi)			{ return xsnmp_getsnmpip(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetIp	libstar/xsnmp.h	/^	snmpip_t	*GetIp()							{ return xsnmp_getip(m_xs); }$/;"	f	class:CXSnmp
GetKey	libstar/hash.h	/^	void		*GetKey(hashent_t *he, int *keylen)	{ return hash_getkey(he, keylen); }$/;"	f	class:CHash
GetNet2Media	libstar/xsnmp.h	/^	snmpinfo_t	*GetNet2Media(snmpinfo_t *snmpi)	{ return xsnmp_getsnmpnet2media(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetNet2MediaCount	libstar/xsnmp.h	/^	uint		GetNet2MediaCount()					{ return xsnmp_getnet2mediacount(m_xs); }$/;"	f	class:CXSnmp
GetNext	libstar/xsnmp.h	/^	BOOL		GetNext()						{ return xsnmp_getnext(m_xs); }$/;"	f	class:CXSnmp
GetOid	libstar/xsnmp.h	/^	oid		*GetOid(uint idx)					{ return xsnmp_getoid(m_xs, idx); }$/;"	f	class:CXSnmp
GetOidStr	libstar/xsnmp.h	/^	CString		GetOidStr(uint idx)				{ CString str = xsnmp_getoidstr(m_xs, m_buf1, sizeof(m_buf1), idx); return str; }$/;"	f	class:CXSnmp
GetRoute	libstar/xsnmp.h	/^	snmpinfo_t	*GetRoute(snmpinfo_t *snmpi)		{ return xsnmp_getsnmproute(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetRoute	libstar/xsnmp.h	/^	snmproute_t	*GetRoute(int *retnroute)			{ return xsnmp_getroute(m_xs, retnroute); }$/;"	f	class:CXSnmp
GetRouteCount	libstar/xsnmp.h	/^	uint		GetRouteCount()						{ return xsnmp_getroutecount(m_xs); }$/;"	f	class:CXSnmp
GetSize	libstar/xlist.h	/^	int	GetSize()				{ return xlist_getsize(m_xl); }$/;"	f	class:CXList
GetSize	libstar/xsnmp.h	/^	int		GetSize()							{ return xsnmp_getsize(m_xs); }$/;"	f	class:CXSnmp
GetStr	libstar/xsnmp.h	/^	CString		GetStr(uint idx)				{ CString str = xsnmp_getstr(m_xs, m_buf1, sizeof(m_buf1), idx); return str; }$/;"	f	class:CXSnmp
GetSys	libstar/xsnmp.h	/^	snmpinfo_t	*GetSys(snmpinfo_t *snmpi)		{ return xsnmp_getsnmpsys(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetSys	libstar/xsnmp.h	/^	snmpsys_t	*GetSys()						{ return xsnmp_getsys(m_xs); }$/;"	f	class:CXSnmp
GetTcp	libstar/xsnmp.h	/^	snmpinfo_t	*GetTcp(snmpinfo_t *snmpi)			{ return xsnmp_getsnmptcp(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetTcpConn	libstar/xsnmp.h	/^	snmpinfo_t	*GetTcpConn(snmpinfo_t *snmpi)		{ return xsnmp_getsnmptcpconn(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetTcpConnCount	libstar/xsnmp.h	/^	uint		GetTcpConnCount()					{ return xsnmp_gettcpconncount(m_xs); }$/;"	f	class:CXSnmp
GetTimeticks	libstar/xsnmp.h	/^	uint		GetTimeticks(uint idx)			{ return GetInt(idx); }$/;"	f	class:CXSnmp
GetUInt	libstar/xsnmp.h	/^	uint		GetUInt(uint idx)				{ xsnmp_getuint(m_xs, idx); }$/;"	f	class:CXSnmp
GetUdp	libstar/xsnmp.h	/^	snmpinfo_t	*GetUdp(snmpinfo_t *snmpi)			{ return xsnmp_getsnmpudp(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetUdpConn	libstar/xsnmp.h	/^	snmpinfo_t	*GetUdpConn(snmpinfo_t *snmpi)		{ return xsnmp_getsnmpudpconn(m_xs, snmpi); }$/;"	f	class:CXSnmp
GetUdpConnCount	libstar/xsnmp.h	/^	uint		GetUdpConnCount()					{ return xsnmp_getudpconncount(m_xs); }$/;"	f	class:CXSnmp
GetVar	libstar/xsnmp.h	/^	SnmpVarList	*GetVar(uint idx)				{ return xsnmp_getvar(m_xs, idx); }$/;"	f	class:CXSnmp
GetWinAppHomeDir	libstar/xutil.c	/^CString	GetWinAppHomeDir()$/;"	f
Gpkts	libstar/xflowlib.h	/^	uint32		Gpkts;$/;"	m	struct:__anon129
H	lib/md5.c	24;"	d	file:
H	libstar/md5.c	256;"	d	file:
HASHLEN	libstar/xhash.c	929;"	d	file:
HASHSTATE	libstar/xhash.c	928;"	d	file:
HASH_ALLOC	libstar/hash.c	33;"	d	file:
HASH_ALLOC	libstar/hash.c	36;"	d	file:
HASH_BIG_ENDIAN	libstar/xhash.h	38;"	d
HASH_BIG_ENDIAN	libstar/xhash.h	45;"	d
HASH_BIG_ENDIAN	libstar/xhash.h	50;"	d
HASH_DEBUG	libstar/hash.c	30;"	d	file:
HASH_FREE	libstar/hash.c	34;"	d	file:
HASH_FREE	libstar/hash.c	37;"	d	file:
HASH_FUNC	libstar/hash.c	45;"	d	file:
HASH_FUNC	libstar/hash.c	47;"	d	file:
HASH_LITTLE_ENDIAN	libstar/xhash.h	37;"	d
HASH_LITTLE_ENDIAN	libstar/xhash.h	44;"	d
HASH_LITTLE_ENDIAN	libstar/xhash.h	49;"	d
HDAC_ADDR_LEN	hdaclib.h	21;"	d
HDAC_MAX_MULTISIG	hdaclib.h	173;"	d
HDAC_MAX_SEND_LIMIT	hdaclib.h	127;"	d
HDAC_PUBKEY_LEN	hdaclib.h	172;"	d
HDAC_TX_LEN	hdaclib.h	22;"	d
HT	libstar/xtn.c	184;"	d	file:
HTTP_URL_HOSTNAME	libstar/xapp.h	/^	HTTP_URL_HOSTNAME	= 1,$/;"	e	enum:__anon111
HTTP_URL_IP	libstar/xapp.h	/^	HTTP_URL_IP		= 0,$/;"	e	enum:__anon111
HeaderBytes	libstar/ssmtp.h	/^	unsigned int    HeaderBytes;		\/\/ Bytes of header data sent $/;"	m	struct:__anon101
HeaderLength	libstar/xicmp.h	/^	uchar		HeaderLength:4;		\/\/ length of the header$/;"	m	struct:__anon131
HeadersSent	libstar/ssmtp.h	/^	unsigned int    HeadersSent;		\/\/ Number of header lines sent $/;"	m	struct:__anon101
I	lib/md5.c	25;"	d	file:
I	libstar/md5.c	282;"	d	file:
IAC	libstar/xtn.c	204;"	d	file:
ICMP_ADDRESS	libstar/xicmp.h	54;"	d
ICMP_ADDRESS	libstar/xping.h	59;"	d
ICMP_ADDRESSREPLY	libstar/xicmp.h	55;"	d
ICMP_ADDRESSREPLY	libstar/xping.h	60;"	d
ICMP_DEST_UNREACH	libstar/xicmp.h	44;"	d
ICMP_DEST_UNREACH	libstar/xping.h	47;"	d
ICMP_ECHO	libstar/xicmp.h	47;"	d
ICMP_ECHO	libstar/xping.h	50;"	d
ICMP_ECHOREPLY	libstar/xicmp.h	43;"	d
ICMP_ECHOREPLY	libstar/xping.h	44;"	d
ICMP_EXC_FRAGTIME	libstar/xicmp.h	86;"	d
ICMP_EXC_TTL	libstar/xicmp.h	85;"	d
ICMP_FRAG_NEEDED	libstar/xicmp.h	64;"	d
ICMP_HOST_ANO	libstar/xicmp.h	70;"	d
ICMP_HOST_ISOLATED	libstar/xicmp.h	68;"	d
ICMP_HOST_UNKNOWN	libstar/xicmp.h	67;"	d
ICMP_HOST_UNREACH	libstar/xicmp.h	61;"	d
ICMP_HOST_UNR_TOS	libstar/xicmp.h	72;"	d
ICMP_INFO_REPLY	libstar/xicmp.h	53;"	d
ICMP_INFO_REPLY	libstar/xping.h	58;"	d
ICMP_INFO_REQUEST	libstar/xicmp.h	52;"	d
ICMP_INFO_REQUEST	libstar/xping.h	57;"	d
ICMP_MIN	libstar/xicmp.h	38;"	d
ICMP_NET_ANO	libstar/xicmp.h	69;"	d
ICMP_NET_UNKNOWN	libstar/xicmp.h	66;"	d
ICMP_NET_UNREACH	libstar/xicmp.h	60;"	d
ICMP_NET_UNR_TOS	libstar/xicmp.h	71;"	d
ICMP_PARAMETERPROB	libstar/xicmp.h	49;"	d
ICMP_PARAMETERPROB	libstar/xping.h	54;"	d
ICMP_PKT_FILTERED	libstar/xicmp.h	73;"	d
ICMP_PORT_UNREACH	libstar/xicmp.h	63;"	d
ICMP_PREC_CUTOFF	libstar/xicmp.h	75;"	d
ICMP_PREC_VIOLATION	libstar/xicmp.h	74;"	d
ICMP_PROT_UNREACH	libstar/xicmp.h	62;"	d
ICMP_REDIRECT	libstar/xicmp.h	46;"	d
ICMP_REDIRECT	libstar/xping.h	49;"	d
ICMP_REDIR_HOST	libstar/xicmp.h	80;"	d
ICMP_REDIR_HOSTTOS	libstar/xicmp.h	82;"	d
ICMP_REDIR_NET	libstar/xicmp.h	79;"	d
ICMP_REDIR_NETTOS	libstar/xicmp.h	81;"	d
ICMP_SOURCE_QUENCH	libstar/xicmp.h	45;"	d
ICMP_SOURCE_QUENCH	libstar/xping.h	48;"	d
ICMP_SR_FAILED	libstar/xicmp.h	65;"	d
ICMP_TIMESTAMP	libstar/xicmp.h	50;"	d
ICMP_TIMESTAMP	libstar/xping.h	55;"	d
ICMP_TIMESTAMPREPLY	libstar/xicmp.h	51;"	d
ICMP_TIMESTAMPREPLY	libstar/xping.h	56;"	d
ICMP_TIME_EXCEEDED	libstar/xicmp.h	48;"	d
ICMP_TIME_EXCEEDED	libstar/xping.h	53;"	d
IDEABLOCKSIZE	libstar/idea.c	19;"	d	file:
IDEAKEYSIZE	libstar/idea.c	18;"	d	file:
IDEA_ALIGN8	libstar/idea.h	28;"	d
IDEAkey	libstar/idea.c	/^typedef word16 IDEAkey[KEYLEN];$/;"	t	file:
IDX_AT	libstar/snmpdef.h	30;"	d
IDX_ICMP	libstar/snmpdef.h	33;"	d
IDX_IF	libstar/snmpdef.h	29;"	d
IDX_IP	libstar/snmpdef.h	31;"	d
IDX_MAXDATA	libstar/snmpdef.h	41;"	d
IDX_PORTCOUNT	libstar/snmpdef.h	39;"	d
IDX_ROUTE	libstar/snmpdef.h	32;"	d
IDX_SYS	libstar/snmpdef.h	28;"	d
IDX_TCP	libstar/snmpdef.h	34;"	d
IDX_TCPCONN	libstar/snmpdef.h	35;"	d
IDX_TCPSUM	libstar/snmpdef.h	38;"	d
IDX_UDP	libstar/snmpdef.h	36;"	d
IDX_UDPCONN	libstar/snmpdef.h	37;"	d
IFCH_ADMIN_STATUS	libstar/xnms.h	/^	IFCH_ADMIN_STATUS	= 0x00000001,$/;"	e	enum:__anon144
IFCH_DEL_IFINDEX	libstar/xnms.h	/^	IFCH_DEL_IFINDEX	= 0x00000008,$/;"	e	enum:__anon144
IFCH_IFALIAS	libstar/xnms.h	/^	IFCH_IFALIAS		= 0x00000040,$/;"	e	enum:__anon144
IFCH_IFDESCR	libstar/xnms.h	/^	IFCH_IFDESCR		= 0x00000020,$/;"	e	enum:__anon144
IFCH_IFMAC	libstar/xnms.h	/^	IFCH_IFMAC		= 0x00000400,$/;"	e	enum:__anon144
IFCH_IFMTU	libstar/xnms.h	/^	IFCH_IFMTU		= 0x00000100,$/;"	e	enum:__anon144
IFCH_IFSPEED	libstar/xnms.h	/^	IFCH_IFSPEED		= 0x00000200,$/;"	e	enum:__anon144
IFCH_IFTYPE	libstar/xnms.h	/^	IFCH_IFTYPE		= 0x00000080,$/;"	e	enum:__anon144
IFCH_NEW_IFINDEX	libstar/xnms.h	/^	IFCH_NEW_IFINDEX	= 0x00000004,$/;"	e	enum:__anon144
IFCH_NUMIF	libstar/xnms.h	/^	IFCH_NUMIF		= 0x00000010,$/;"	e	enum:__anon144
IFCH_OPER_STATUS	libstar/xnms.h	/^	IFCH_OPER_STATUS	= 0x00000002,$/;"	e	enum:__anon144
IF_HDR_FIXED	libstar/snoop.h	103;"	d
IF_HDR_VAR	libstar/snoop.h	104;"	d
INITIAL_TABLE_SIZE	libstar/hash.c	63;"	d	file:
INMCOUNTERSVERSION_ETHERNET	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_ETHERNET = 2,$/;"	e	enum:INMCounters_version
INMCOUNTERSVERSION_FDDI	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_FDDI = 4,$/;"	e	enum:INMCounters_version
INMCOUNTERSVERSION_GENERIC	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_GENERIC = 1,$/;"	e	enum:INMCounters_version
INMCOUNTERSVERSION_TOKENRING	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_TOKENRING = 3,$/;"	e	enum:INMCounters_version
INMCOUNTERSVERSION_VG	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_VG = 5,$/;"	e	enum:INMCounters_version
INMCOUNTERSVERSION_VLAN	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_VLAN = 7$/;"	e	enum:INMCounters_version
INMCOUNTERSVERSION_WAN	libstar/sflowlib.h	/^	INMCOUNTERSVERSION_WAN = 6,$/;"	e	enum:INMCounters_version
INMCounters_version	libstar/sflowlib.h	/^enum INMCounters_version$/;"	g
INMEXTENDED_GATEWAY	libstar/sflowlib.h	/^	INMEXTENDED_GATEWAY = 3,	\/* Extended gateway router information *\/$/;"	e	enum:INMExtended_information_type
INMEXTENDED_ROUTER	libstar/sflowlib.h	/^	INMEXTENDED_ROUTER = 2,	\/* Extended router information *\/$/;"	e	enum:INMExtended_information_type
INMEXTENDED_SWITCH	libstar/sflowlib.h	/^	INMEXTENDED_SWITCH = 1,	\/* Extended switch information *\/$/;"	e	enum:INMExtended_information_type
INMEXTENDED_URL	libstar/sflowlib.h	/^	INMEXTENDED_URL = 5	\/* Extended URL information *\/$/;"	e	enum:INMExtended_information_type
INMEXTENDED_USER	libstar/sflowlib.h	/^	INMEXTENDED_USER = 4,	\/* Extended TACAS\/RADIUS user information *\/$/;"	e	enum:INMExtended_information_type
INMExtended_information_type	libstar/sflowlib.h	/^enum INMExtended_information_type$/;"	g
INMPACKETTYPE_HEADER	libstar/sflowlib.h	/^	INMPACKETTYPE_HEADER = 1,	\/* Packet headers are sampled *\/$/;"	e	enum:INMPacket_information_type
INMPACKETTYPE_IPV4	libstar/sflowlib.h	/^	INMPACKETTYPE_IPV4 = 2,	\/* IP version 4 data *\/$/;"	e	enum:INMPacket_information_type
INMPACKETTYPE_IPV6	libstar/sflowlib.h	/^	INMPACKETTYPE_IPV6 = 3	\/* IP version 4 data *\/$/;"	e	enum:INMPacket_information_type
INMPacket_information_type	libstar/sflowlib.h	/^enum INMPacket_information_type$/;"	g
IP	libstar/xtn.c	193;"	d	file:
IP_HEADER_SIZE	libstar/netbios.c	69;"	d	file:
IcmpChecksum	libstar/xicmp.h	/^	ushort	IcmpChecksum;$/;"	m	struct:__anon132
IcmpCode	libstar/xicmp.h	/^	uchar	IcmpCode;			\/\/ Type sub code$/;"	m	struct:__anon132
IcmpGateway	libstar/xicmp.h	/^	uint	IcmpGateway;			\/\/ Gateway 주소 $/;"	m	struct:__anon132
IcmpHeader	libstar/xicmp.h	/^}	IcmpHeader;$/;"	t	typeref:struct:__anon132
IcmpId	libstar/xicmp.h	/^	ushort	IcmpId;$/;"	m	struct:__anon132
IcmpSeq	libstar/xicmp.h	/^	ushort	IcmpSeq;$/;"	m	struct:__anon132
IcmpTimestamp	libstar/xicmp.h	/^	uint	IcmpTimestamp;			\/\/ Not standard field in header, but reserved nonetheless$/;"	m	struct:__anon132
IcmpType	libstar/xicmp.h	/^	uchar	IcmpType;$/;"	m	struct:__anon132
Identification	libstar/xicmp.h	/^	ushort		Identification;		\/\/ unique identifier$/;"	m	struct:__anon131
Init	libstar/hash.h	/^	hash_t		*Init(uint (*hashf)(const void *, size_t), int (*cmpf)(const void *, const void *, size_t), int instsize)$/;"	f	class:CHash
Insert	libstar/hash.h	/^	hashent_t	*Insert(void *key, uint keylen)	{ return hash_insert(m_ht, key, keylen); }$/;"	f	class:CHash
InterSampleCleanup	libstar/sflowlib.c	/^static	void	InterSampleCleanup(SFSample * spp)$/;"	f	file:
IpHeader	libstar/xicmp.h	/^}	IpHeader;$/;"	t	typeref:struct:__anon131
JSON11_ENABLE_DR1467_CANARY	json11/test.cpp	26;"	d	file:
JSON11_TEST_ASSERT	json11/test.cpp	13;"	d	file:
JSON11_TEST_CASE	json11/test.cpp	/^JSON11_TEST_CASE(json11_test) {$/;"	f
JSON11_TEST_CASE	json11/test.cpp	12;"	d	file:
JSON11_TEST_CPP_PREFIX_CODE	json11/test.cpp	9;"	d	file:
JSON11_TEST_CPP_SUFFIX_CODE	json11/test.cpp	10;"	d	file:
JSON11_TEST_STANDALONE_MAIN	json11/test.cpp	11;"	d	file:
JSON_ARRAY	json2.h	/^	JSON_ARRAY,$/;"	e	enum:__anon12
JSON_ARRAY	myjson/json.h	/^	JSON_ARRAY,$/;"	e	enum:__anon185
JSON_ARRAY	myjson/json2.h	/^	JSON_ARRAY,$/;"	e	enum:__anon182
JSON_ARRAY_END	json2.h	/^	JSON_ARRAY_END,$/;"	e	enum:__anon12
JSON_ARRAY_END	myjson/json2.h	/^	JSON_ARRAY_END,$/;"	e	enum:__anon182
JSON_FALSE	json2.h	/^	JSON_FALSE,$/;"	e	enum:__anon12
JSON_FALSE	myjson/json.h	/^	JSON_FALSE,$/;"	e	enum:__anon185
JSON_FALSE	myjson/json2.h	/^	JSON_FALSE,$/;"	e	enum:__anon182
JSON_FIND_ALL	myjson/json.h	/^	JSON_FIND_ALL		= 0x00000002,		\/\/ Find all matchings$/;"	e	enum:__anon184
JSON_FIND_FIRST	myjson/json.h	/^	JSON_FIND_FIRST		= 0x00000000,		\/\/ Find first matching$/;"	e	enum:__anon184
JSON_FIND_LAST	myjson/json.h	/^	JSON_FIND_LAST		= 0x00000001,		\/\/ Find last matching$/;"	e	enum:__anon184
JSON_MAX_NEST	json2.h	28;"	d
JSON_MAX_NEST	myjson/json.h	29;"	d
JSON_MAX_NEST	myjson/json2.h	28;"	d
JSON_MAX_SIZE	myjson/json.h	28;"	d
JSON_NONE	json2.h	/^	JSON_NONE	= 0,$/;"	e	enum:__anon12
JSON_NONE	myjson/json2.h	/^	JSON_NONE	= 0,$/;"	e	enum:__anon182
JSON_NULL	json2.h	/^	JSON_NULL,$/;"	e	enum:__anon12
JSON_NULL	myjson/json.h	/^	JSON_NULL,$/;"	e	enum:__anon185
JSON_NULL	myjson/json2.h	/^	JSON_NULL,$/;"	e	enum:__anon182
JSON_NUMBER	json2.h	/^	JSON_NUMBER,$/;"	e	enum:__anon12
JSON_NUMBER	myjson/json.h	/^	JSON_NUMBER,$/;"	e	enum:__anon185
JSON_NUMBER	myjson/json2.h	/^	JSON_NUMBER,$/;"	e	enum:__anon182
JSON_OBJECT	json2.h	/^	JSON_OBJECT,$/;"	e	enum:__anon12
JSON_OBJECT	myjson/json.h	/^	JSON_OBJECT	= 1,$/;"	e	enum:__anon185
JSON_OBJECT	myjson/json2.h	/^	JSON_OBJECT,$/;"	e	enum:__anon182
JSON_OBJECT_END	json2.h	/^	JSON_OBJECT_END,$/;"	e	enum:__anon12
JSON_OBJECT_END	myjson/json2.h	/^	JSON_OBJECT_END,$/;"	e	enum:__anon182
JSON_PAIR	json2.h	/^	JSON_PAIR,$/;"	e	enum:__anon12
JSON_PAIR	myjson/json.h	/^	JSON_PAIR,$/;"	e	enum:__anon185
JSON_PAIR	myjson/json2.h	/^	JSON_PAIR,$/;"	e	enum:__anon182
JSON_RECUR_CALL	myjson/json.h	/^	JSON_RECUR_CALL		= 0x00000020,		\/\/ recursive call 중인지 구분 $/;"	e	enum:__anon184
JSON_SKIP_SPC_FIRST	myjson/json.h	/^	JSON_SKIP_SPC_FIRST	= 0x00000010,		\/\/ json_print에서 사용 $/;"	e	enum:__anon184
JSON_STRING	json2.h	/^	JSON_STRING,$/;"	e	enum:__anon12
JSON_STRING	myjson/json.h	/^	JSON_STRING,$/;"	e	enum:__anon185
JSON_STRING	myjson/json2.h	/^	JSON_STRING,$/;"	e	enum:__anon182
JSON_TRUE	json2.h	/^	JSON_TRUE,$/;"	e	enum:__anon12
JSON_TRUE	myjson/json.h	/^	JSON_TRUE,$/;"	e	enum:__anon185
JSON_TRUE	myjson/json2.h	/^	JSON_TRUE,$/;"	e	enum:__anon182
Json	json11/json11.cpp	/^Json::Json(Json::array &&values)       : m_ptr(make_shared<JsonArray>(move(values))) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(Json::object &&values)      : m_ptr(make_shared<JsonObject>(move(values))) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(bool value)                 : m_ptr(value ? statics().t : statics().f) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(const Json::array &values)  : m_ptr(make_shared<JsonArray>(values)) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(const Json::object &values) : m_ptr(make_shared<JsonObject>(values)) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(const char * value)         : m_ptr(make_shared<JsonString>(value)) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(const string &value)        : m_ptr(make_shared<JsonString>(value)) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(double value)               : m_ptr(make_shared<JsonDouble>(value)) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(int value)                  : m_ptr(make_shared<JsonInt>(value)) {}$/;"	f	class:json11::Json
Json	json11/json11.cpp	/^Json::Json(string &&value)             : m_ptr(make_shared<JsonString>(move(value))) {}$/;"	f	class:json11::Json
Json	json11/json11.hpp	/^    Json(const T & t) : Json(t.to_json()) {}$/;"	f	class:json11::final
JsonArray	json11/json11.cpp	/^    explicit JsonArray(Json::array &&value)      : Value(move(value)) {}$/;"	f	class:json11::final
JsonArray	json11/json11.cpp	/^    explicit JsonArray(const Json::array &value) : Value(value) {}$/;"	f	class:json11::final
JsonBoolean	json11/json11.cpp	/^    explicit JsonBoolean(bool value) : Value(value) {}$/;"	f	class:json11::final
JsonDouble	json11/json11.cpp	/^    explicit JsonDouble(double value) : Value(value) {}$/;"	f	class:json11::final
JsonInt	json11/json11.cpp	/^    explicit JsonInt(int value) : Value(value) {}$/;"	f	class:json11::final
JsonNull	json11/json11.cpp	/^    JsonNull() : Value({}) {}$/;"	f	class:json11::final
JsonObject	json11/json11.cpp	/^    explicit JsonObject(Json::object &&value)      : Value(move(value)) {}$/;"	f	class:json11::final
JsonObject	json11/json11.cpp	/^    explicit JsonObject(const Json::object &value) : Value(value) {}$/;"	f	class:json11::final
JsonParse	json11/json11.hpp	/^enum JsonParse {$/;"	g	namespace:json11
JsonString	json11/json11.cpp	/^    explicit JsonString(const string &value) : Value(value) {}$/;"	f	class:json11::final
JsonString	json11/json11.cpp	/^    explicit JsonString(string &&value)      : Value(move(value)) {}$/;"	f	class:json11::final
JsonValue	json11/json11.hpp	/^class JsonValue {$/;"	c	namespace:json11
K	lib/sha256.c	/^static const uint32_t K[64] = {$/;"	v	file:
K	lib/sha512.c	/^static const uint64_t K[80] = {$/;"	v	file:
KEYLEN	libstar/idea.c	22;"	d	file:
KRK	libstar/aria.c	/^const uint KRK[3][4] = {$/;"	v
KXL	libstar/aria.c	176;"	d	file:
L4_ALTEON	libstar/snmpdef.h	/^	L4_ALTEON	= 1,$/;"	e	enum:__anon94
L4_CISCO_ACE	libstar/snmpdef.h	/^	L4_CISCO_ACE,$/;"	e	enum:__anon94
L4_F5_BIGIP	libstar/snmpdef.h	/^	L4_F5_BIGIP,$/;"	e	enum:__anon94
L4_FOUNDRY	libstar/snmpdef.h	/^	L4_FOUNDRY,$/;"	e	enum:__anon94
L4_NETSCALER	libstar/snmpdef.h	/^	L4_NETSCALER,$/;"	e	enum:__anon94
L4_PIOLINK	libstar/snmpdef.h	/^	L4_PIOLINK,$/;"	e	enum:__anon94
LABEL_MASK	libstar/sflowlib.h	945;"	d
LABEL_SHIFT	libstar/sflowlib.h	946;"	d
LF	libstar/xtn.c	185;"	d	file:
LIBBASE58_H	lib/base58.h	2;"	d
LINUX	libstar/osconfig.h	8;"	d
LINUX_4_10	libstar/osconfig.h	15;"	d
LOAD32H	lib/sha256.c	24;"	d	file:
LOAD64H	lib/sha512.c	20;"	d	file:
LOG_ALERT	libstar/xnms.h	28;"	d
LOG_CRIT	libstar/xnms.h	29;"	d
LOG_DEBUG	libstar/xnms.h	34;"	d
LOG_EMERG	libstar/xnms.h	27;"	d
LOG_ERR	libstar/xnms.h	30;"	d
LOG_INFO	libstar/xnms.h	33;"	d
LOG_NOTICE	libstar/xnms.h	32;"	d
LOG_OPT_PRINT_DATE	libstar/xdebug.h	/^	LOG_OPT_PRINT_DATE	= 0x01,		\/\/ 로그 파일에 날짜 넣기 $/;"	e	enum:__anon125
LOG_OPT_PRINT_DATETIME	libstar/xdebug.h	/^	LOG_OPT_PRINT_DATETIME	= 0x03,		\/\/ 로그 파일에 날짜 넣기 $/;"	e	enum:__anon125
LOG_OPT_PRINT_FILE	libstar/xdebug.h	/^	LOG_OPT_PRINT_FILE	= 0x10,		\/\/ 로그 파일에 호출된 파일명 넣기 $/;"	e	enum:__anon125
LOG_OPT_PRINT_FUNC	libstar/xdebug.h	/^	LOG_OPT_PRINT_FUNC	= 0x20,		\/\/ 로그 파일에 호출된 함수명 넣기 $/;"	e	enum:__anon125
LOG_OPT_PRINT_LINE	libstar/xdebug.h	/^	LOG_OPT_PRINT_LINE	= 0x40,		\/\/ 로그 파일에 호출된 라인 번호 넣기 $/;"	e	enum:__anon125
LOG_OPT_PRINT_TIME	libstar/xdebug.h	/^	LOG_OPT_PRINT_TIME	= 0x02,		\/\/ 로그 파일에 시간 넣기 $/;"	e	enum:__anon125
LOG_TIMEOUT	libstar/loglib.h	22;"	d
LOG_WARNING	libstar/xnms.h	31;"	d
LPCODEPROC	libstar/xtn.c	/^typedef void (*LPCODEPROC)(char*);$/;"	t	file:
LPDATAPROC	libstar/xtn.c	/^typedef void(*LPDATAPROC)(SOCKET,unsigned char data);$/;"	t	file:
LPOPTIONPROC	libstar/xtn.c	/^typedef void(*LPOPTIONPROC)(SOCKET,_verb,_option);$/;"	t	file:
Last	libstar/xlist.h	/^	xlistnode_t	*Last()				{ return xlist_last(m_xl, &m_xloop); }$/;"	f	class:CXList
LastErr	libstar/dvdlib.c	/^	int		LastErr;$/;"	m	struct:__anon28	file:
LastErr	libstar/oddlibwin.c	/^	int             LastErr;$/;"	m	struct:__anon65	file:
LastResponse	libstar/ssmtp.h	/^	char            LastResponse[MAX_ARG_LEN];	\/\/ Last SMTP response string from server $/;"	m	struct:__anon101
LastResponseCode	libstar/ssmtp.h	/^	int             LastResponseCode;	\/\/ Last SMTP response code from server $/;"	m	struct:__anon101
LinkSize	libstar/dvdlib.c	/^	BYTE		LinkSize;$/;"	m	struct:__anon28	file:
LinkSize	libstar/oddlibwin.c	/^	BYTE            LinkSize;$/;"	m	struct:__anon65	file:
Lock	libstar/xlist.h	/^	void	Lock()					{ xlist_lock(m_xl); }$/;"	f	class:CXList
Lun	libstar/dvdlib.c	/^	char		Lun;$/;"	m	struct:__anon28	file:
Lun	libstar/oddlibwin.c	/^	char            Lun;$/;"	m	struct:__anon65	file:
MAX	libstar/snoop.h	54;"	d
MAX	libstar/xutil.h	35;"	d
MAXLEN	libstar/xhash.c	931;"	d	file:
MAXPAIR	libstar/xhash.c	930;"	d	file:
MAX_ARG_LEN	libstar/ssmtp.h	35;"	d
MAX_ASPI_TIMEOUT	libstar/dvdlib.c	463;"	d	file:
MAX_ASPI_TIMEOUT	libstar/oddlibwin.c	303;"	d	file:
MAX_AT	libstar/snmpdef.h	22;"	d
MAX_AUTH_DATA	hdaclib.h	60;"	d
MAX_BUFLEN	libstar/xtn.c	36;"	d	file:
MAX_BUFSIZE	libstar/xstr.h	27;"	d
MAX_BUF_LEN	libstar/ssmtp.h	36;"	d
MAX_DB	libstar/xdb.h	/^	MAX_DB,$/;"	e	enum:__anon114
MAX_DB_COL	libstar/xdb.h	32;"	d
MAX_DOMAIN_LEN	libstar/ssmtp.h	34;"	d
MAX_DVD_DRIVE	libstar/dvdlib.h	42;"	d
MAX_ERR_MSG_LEN	libstar/ssmtp.h	33;"	d
MAX_EVLOG	libstar/loglib.h	19;"	d
MAX_EVLOG_AGENT	libstar/loglib.h	18;"	d
MAX_FLD	libstar/xstr.h	28;"	d
MAX_FLOWS_PER_ANY_PACKET	libstar/nflowlib.h	279;"	d
MAX_FLOWS_PER_V1PACKET	libstar/nflowlib.h	35;"	d
MAX_FLOWS_PER_V5PACKET	libstar/nflowlib.h	80;"	d
MAX_FLOWS_PER_V6PACKET	libstar/nflowlib.h	126;"	d
MAX_FLOWS_PER_V7PACKET	libstar/nflowlib.h	159;"	d
MAX_FLOWS_PER_V8AS_PACKET	libstar/nflowlib.h	255;"	d
MAX_FLOWS_PER_V8DSTNET_PACKET	libstar/nflowlib.h	258;"	d
MAX_FLOWS_PER_V8NETMATRIX_PACKET	libstar/nflowlib.h	259;"	d
MAX_FLOWS_PER_V8PROTO_PORT_PACKET	libstar/nflowlib.h	256;"	d
MAX_FLOWS_PER_V8SRCNET_PACKET	libstar/nflowlib.h	257;"	d
MAX_FLOW_PACKET_SIZE	libstar/nflowlib.h	20;"	d
MAX_GATEWAY	libstar/gw.h	44;"	d
MAX_HOPS	libstar/xicmp.h	37;"	d
MAX_IFVAL	libstar/snmpsub.c	1053;"	d	file:
MAX_LINE	libstar/snoop.h	69;"	d
MAX_LINES_PER_SEND	libstar/loglib.h	20;"	d
MAX_LINE_LEN	libstar/loglib.h	23;"	d
MAX_LOCK_CHECK	libstar/xlock.c	26;"	d	file:
MAX_NODE_IF	libstar/snmpdef.h	21;"	d
MAX_PINGIP	libstar/xping.h	64;"	d
MAX_PING_THREADS	libstar/xping.h	65;"	d
MAX_PLAINTEXT_SIZE	lib/test_hashlib.c	26;"	d	file:
MAX_PORT	libstar/snmpdef.h	26;"	d
MAX_PORTS	libstar/gw.h	45;"	d
MAX_PROTOCOL_LEN	libstar/sflowlib.h	753;"	d
MAX_RECEIVER	libstar/ssmtp.h	32;"	d
MAX_ROUTE	libstar/snmpdef.h	23;"	d
MAX_ROW_SIZE	libstar/xdb.h	33;"	d
MAX_SCAN_DRIVE	libstar/oddlibwin.c	302;"	d	file:
MAX_SNMP_SLOW_THREAD	libstar/xnms.h	39;"	d
MAX_SNMP_THREAD	libstar/xnms.h	38;"	d
MAX_SYSLOG_FILTER	libstar/xnms.h	42;"	d
MAX_TCPCONN	libstar/snmpdef.h	24;"	d
MAX_TRAP_FILTER	libstar/xnms.h	43;"	d
MAX_UDPCONN	libstar/snmpdef.h	25;"	d
MAX_VHASH_TABLE	libstar/vhash.h	28;"	d
MAX_XFLOW_QUEUE_SIZE	libstar/xflowlib.h	26;"	d
MAX_XIFINFO	libstar/xsock.h	67;"	d
MAX_XPROF	libstar/xtime.h	35;"	d
MD5	libstar/md5.h	92;"	d
MD5_CTX	libstar/md5.h	88;"	d
MD5_Final	libstar/md5.h	91;"	d
MD5_H	lib/md5.h	11;"	d
MD5_HASH	lib/md5.h	/^} MD5_HASH;$/;"	t	typeref:struct:__anon17
MD5_HASH_SIZE	lib/md5.h	32;"	d
MD5_Init	libstar/md5.h	89;"	d
MD5_Update	libstar/md5.h	90;"	d
MICROSEC	libstar/xtime.h	26;"	d
MIN	lib/sha256.c	18;"	d	file:
MIN	lib/sha512.c	18;"	d	file:
MIN	libstar/snoop.h	58;"	d
MIN	libstar/xutil.h	38;"	d
MIN_IFVAL	libstar/snmpsub.c	1001;"	d	file:
MM	libstar/aria.c	193;"	d	file:
MPLS_EXP	libstar/sflowlib.h	955;"	d
MPLS_LABEL	libstar/sflowlib.h	954;"	d
MPLS_STACK	libstar/sflowlib.h	956;"	d
MPLS_TTL	libstar/sflowlib.h	957;"	d
MSSQL_DB	libstar/xdb.h	/^	MSSQL_DB,			\/\/ MS-SQL DB - Commercial$/;"	e	enum:__anon114
MUL	libstar/idea.c	134;"	d	file:
MYSQL_DB	libstar/xdb.h	/^	MYSQL_DB,			\/\/ MySQL DB - Commercial$/;"	e	enum:__anon114
Maj	lib/sha256.c	59;"	d	file:
Maj	lib/sha512.c	66;"	d	file:
MaxFoundDrive	libstar/oddlibwin.c	/^static int      MaxFoundDrive;$/;"	v	file:
Md5Context	lib/md5.h	/^} Md5Context;$/;"	t	typeref:struct:__anon16
Md5Finalise	lib/md5.c	/^void	Md5Finalise(Md5Context *Context, MD5_HASH *Digest)$/;"	f
Md5Hash	lib/test_hashlib.c	/^    MD5_HASH        Md5Hash;$/;"	m	struct:__anon181	file:
Md5Initialise	lib/md5.c	/^void	Md5Initialise(Md5Context *Context)$/;"	f
Md5Update	lib/md5.c	/^void	Md5Update(Md5Context *Context, const void *Buffer, uint32_t BufferSize)$/;"	f
Modify	libstar/xnms.h	/^	int		Modify(xnmsnode_t *xn)		{ xnms_modify(m_xnms, xn); }$/;"	f	class:CXNms
MultiPing	libstar/xping.c	/^int	CXPing::MultiPing(CStringArray& arHostList, CUIntArray& arRetAddr, CUIntArray& arDelayUS)$/;"	f	class:CXPing
MultiPing	libstar/xping.c	/^int	CXPing::MultiPing(CUIntArray& arHostList, CUIntArray& arRetAddr, CUIntArray& arDelayUS)$/;"	f	class:CXPing
NANOSEC	libstar/xtime.h	30;"	d
NBNAME_REQUEST_SIZE	libstar/netbios.c	67;"	d	file:
NBNAME_RESPONSE_FOOTER_SIZE	libstar/netbios.c	117;"	d	file:
NBNAME_RESPONSE_HEADER_SIZE	libstar/netbios.c	90;"	d	file:
NB_DGRAM	libstar/netbios.h	17;"	d
NDEBUG	json11/test.cpp	15;"	d	file:
NETFLOW_MSG_SIZE	libstar/nflowlib.h	549;"	d
NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE	libstar/xsnmptrap.c	45;"	d	file:
NETSNMP_CALLBACK_OP_TIMED_OUT	libstar/xsnmptrap.c	46;"	d	file:
NETSNMP_DS_LIBRARY_ID	libstar/xsnmp.h	61;"	d
NETSNMP_DS_LIB_SNMPVERSION	libstar/xsnmp.h	62;"	d
NF9_BGP_IPV4_NEXT_HOP	libstar/nflowlib.h	600;"	d
NF9_BGP_IPV6_NEXT_HOP	libstar/nflowlib.h	623;"	d
NF9_CUST_CLASS	libstar/nflowlib.h	636;"	d
NF9_DIRECTION	libstar/nflowlib.h	621;"	d
NF9_DST_AS	libstar/nflowlib.h	599;"	d
NF9_DST_MAC	libstar/nflowlib.h	617;"	d
NF9_DST_MASK	libstar/nflowlib.h	595;"	d
NF9_DST_VLAN	libstar/nflowlib.h	619;"	d
NF9_ENGINE_ID	libstar/nflowlib.h	614;"	d
NF9_ENGINE_TYPE	libstar/nflowlib.h	613;"	d
NF9_FIRST_SWITCHED	libstar/nflowlib.h	605;"	d
NF9_FLOWS	libstar/nflowlib.h	585;"	d
NF9_FTYPE_IPV4	libstar/nflowlib.h	638;"	d
NF9_FTYPE_IPV4	libstar/sflowlib.h	740;"	d
NF9_FTYPE_IPV6	libstar/nflowlib.h	639;"	d
NF9_FTYPE_IPV6	libstar/sflowlib.h	741;"	d
NF9_FTYPE_MPLS	libstar/nflowlib.h	643;"	d
NF9_FTYPE_MPLS	libstar/sflowlib.h	745;"	d
NF9_FTYPE_MPLS_IPV4	libstar/nflowlib.h	644;"	d
NF9_FTYPE_MPLS_IPV4	libstar/sflowlib.h	746;"	d
NF9_FTYPE_MPLS_IPV6	libstar/nflowlib.h	645;"	d
NF9_FTYPE_MPLS_IPV6	libstar/sflowlib.h	747;"	d
NF9_FTYPE_VLAN	libstar/nflowlib.h	640;"	d
NF9_FTYPE_VLAN	libstar/sflowlib.h	742;"	d
NF9_FTYPE_VLAN_IPV4	libstar/nflowlib.h	641;"	d
NF9_FTYPE_VLAN_IPV4	libstar/sflowlib.h	743;"	d
NF9_FTYPE_VLAN_IPV6	libstar/nflowlib.h	642;"	d
NF9_FTYPE_VLAN_IPV6	libstar/sflowlib.h	744;"	d
NF9_FTYPE_VLAN_MPLS	libstar/nflowlib.h	646;"	d
NF9_FTYPE_VLAN_MPLS	libstar/sflowlib.h	748;"	d
NF9_FTYPE_VLAN_MPLS_IPV4	libstar/nflowlib.h	647;"	d
NF9_FTYPE_VLAN_MPLS_IPV4	libstar/sflowlib.h	749;"	d
NF9_FTYPE_VLAN_MPLS_IPV6	libstar/nflowlib.h	648;"	d
NF9_FTYPE_VLAN_MPLS_IPV6	libstar/sflowlib.h	750;"	d
NF9_ICMP_TYPE	libstar/nflowlib.h	611;"	d
NF9_INPUT_SNMP	libstar/nflowlib.h	592;"	d
NF9_IN_BYTES	libstar/nflowlib.h	583;"	d
NF9_IN_PACKETS	libstar/nflowlib.h	584;"	d
NF9_IPV4_DST_ADDR	libstar/nflowlib.h	594;"	d
NF9_IPV4_NEXT_HOP	libstar/nflowlib.h	597;"	d
NF9_IPV4_SRC_ADDR	libstar/nflowlib.h	590;"	d
NF9_IPV6_DST_ADDR	libstar/nflowlib.h	608;"	d
NF9_IPV6_DST_MASK	libstar/nflowlib.h	610;"	d
NF9_IPV6_NEXT_HOP	libstar/nflowlib.h	622;"	d
NF9_IPV6_SRC_ADDR	libstar/nflowlib.h	607;"	d
NF9_IPV6_SRC_MASK	libstar/nflowlib.h	609;"	d
NF9_IP_PROTOCOL_VERSION	libstar/nflowlib.h	620;"	d
NF9_L4_DST_PORT	libstar/nflowlib.h	593;"	d
NF9_L4_PROTOCOL	libstar/nflowlib.h	586;"	d
NF9_L4_SRC_PORT	libstar/nflowlib.h	589;"	d
NF9_LAST_SWITCHED	libstar/nflowlib.h	604;"	d
NF9_MAX_DEFINED_FIELD	libstar/nflowlib.h	580;"	d
NF9_MIN_RECORD_FLOWSET_ID	libstar/nflowlib.h	579;"	d
NF9_MPLS_LABEL_1	libstar/nflowlib.h	625;"	d
NF9_MPLS_LABEL_10	libstar/nflowlib.h	634;"	d
NF9_MPLS_LABEL_2	libstar/nflowlib.h	626;"	d
NF9_MPLS_LABEL_3	libstar/nflowlib.h	627;"	d
NF9_MPLS_LABEL_4	libstar/nflowlib.h	628;"	d
NF9_MPLS_LABEL_5	libstar/nflowlib.h	629;"	d
NF9_MPLS_LABEL_6	libstar/nflowlib.h	630;"	d
NF9_MPLS_LABEL_7	libstar/nflowlib.h	631;"	d
NF9_MPLS_LABEL_8	libstar/nflowlib.h	632;"	d
NF9_MPLS_LABEL_9	libstar/nflowlib.h	633;"	d
NF9_MUL_DST_BYTES	libstar/nflowlib.h	602;"	d
NF9_MUL_DST_PKTS	libstar/nflowlib.h	601;"	d
NF9_OPTIONS_FLOWSET_ID	libstar/nflowlib.h	578;"	d
NF9_OUTPUT_SNMP	libstar/nflowlib.h	596;"	d
NF9_SRC_AS	libstar/nflowlib.h	598;"	d
NF9_SRC_MAC	libstar/nflowlib.h	616;"	d
NF9_SRC_MASK	libstar/nflowlib.h	591;"	d
NF9_SRC_TOS	libstar/nflowlib.h	587;"	d
NF9_SRC_VLAN	libstar/nflowlib.h	618;"	d
NF9_TCP_FLAGS	libstar/nflowlib.h	588;"	d
NF9_TEMPLATE_FLOWSET_ID	libstar/nflowlib.h	577;"	d
NFT_8022_SIZ	libstar/sflowlib.c	866;"	d	file:
NFT_ETHHDR_SIZ	libstar/sflowlib.c	865;"	d	file:
NFT_MAX_8023_LEN	libstar/sflowlib.c	867;"	d	file:
NF_AS_KEEP	libstar/nflowlib.h	573;"	d
NF_AS_KEEP	libstar/sflowlib.h	733;"	d
NF_AS_NEW	libstar/nflowlib.h	574;"	d
NF_AS_NEW	libstar/sflowlib.h	736;"	d
NF_TIME_MSECS	libstar/nflowlib.h	569;"	d
NF_TIME_NEW	libstar/nflowlib.h	571;"	d
NF_TIME_SECS	libstar/nflowlib.h	570;"	d
NMS_MODE_AV	libstar/xnms.h	/^	NMS_MODE_AV	= 0x0004,$/;"	e	enum:__anon142
NMS_MODE_LG	libstar/xnms.h	/^	NMS_MODE_LG	= 0x0002,	\/\/ Ping 사용 안함. 고속 포트 스캐닝 모드 enabled. CPU OID만 비교.$/;"	e	enum:__anon142
NMS_MODE_NORMAL	libstar/xnms.h	/^	NMS_MODE_NORMAL	= 0x0001,$/;"	e	enum:__anon142
NOP	libstar/xtn.c	190;"	d	file:
NR_ICMP_TYPES	libstar/xicmp.h	56;"	d
NR_ICMP_UNREACH	libstar/xicmp.h	76;"	d
NR_SEND_BLOCK	libstar/dvdlib.h	36;"	d
NR_SEND_BLOCK	libstar/oddlibwin.c	1218;"	d	file:
NUL	json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::final::Type
NUL	libstar/xtn.c	181;"	d	file:
NUMBER	json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::final::Type
NUM_CODEC	libstar/xtn.c	151;"	d	file:
NUM_TERMINALS	libstar/xtn.c	1568;"	d	file:
NUM_TEST_VECTORS	lib/test_hashlib.c	167;"	d	file:
Next	libstar/hash.h	/^	hashent_t	*Next(hashloop_t *lp)				{ return hash_next(m_ht, lp); }$/;"	f	class:CHash
Next	libstar/xlist.h	/^	xlistnode_t	*Next()				{ return xlist_next(m_xl, &m_xloop); }$/;"	f	class:CXList
Now	libstar/xsnmptrap.c	/^struct timeval  Now;$/;"	v	typeref:struct:timeval
NullStruct	json11/json11.cpp	/^struct NullStruct {$/;"	s	namespace:json11	file:
NumFailedBCC	libstar/ssmtp.h	/^	int             NumFailedBCC;		\/\/ number of rejected BCC recipients $/;"	m	struct:__anon101
NumFailedCC	libstar/ssmtp.h	/^	int             NumFailedCC;		\/\/ number of rejected CC recipients $/;"	m	struct:__anon101
NumFailedTo	libstar/ssmtp.h	/^	int             NumFailedTo;		\/\/ number of rejected recipients $/;"	m	struct:__anon101
NumParts	libstar/ssmtp.h	/^	int             NumParts;		\/\/ Number of body parts $/;"	m	struct:__anon101
OBJECT	json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::final::Type
OCI_PIECE_SIZE	libstar/ocilib.c	795;"	d	file:
OCI_PIECE_SIZE	libstar/ocilib.h	21;"	d
ODDLIB_API	libstar/oddlib.h	25;"	d
ODDLIB_API	libstar/oddlib.h	26;"	d
ODDLIB_API	libstar/oddlib.h	7;"	d
ODDLIB_API	libstar/oddlib.h	9;"	d
ODDLIB_EXPORTS	libstar/oddlibwin.c	6;"	d	file:
ODD_MARK	libstar/oddlib.h	36;"	d
ODD_REC_ERROR_CODE	libstar/oddlib.h	/^}	ODD_REC_ERROR_CODE;$/;"	v	typeref:enum:__anon63
ORACLE_DB	libstar/xdb.h	/^	ORACLE_DB,			\/\/ Oracle DB - Commercial$/;"	e	enum:__anon114
OS_64BIT	libstar/osconfig.h	9;"	d
OS_BITS	libstar/osconfig.h	10;"	d
OS_DIR	libstar/osconfig.h	6;"	d
OS_MAJOR_VER	libstar/osconfig.h	12;"	d
OS_MINOR_VER	libstar/osconfig.h	13;"	d
OS_TYPE	libstar/osconfig.h	7;"	d
OS_VERSION	libstar/osconfig.h	14;"	d
O_BINARY	libstar/libstar.h	24;"	d
O_BINARY	libstar/xdebug.c	30;"	d	file:
Oid2Str	libstar/xsnmp.h	/^	CString		Oid2Str(oid *ids, uint idlen)	{ CString str = xsnmp_oid2str(m_buf1, sizeof(m_buf1), ids, idlen); return str; }$/;"	f	class:CXSnmp
OnDeviceChangeForASPI	libstar/dvdlib.c	/^DVDLIB_API void OnDeviceChangeForASPI(WPARAM wParam, LPARAM lParam)$/;"	f
OnDeviceChangeForASPI	libstar/oddlibwin.c	/^ODDLIB_API void OnDeviceChangeForASPI(WPARAM wParam, LPARAM lParam)$/;"	f
Open	libstar/xsnmp.h	/^	BOOL		Open(CString hn, CString cm)	{ return xsnmp_open(m_xs, (char *)(LPCSTR)hn, (char *)(LPCSTR)cm); }$/;"	f	class:CXSnmp
OptionProc	libstar/xtn.c	/^	LPOPTIONPROC OptionProc;$/;"	m	struct:ol_st	file:
P	libstar/aria.c	200;"	d	file:
P	libstar/aria.c	206;"	d	file:
PACKET_SIZE	libstar/xicmp.h	36;"	d
PGSQL_DB	libstar/xdb.h	/^	PGSQL_DB,			\/\/ Postgres SQL - Free DB$/;"	e	enum:__anon114
PKT_MARK	libstar/xpcap.h	62;"	d
PM_BRIDGEPORT	libstar/xsnmp.h	/^	PM_BRIDGEPORT,		\/\/ xsnmp_portmaphash: 장비명 + Logical port #$/;"	e	enum:__anon162
PM_MAC	libstar/xsnmp.h	/^	PM_MAC,			\/\/ xsnmp_portmaphash: 장비명 + MAC 주소$/;"	e	enum:__anon162
PPPOE_HDRLEN	libstar/sflowlib.h	933;"	d
PPP_ADDRESS	libstar/sflowlib.h	938;"	d
PPP_CONTROL	libstar/sflowlib.h	939;"	d
PPP_HDRLEN	libstar/sflowlib.h	932;"	d
PPP_IP	libstar/sflowlib.h	934;"	d
PPP_IPV6	libstar/sflowlib.h	935;"	d
PPP_MPLS_MCAST	libstar/sflowlib.h	937;"	d
PPP_MPLS_UCAST	libstar/sflowlib.h	936;"	d
PRINTNS	libstar/xtime.h	40;"	d
PRINTUS	libstar/xtime.h	41;"	d
Parts	libstar/ssmtp.h	/^	SSMTP_MIME_PART *Parts[MAX_RECEIVER];	\/\/ Parts we will send $/;"	m	struct:__anon101
Pass	libstar/ssmtp.h	/^	char            Pass[MAX_ARG_LEN];	\/\/ Auth password $/;"	m	struct:__anon101
PathId	libstar/dvdlib.c	/^	char		PathId;$/;"	m	struct:__anon28	file:
PathId	libstar/oddlibwin.c	/^	char            PathId;$/;"	m	struct:__anon65	file:
Ping	libstar/xping.h	/^	uint	Ping(char *szHostName, int timeoutMS = 5000, int retry = 3)		{ return xpingip(szHostName, timeoutMS, retry); }$/;"	f	class:CXPing
Ping	libstar/xping.h	/^	uint	Ping(uint nAddress, int timeoutMS = 5000, int retry = 3)		{ return xping(nAddress, timeoutMS, retry); }$/;"	f	class:CXPing
PlainText	lib/test_hashlib.c	/^    char            PlainText [MAX_PLAINTEXT_SIZE];$/;"	m	struct:__anon181	file:
PlainTextSize	lib/test_hashlib.c	/^    int             PlainTextSize;                      \/\/ 0 to use (int)strlen$/;"	m	struct:__anon181	file:
Prev	libstar/xlist.h	/^	xlistnode_t	*Prev()				{ return xlist_prev(m_xl, &m_xloop); }$/;"	f	class:CXList
Protocol	libstar/xicmp.h	/^	uchar		Protocol;          	\/\/ protocol (TCP, UDP etc)$/;"	m	struct:__anon131
QC_INTERNET	libstar/netbios.c	47;"	d	file:
QT_NODE_STATUS_REQUEST	libstar/netbios.c	46;"	d	file:
R	lib/sha256.c	61;"	d	file:
R	lib/sha512.c	68;"	d	file:
R0	lib/sha1.c	37;"	d	file:
R1	lib/sha1.c	38;"	d	file:
R2	lib/sha1.c	39;"	d	file:
R3	lib/sha1.c	40;"	d	file:
R4	lib/sha1.c	41;"	d	file:
RC4_H	lib/rc4.h	10;"	d
REC_LAST_LBA	libstar/dvdlib.h	35;"	d
REC_START_LBA	libstar/dvdlib.h	34;"	d
REC_START_LBA	libstar/oddlib.h	34;"	d
REC_UNIT_BUF_SIZE	libstar/dvdlib.h	40;"	d
RESIZE_AT	libstar/hash.c	65;"	d	file:
RESIZE_SHIFT	libstar/hash.c	64;"	d	file:
ROR64	lib/sha512.c	16;"	d	file:
ROTATE_LEFT	libstar/md5.c	199;"	d	file:
ROUNDS	libstar/idea.c	21;"	d	file:
RPC_SECURE	rpc.h	15;"	d
Rc4Context	lib/rc4.h	/^} Rc4Context;$/;"	t	typeref:struct:__anon18
Rc4Initialise	lib/rc4.c	/^void	Rc4Initialise(Rc4Context *Context, void *Key, uint32_t KeySize, uint32_t DropN)$/;"	f
Rc4Output	lib/rc4.c	/^void	Rc4Output(Rc4Context *Context, void *Buffer, uint32_t Size)$/;"	f
Rc4Xor	lib/rc4.c	/^void	Rc4Xor(Rc4Context *Context, void *InBuffer, void *OutBuffer, uint32_t Size)$/;"	f
RecRequstBuf	libstar/dvdlib.c	/^	BYTE		*RecRequstBuf;$/;"	m	struct:__anon28	file:
RecRequstBuf	libstar/oddlibwin.c	/^	BYTE           *RecRequstBuf;$/;"	m	struct:__anon65	file:
RecRequstBufLen	libstar/dvdlib.c	/^	DWORD		RecRequstBufLen;$/;"	m	struct:__anon28	file:
RecRequstBufLen	libstar/oddlibwin.c	/^	DWORD           RecRequstBufLen;$/;"	m	struct:__anon65	file:
ReverseWord	libstar/aria.c	151;"	d	file:
ReverseWord	libstar/aria.c	153;"	d	file:
S	lib/rc4.h	/^    uint8_t      S[256];$/;"	m	struct:__anon18
S	lib/sha256.c	60;"	d	file:
S	lib/sha512.c	67;"	d	file:
S1	libstar/aria.c	/^const uint S1[256] = {$/;"	v
S2	libstar/aria.c	/^const uint S2[256] = {$/;"	v
SASAMPLE_EXTENDED_DATA_GATEWAY	libstar/sflowlib.h	860;"	d
SASAMPLE_EXTENDED_DATA_MPLS	libstar/sflowlib.h	863;"	d
SASAMPLE_EXTENDED_DATA_MPLS_FTN	libstar/sflowlib.h	867;"	d
SASAMPLE_EXTENDED_DATA_MPLS_LDP_FEC	libstar/sflowlib.h	868;"	d
SASAMPLE_EXTENDED_DATA_MPLS_TUNNEL	libstar/sflowlib.h	865;"	d
SASAMPLE_EXTENDED_DATA_MPLS_VC	libstar/sflowlib.h	866;"	d
SASAMPLE_EXTENDED_DATA_NAT	libstar/sflowlib.h	864;"	d
SASAMPLE_EXTENDED_DATA_ROUTER	libstar/sflowlib.h	859;"	d
SASAMPLE_EXTENDED_DATA_SWITCH	libstar/sflowlib.h	858;"	d
SASAMPLE_EXTENDED_DATA_URL	libstar/sflowlib.h	862;"	d
SASAMPLE_EXTENDED_DATA_USER	libstar/sflowlib.h	861;"	d
SASAMPLE_EXTENDED_DATA_VLAN_TUNNEL	libstar/sflowlib.h	869;"	d
SA_MAX_EXTENDED_HOST_LEN	libstar/sflowlib.h	904;"	d
SA_MAX_EXTENDED_URL_LEN	libstar/sflowlib.h	903;"	d
SA_MAX_EXTENDED_USER_LEN	libstar/sflowlib.h	894;"	d
SA_MAX_FTN_LEN	libstar/sflowlib.c	744;"	d	file:
SA_MAX_TUNNELNAME_LEN	libstar/sflowlib.c	716;"	d	file:
SA_MAX_VCNAME_LEN	libstar/sflowlib.c	730;"	d	file:
SB	libstar/xtn.c	199;"	d	file:
SBL1_M	libstar/aria.c	179;"	d	file:
SBL2_M	libstar/aria.c	186;"	d	file:
SB_TERM_IS	libstar/xtn.c	/^	SB_TERM_IS = 0,$/;"	e	enum:__anon178	file:
SB_TERM_SEND	libstar/xtn.c	/^	SB_TERM_SEND = 1$/;"	e	enum:__anon178	file:
SCALABLE_WALLET	rpc.h	16;"	d
SCAN_BY_CLASSGUID	libstar/dvdlib.h	30;"	d
SCAN_BY_CLASSGUID	libstar/oddlib.h	30;"	d
SCAN_BY_INQUIRY	libstar/dvdlib.h	31;"	d
SCAN_BY_INQUIRY	libstar/oddlib.h	31;"	d
SCAN_BY_IOCTL	libstar/dvdlib.h	29;"	d
SCAN_BY_IOCTL	libstar/oddlib.h	29;"	d
SE	libstar/xtn.c	189;"	d	file:
SENDASPI32COMMAND	libstar/dvdlib.c	/^typedef DWORD(*SENDASPI32COMMAND) (LPSRB);$/;"	t	file:
SENDASPI32COMMAND	libstar/oddlibwin.c	/^typedef         DWORD(*SENDASPI32COMMAND) (LPSRB);$/;"	t	file:
SESS_APPENABLE	libstar/oddlibwin.c	1270;"	d	file:
SESS_FINAL	libstar/oddlibwin.c	1271;"	d	file:
SET	lib/md5.c	39;"	d	file:
SET	libstar/md5.c	205;"	d	file:
SET	libstar/md5.c	225;"	d	file:
SET	libstar/md5.c	231;"	d	file:
SET	libstar/md5.c	251;"	d	file:
SET	libstar/md5.c	257;"	d	file:
SET	libstar/md5.c	277;"	d	file:
SET	libstar/md5.c	283;"	d	file:
SET	libstar/md5.c	303;"	d	file:
SETJMP	libstar/xdebug.h	83;"	d
SFLADDRESSTYPE_IP_V4	libstar/sflowlib.h	/^	SFLADDRESSTYPE_IP_V4 = 1,$/;"	e	enum:SFLAddress_type
SFLADDRESSTYPE_IP_V6	libstar/sflowlib.h	/^	SFLADDRESSTYPE_IP_V6 = 2$/;"	e	enum:SFLAddress_type
SFLADD_ELEMENT	libstar/sflowlib.h	691;"	d
SFLAddress	libstar/sflowlib.h	/^SFLAddress;$/;"	t	typeref:struct:_SFLAddress
SFLAddress_type	libstar/sflowlib.h	/^enum SFLAddress_type$/;"	g
SFLAddress_value	libstar/sflowlib.h	/^SFLAddress_value;$/;"	t	typeref:union:_SFLAddress_value
SFLCOUNTERS_ETHERNET	libstar/sflowlib.h	/^	SFLCOUNTERS_ETHERNET = 2,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_GENERIC	libstar/sflowlib.h	/^	SFLCOUNTERS_GENERIC = 1,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_PROCESSOR	libstar/sflowlib.h	/^	SFLCOUNTERS_PROCESSOR = 1001$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_SAMPLE	libstar/sflowlib.h	/^	SFLCOUNTERS_SAMPLE = 2,	\/* enterprise = 0 : format = 2 *\/$/;"	e	enum:SFL_sample_tag
SFLCOUNTERS_SAMPLE_EXPANDED	libstar/sflowlib.h	/^	SFLCOUNTERS_SAMPLE_EXPANDED = 4	\/* enterprise = 0 : format = 4 *\/$/;"	e	enum:SFL_sample_tag
SFLCOUNTERS_TOKENRING	libstar/sflowlib.h	/^	SFLCOUNTERS_TOKENRING = 3,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_VG	libstar/sflowlib.h	/^	SFLCOUNTERS_VG = 4,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_VLAN	libstar/sflowlib.h	/^	SFLCOUNTERS_VLAN = 5,$/;"	e	enum:SFLCounters_type_tag
SFLCounters_sample	libstar/sflowlib.h	/^SFLCounters_sample;$/;"	t	typeref:struct:_SFLCounters_sample
SFLCounters_sample_element	libstar/sflowlib.h	/^SFLCounters_sample_element;$/;"	t	typeref:struct:_SFLCounters_sample_element
SFLCounters_sample_expanded	libstar/sflowlib.h	/^SFLCounters_sample_expanded;$/;"	t	typeref:struct:_SFLCounters_sample_expanded
SFLCounters_type	libstar/sflowlib.h	/^SFLCounters_type;$/;"	t	typeref:union:_SFLCounters_type
SFLCounters_type_tag	libstar/sflowlib.h	/^enum SFLCounters_type_tag$/;"	g
SFLDATAGRAM_VERSION2	libstar/sflowlib.h	/^	SFLDATAGRAM_VERSION2 = 2,$/;"	e	enum:SFLDatagram_version
SFLDATAGRAM_VERSION4	libstar/sflowlib.h	/^	SFLDATAGRAM_VERSION4 = 4,$/;"	e	enum:SFLDatagram_version
SFLDATAGRAM_VERSION5	libstar/sflowlib.h	/^	SFLDATAGRAM_VERSION5 = 5$/;"	e	enum:SFLDatagram_version
SFLDatagram_version	libstar/sflowlib.h	/^enum SFLDatagram_version$/;"	g
SFLEXTENDED_AS_SEQUENCE	libstar/sflowlib.h	/^	SFLEXTENDED_AS_SEQUENCE = 2	\/* Ordered sequence of ASs *\/$/;"	e	enum:SFLExtended_as_path_segment_type
SFLEXTENDED_AS_SET	libstar/sflowlib.h	/^	SFLEXTENDED_AS_SET = 1,	\/* Unordered set of ASs *\/$/;"	e	enum:SFLExtended_as_path_segment_type
SFLEXTENDED_URL_DST	libstar/sflowlib.h	/^	SFLEXTENDED_URL_DST = 2	\/* URL is associated with destination address *\/$/;"	e	enum:SFLExtended_url_direction
SFLEXTENDED_URL_SRC	libstar/sflowlib.h	/^	SFLEXTENDED_URL_SRC = 1,	\/* URL is associated with source address *\/$/;"	e	enum:SFLExtended_url_direction
SFLEthernet_counters	libstar/sflowlib.h	/^SFLEthernet_counters;$/;"	t	typeref:struct:_SFLEthernet_counters
SFLExtended_as_path_segment	libstar/sflowlib.h	/^SFLExtended_as_path_segment;$/;"	t	typeref:struct:_SFLExtended_as_path_segment
SFLExtended_as_path_segment_type	libstar/sflowlib.h	/^enum SFLExtended_as_path_segment_type$/;"	g
SFLExtended_gateway	libstar/sflowlib.h	/^SFLExtended_gateway;$/;"	t	typeref:struct:_SFLExtended_gateway
SFLExtended_mpls	libstar/sflowlib.h	/^SFLExtended_mpls;$/;"	t	typeref:struct:_SFLExtended_mpls
SFLExtended_mpls_FTN	libstar/sflowlib.h	/^SFLExtended_mpls_FTN;$/;"	t	typeref:struct:_SFLExtended_mpls_FTN
SFLExtended_mpls_LDP_FEC	libstar/sflowlib.h	/^SFLExtended_mpls_LDP_FEC;$/;"	t	typeref:struct:_SFLExtended_mpls_LDP_FEC
SFLExtended_mpls_tunnel	libstar/sflowlib.h	/^SFLExtended_mpls_tunnel;$/;"	t	typeref:struct:_SFLExtended_mpls_tunnel
SFLExtended_mpls_vc	libstar/sflowlib.h	/^SFLExtended_mpls_vc;$/;"	t	typeref:struct:_SFLExtended_mpls_vc
SFLExtended_nat	libstar/sflowlib.h	/^SFLExtended_nat;$/;"	t	typeref:struct:_SFLExtended_nat
SFLExtended_process	libstar/sflowlib.h	/^SFLExtended_process;$/;"	t	typeref:struct:_SFLExtended_process
SFLExtended_router	libstar/sflowlib.h	/^SFLExtended_router;$/;"	t	typeref:struct:_SFLExtended_router
SFLExtended_switch	libstar/sflowlib.h	/^SFLExtended_switch;$/;"	t	typeref:struct:_SFLExtended_switch
SFLExtended_url	libstar/sflowlib.h	/^SFLExtended_url;$/;"	t	typeref:struct:_SFLExtended_url
SFLExtended_url_direction	libstar/sflowlib.h	/^enum SFLExtended_url_direction$/;"	g
SFLExtended_user	libstar/sflowlib.h	/^SFLExtended_user;$/;"	t	typeref:struct:_SFLExtended_user
SFLExtended_vlan_tunnel	libstar/sflowlib.h	/^SFLExtended_vlan_tunnel;$/;"	t	typeref:struct:_SFLExtended_vlan_tunnel
SFLFLOW_ETHERNET	libstar/sflowlib.h	/^	SFLFLOW_ETHERNET = 2,	\/* MAC layer information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_CLASS	libstar/sflowlib.h	/^	SFLFLOW_EX_CLASS = (8800 << 12) + 1,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_GATEWAY	libstar/sflowlib.h	/^	SFLFLOW_EX_GATEWAY = 1003,	\/* Extended gateway router information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS	libstar/sflowlib.h	/^	SFLFLOW_EX_MPLS = 1006,	\/* Extended MPLS information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_FTN	libstar/sflowlib.h	/^	SFLFLOW_EX_MPLS_FTN = 1010,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_LDP_FEC	libstar/sflowlib.h	/^	SFLFLOW_EX_MPLS_LDP_FEC = 1011,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_TUNNEL	libstar/sflowlib.h	/^	SFLFLOW_EX_MPLS_TUNNEL = 1008,	\/* additional MPLS information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_VC	libstar/sflowlib.h	/^	SFLFLOW_EX_MPLS_VC = 1009,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_NAT	libstar/sflowlib.h	/^	SFLFLOW_EX_NAT = 1007,	\/* Extended NAT information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_PROCESS	libstar/sflowlib.h	/^	SFLFLOW_EX_PROCESS = (4300 << 12) + 3,	\/* =17612803 Extended Process information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_ROUTER	libstar/sflowlib.h	/^	SFLFLOW_EX_ROUTER = 1002,	\/* Extended router information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_SWITCH	libstar/sflowlib.h	/^	SFLFLOW_EX_SWITCH = 1001,	\/* Extended switch information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_URL	libstar/sflowlib.h	/^	SFLFLOW_EX_URL = 1005,	\/* Extended URL information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_USER	libstar/sflowlib.h	/^	SFLFLOW_EX_USER = 1004,	\/* Extended TACAS\/RADIUS user information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_VLAN_TUNNEL	libstar/sflowlib.h	/^	SFLFLOW_EX_VLAN_TUNNEL = 1012,	\/* VLAN stack *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_HEADER	libstar/sflowlib.h	/^	SFLFLOW_HEADER = 1,	\/* Packet headers are sampled *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_IPV4	libstar/sflowlib.h	/^	SFLFLOW_IPV4 = 3,	\/* IP version 4 data *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_IPV6	libstar/sflowlib.h	/^	SFLFLOW_IPV6 = 4,	\/* IP version 6 data *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_SAMPLE	libstar/sflowlib.h	/^	SFLFLOW_SAMPLE = 1,	\/* enterprise = 0 : format = 1 *\/$/;"	e	enum:SFL_sample_tag
SFLFLOW_SAMPLE_EXPANDED	libstar/sflowlib.h	/^	SFLFLOW_SAMPLE_EXPANDED = 3,	\/* enterprise = 0 : format = 3 *\/$/;"	e	enum:SFL_sample_tag
SFLFlow_sample	libstar/sflowlib.h	/^SFLFlow_sample;$/;"	t	typeref:struct:_SFLFlow_sample
SFLFlow_sample_element	libstar/sflowlib.h	/^SFLFlow_sample_element;$/;"	t	typeref:struct:_SFLFlow_sample_element
SFLFlow_sample_expanded	libstar/sflowlib.h	/^SFLFlow_sample_expanded;$/;"	t	typeref:struct:_SFLFlow_sample_expanded
SFLFlow_type	libstar/sflowlib.h	/^SFLFlow_type;$/;"	t	typeref:union:_SFLFlow_type
SFLFlow_type_tag	libstar/sflowlib.h	/^enum SFLFlow_type_tag$/;"	g
SFLHEADER_AAL5	libstar/sflowlib.h	/^	SFLHEADER_AAL5 = 9,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_AAL5_IP	libstar/sflowlib.h	/^	SFLHEADER_AAL5_IP = 10,	\/\/ e.g. Cisco AAL5 mux $/;"	e	enum:SFLHeader_protocol
SFLHEADER_ETHERNET_ISO8023	libstar/sflowlib.h	/^	SFLHEADER_ETHERNET_ISO8023 = 1,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_FDDI	libstar/sflowlib.h	/^	SFLHEADER_FDDI = 4,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_FRAME_RELAY	libstar/sflowlib.h	/^	SFLHEADER_FRAME_RELAY = 5,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_IPv4	libstar/sflowlib.h	/^	SFLHEADER_IPv4 = 11,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_IPv6	libstar/sflowlib.h	/^	SFLHEADER_IPv6 = 12,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_ISO88024_TOKENBUS	libstar/sflowlib.h	/^	SFLHEADER_ISO88024_TOKENBUS = 2,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_ISO88025_TOKENRING	libstar/sflowlib.h	/^	SFLHEADER_ISO88025_TOKENRING = 3,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_MPLS	libstar/sflowlib.h	/^	SFLHEADER_MPLS = 13$/;"	e	enum:SFLHeader_protocol
SFLHEADER_PPP	libstar/sflowlib.h	/^	SFLHEADER_PPP = 7,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_SMDS	libstar/sflowlib.h	/^	SFLHEADER_SMDS = 8,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_X25	libstar/sflowlib.h	/^	SFLHEADER_X25 = 6,$/;"	e	enum:SFLHeader_protocol
SFLHeader_protocol	libstar/sflowlib.h	/^enum SFLHeader_protocol$/;"	g
SFLIf_counters	libstar/sflowlib.h	/^SFLIf_counters;$/;"	t	typeref:struct:_SFLIf_counters
SFLLabelStack	libstar/sflowlib.h	/^SFLLabelStack;$/;"	t	typeref:struct:_SFLLabelStack
SFLOW_MAX_MSG_SIZE	libstar/sflowlib.h	730;"	d
SFLOW_MIN_MSG_SIZE	libstar/sflowlib.h	729;"	d
SFLProcess	libstar/sflowlib.h	/^SFLProcess;$/;"	t	typeref:struct:_SFLProcess
SFLProcessor_counters	libstar/sflowlib.h	/^SFLProcessor_counters;$/;"	t	typeref:struct:_SFLProcessor_counters
SFLSample_datagram_hdr	libstar/sflowlib.h	/^SFLSample_datagram_hdr;$/;"	t	typeref:struct:_SFLSample_datagram_hdr
SFLSampled_ethernet	libstar/sflowlib.h	/^SFLSampled_ethernet;$/;"	t	typeref:struct:_SFLSampled_ethernet
SFLSampled_header	libstar/sflowlib.h	/^SFLSampled_header;$/;"	t	typeref:struct:_SFLSampled_header
SFLSampled_ipv4	libstar/sflowlib.h	/^SFLSampled_ipv4;$/;"	t	typeref:struct:_SFLSampled_ipv4
SFLSampled_ipv6	libstar/sflowlib.h	/^SFLSampled_ipv6;$/;"	t	typeref:struct:_SFLSampled_ipv6
SFLString	libstar/sflowlib.h	/^SFLString;$/;"	t	typeref:struct:_SFLString
SFLTokenring_counters	libstar/sflowlib.h	/^SFLTokenring_counters;$/;"	t	typeref:struct:_SFLTokenring_counters
SFLVg_counters	libstar/sflowlib.h	/^SFLVg_counters;$/;"	t	typeref:struct:_SFLVg_counters
SFLVlanStack	libstar/sflowlib.h	/^typedef SFLLabelStack SFLVlanStack;$/;"	t
SFLVlan_counters	libstar/sflowlib.h	/^SFLVlan_counters;$/;"	t	typeref:struct:_SFLVlan_counters
SFL_DATA_PAD	libstar/sflowlib.h	722;"	d
SFL_DEFAULT_COLLECTOR_PORT	libstar/sflowlib.h	92;"	d
SFL_DEFAULT_DATAGRAM_SIZE	libstar/sflowlib.h	720;"	d
SFL_DEFAULT_HEADER_SIZE	libstar/sflowlib.h	91;"	d
SFL_DEFAULT_SAMPLING_RATE	libstar/sflowlib.h	93;"	d
SFL_MAX_DATAGRAM_SIZE	libstar/sflowlib.h	718;"	d
SFL_MAX_PROCESSES	libstar/sflowlib.h	372;"	d
SFL_MIN_DATAGRAM_SIZE	libstar/sflowlib.h	719;"	d
SFL_sample_tag	libstar/sflowlib.h	/^enum SFL_sample_tag$/;"	g
SFSample	libstar/sflowlib.h	/^SFSample;$/;"	t	typeref:struct:_SFSample
SHA1_H	lib/sha1.h	14;"	d
SHA1_HASH	lib/sha1.h	/^}	SHA1_HASH;$/;"	t	typeref:struct:__anon21
SHA1_HASH_SIZE	lib/sha1.h	30;"	d
SHA256_H	lib/sha256.h	12;"	d
SHA256_HASH	lib/sha256.h	/^} SHA256_HASH;$/;"	t	typeref:struct:__anon23
SHA256_HASH_SIZE	lib/sha256.h	26;"	d
SHA512_H	lib/sha512.h	12;"	d
SHA512_HASH	lib/sha512.h	/^}	SHA512_HASH;$/;"	t	typeref:struct:__anon25
SHA512_HASH_SIZE	lib/sha512.h	27;"	d
SHASH_ALLOC	libstar/shash.c	23;"	d	file:
SHASH_ALLOC	libstar/shash.c	26;"	d	file:
SHASH_DEBUG	libstar/fhash.c	19;"	d	file:
SHASH_DEBUG	libstar/shash.c	20;"	d	file:
SHASH_FREE	libstar/shash.c	24;"	d	file:
SHASH_FREE	libstar/shash.c	27;"	d	file:
SHASH_FUNC	libstar/shash.c	35;"	d	file:
SHASH_FUNC	libstar/shash.c	37;"	d	file:
SIGSET	libstar/xdebug.h	74;"	d
SMIME_APPLICATION	libstar/smime.h	26;"	d
SMIME_APP_DEBIAN_PACKAGE	libstar/smime.h	71;"	d
SMIME_APP_EXECUTABLE	libstar/smime.h	72;"	d
SMIME_APP_GTAR	libstar/smime.h	73;"	d
SMIME_APP_OCTET_STREAM	libstar/smime.h	76;"	d
SMIME_APP_PDF	libstar/smime.h	69;"	d
SMIME_APP_POSTSCRIPT	libstar/smime.h	68;"	d
SMIME_APP_RTF	libstar/smime.h	67;"	d
SMIME_APP_SHELLSCRIPT	libstar/smime.h	74;"	d
SMIME_APP_TAR	libstar/smime.h	75;"	d
SMIME_APP_ZIP	libstar/smime.h	70;"	d
SMIME_AUDIO	libstar/smime.h	24;"	d
SMIME_AUDIO_AIFF	libstar/smime.h	58;"	d
SMIME_AUDIO_MIDI	libstar/smime.h	56;"	d
SMIME_AUDIO_MPEGAUD	libstar/smime.h	55;"	d
SMIME_AUDIO_WAV	libstar/smime.h	57;"	d
SMIME_BOUND	libstar/smime.h	18;"	d
SMIME_CHARSET_EUC_KR	libstar/smime.h	102;"	d
SMIME_CHARSET_GB2312	libstar/smime.h	101;"	d
SMIME_CHARSET_ISO8859_1	libstar/smime.h	98;"	d
SMIME_CHARSET_ISO8859_2	libstar/smime.h	99;"	d
SMIME_CHARSET_ISO8859_3	libstar/smime.h	100;"	d
SMIME_CHARSET_NOCHARSET	libstar/smime.h	96;"	d
SMIME_CHARSET_USASCII	libstar/smime.h	97;"	d
SMIME_CUSTOM	libstar/smime.h	28;"	d
SMIME_ENC_7BIT	libstar/smime.h	88;"	d
SMIME_ENC_8BIT	libstar/smime.h	89;"	d
SMIME_ENC_BASE64	libstar/smime.h	91;"	d
SMIME_ENC_BINARY	libstar/smime.h	90;"	d
SMIME_ENC_QUOTED	libstar/smime.h	92;"	d
SMIME_IMAGE	libstar/smime.h	23;"	d
SMIME_IMAGE_GIF	libstar/smime.h	42;"	d
SMIME_IMAGE_JPG	libstar/smime.h	43;"	d
SMIME_IMAGE_MS_BMP	libstar/smime.h	46;"	d
SMIME_IMAGE_PNG	libstar/smime.h	44;"	d
SMIME_IMAGE_PORTABLE_ANYMAP	libstar/smime.h	49;"	d
SMIME_IMAGE_PORTABLE_BITMAP	libstar/smime.h	50;"	d
SMIME_IMAGE_PORTABLE_GRAYMAP	libstar/smime.h	51;"	d
SMIME_IMAGE_PORTABLE_PIXMAP	libstar/smime.h	52;"	d
SMIME_IMAGE_TIFF	libstar/smime.h	45;"	d
SMIME_IMAGE_XBITMAP	libstar/smime.h	47;"	d
SMIME_IMAGE_XPIXMAP	libstar/smime.h	48;"	d
SMIME_MAX	libstar/smime.h	29;"	d
SMIME_MAX_APPLICATION	libstar/smime.h	77;"	d
SMIME_MAX_AUDIO	libstar/smime.h	59;"	d
SMIME_MAX_CHARSET	libstar/smime.h	103;"	d
SMIME_MAX_ENC	libstar/smime.h	93;"	d
SMIME_MAX_IMAGE	libstar/smime.h	53;"	d
SMIME_MAX_MESSAGE	libstar/smime.h	40;"	d
SMIME_MAX_MULTIPART	libstar/smime.h	83;"	d
SMIME_MAX_TEXT	libstar/smime.h	36;"	d
SMIME_MAX_VIDEO	libstar/smime.h	65;"	d
SMIME_MESSAGE	libstar/smime.h	22;"	d
SMIME_MESSAGE_PARTIAL	libstar/smime.h	39;"	d
SMIME_MESSAGE_RFC822	libstar/smime.h	38;"	d
SMIME_MULTIPART	libstar/smime.h	27;"	d
SMIME_MULTIPART_ALTERNATIVE	libstar/smime.h	82;"	d
SMIME_MULTIPART_DIGEST	libstar/smime.h	81;"	d
SMIME_MULTIPART_MIXED	libstar/smime.h	79;"	d
SMIME_MULTIPART_PARALLEL	libstar/smime.h	80;"	d
SMIME_SUB_CUSTOM	libstar/smime.h	85;"	d
SMIME_TEXT	libstar/smime.h	21;"	d
SMIME_TEXT_ENGLISH	libstar/smime.h	34;"	d
SMIME_TEXT_HTML	libstar/smime.h	33;"	d
SMIME_TEXT_PLAIN	libstar/smime.h	32;"	d
SMIME_TEXT_RICHTEXT	libstar/smime.h	35;"	d
SMIME_VIDEO	libstar/smime.h	25;"	d
SMIME_VIDEO_FLI	libstar/smime.h	64;"	d
SMIME_VIDEO_MPEGVID	libstar/smime.h	61;"	d
SMIME_VIDEO_MSVIDEO	libstar/smime.h	62;"	d
SMIME_VIDEO_QUICKTIME	libstar/smime.h	63;"	d
SMS_ERR_AUTH_FAIL	libstar/smslib.h	23;"	d
SMS_ERR_BAD_ARG	libstar/smslib.h	24;"	d
SMS_ERR_SUCCESS	libstar/smslib.h	22;"	d
SNMP_FLAG_ALL	libstar/xsnmp.h	/^	SNMP_FLAG_ALL		= 0x0000,	\/\/ Interfaces의 모든 정보 입수$/;"	e	enum:__anon157
SNMP_FLAG_BPSPPS	libstar/xsnmp.h	/^	SNMP_FLAG_BPSPPS	= 0x0002,	\/\/ BPS\/PPS 정보만 입수$/;"	e	enum:__anon157
SNMP_FLAG_CACHE	libstar/xsnmp.h	/^	SNMP_FLAG_CACHE		= 0x0020,	\/\/ INF Caching을 위해 정보 수집 $/;"	e	enum:__anon157
SNMP_FLAG_HW	libstar/xsnmp.h	/^	SNMP_FLAG_HW		= 0x0004,	\/\/ H\/W 정보만 입수$/;"	e	enum:__anon157
SNMP_FLAG_LG	libstar/xsnmp.h	/^	SNMP_FLAG_LG		= 0x0008,	\/\/ BPSPPS + Admin\/OperStatus + Speed + Descr + IfName(CISCO)$/;"	e	enum:__anon157
SNMP_FLAG_STATUS	libstar/xsnmp.h	/^	SNMP_FLAG_STATUS	= 0x0010,	\/\/ AdminStatus,OperStatus 상태 정보만 입수 $/;"	e	enum:__anon157
SNMP_FLAG_TRAFFIC	libstar/xsnmp.h	/^	SNMP_FLAG_TRAFFIC	= 0x0001,	\/\/ I\/O 트래픽 관련 정보만 입수$/;"	e	enum:__anon157
SOCKET	libstar/xtn.c	34;"	d	file:
SRECV	libstar/ssmtp.h	/^}	SRECV;$/;"	t	typeref:struct:__anon99
SSMTP_BODY_MODULE	libstar/ssmtp.h	82;"	d
SSMTP_BODY_STAGE	libstar/ssmtp.h	98;"	d
SSMTP_CONNECT_STAGE	libstar/ssmtp.h	90;"	d
SSMTP_DATA_STAGE	libstar/ssmtp.h	95;"	d
SSMTP_DIALOGUE_MODULE	libstar/ssmtp.h	85;"	d
SSMTP_ERR_AUTHLOGIN	libstar/ssmtp.h	64;"	d
SSMTP_ERR_BADARGS	libstar/ssmtp.h	47;"	d
SSMTP_ERR_BADCHARSET	libstar/ssmtp.h	60;"	d
SSMTP_ERR_BADENCODING	libstar/ssmtp.h	59;"	d
SSMTP_ERR_BADFUNCPARA	libstar/ssmtp.h	40;"	d
SSMTP_ERR_BADMIME	libstar/ssmtp.h	58;"	d
SSMTP_ERR_BADSTAGE	libstar/ssmtp.h	55;"	d
SSMTP_ERR_BASE64_ENCODE	libstar/ssmtp.h	62;"	d
SSMTP_ERR_CHECKPART	libstar/ssmtp.h	56;"	d
SSMTP_ERR_CONNECTFATAL	libstar/ssmtp.h	42;"	d
SSMTP_ERR_GETMYHOSTNAME	libstar/ssmtp.h	48;"	d
SSMTP_ERR_GETSRVHOSTNAME	libstar/ssmtp.h	49;"	d
SSMTP_ERR_MALLOC_BUF	libstar/ssmtp.h	63;"	d
SSMTP_ERR_MIMEPARTINIT	libstar/ssmtp.h	57;"	d
SSMTP_ERR_MXNOFOUND	libstar/ssmtp.h	43;"	d
SSMTP_ERR_NOTACCEPTDATA	libstar/ssmtp.h	51;"	d
SSMTP_ERR_NOTACCEPTSENDER	libstar/ssmtp.h	50;"	d
SSMTP_ERR_NOTWELCOME	libstar/ssmtp.h	46;"	d
SSMTP_ERR_READFATAL	libstar/ssmtp.h	44;"	d
SSMTP_ERR_REJECTBODY	libstar/ssmtp.h	52;"	d
SSMTP_ERR_REJECTQUIT	libstar/ssmtp.h	53;"	d
SSMTP_ERR_SESSIONINIT	libstar/ssmtp.h	41;"	d
SSMTP_ERR_SOCKET_TIMEOUT	libstar/ssmtp.h	61;"	d
SSMTP_ERR_TOOSMALLBUF	libstar/ssmtp.h	54;"	d
SSMTP_ERR_WRITEFATAL	libstar/ssmtp.h	45;"	d
SSMTP_FINISHED_STAGE	libstar/ssmtp.h	99;"	d
SSMTP_GREET_STAGE	libstar/ssmtp.h	91;"	d
SSMTP_HAS_8BIT	libstar/ssmtp.h	68;"	d
SSMTP_HAS_AUTH	libstar/ssmtp.h	69;"	d
SSMTP_HAS_DSN	libstar/ssmtp.h	72;"	d
SSMTP_HAS_ENHANCEDSTATUSCODES	libstar/ssmtp.h	74;"	d
SSMTP_HAS_ETRN	libstar/ssmtp.h	73;"	d
SSMTP_HAS_PIPELINING	libstar/ssmtp.h	70;"	d
SSMTP_HAS_SIZE	libstar/ssmtp.h	71;"	d
SSMTP_HAS_TLS	libstar/ssmtp.h	67;"	d
SSMTP_HEADERS_STAGE	libstar/ssmtp.h	96;"	d
SSMTP_HEADER_MODULE	libstar/ssmtp.h	84;"	d
SSMTP_HELLO_STAGE	libstar/ssmtp.h	92;"	d
SSMTP_IP	libstar/ssmtp.h	30;"	d
SSMTP_LIB_H	libstar/ssmtplib.h	14;"	d
SSMTP_MAX_MODULE	libstar/ssmtp.h	86;"	d
SSMTP_MAX_REC	libstar/ssmtp.h	80;"	d
SSMTP_MAX_STAGE	libstar/ssmtp.h	101;"	d
SSMTP_MAX_TYPE	libstar/ssmtp.h	75;"	d
SSMTP_MIMEHEADERS_STAGE	libstar/ssmtp.h	97;"	d
SSMTP_MIME_MODULE	libstar/ssmtp.h	83;"	d
SSMTP_MIME_PART	libstar/ssmtp.h	/^}	SSMTP_MIME_PART;$/;"	t	typeref:struct:__anon100
SSMTP_NOCONNECT_STAGE	libstar/ssmtp.h	89;"	d
SSMTP_OK	libstar/ssmtp.h	39;"	d
SSMTP_PORT	libstar/ssmtp.h	29;"	d
SSMTP_QUIT_STAGE	libstar/ssmtp.h	100;"	d
SSMTP_RECIPIENT_STAGE	libstar/ssmtp.h	94;"	d
SSMTP_REC_BCC	libstar/ssmtp.h	79;"	d
SSMTP_REC_CC	libstar/ssmtp.h	78;"	d
SSMTP_REC_TO	libstar/ssmtp.h	77;"	d
SSMTP_SENDER_STAGE	libstar/ssmtp.h	93;"	d
SSMTP_SESSION	libstar/ssmtp.h	/^}	SSMTP_SESSION;$/;"	t	typeref:struct:__anon101
STACK_MASK	libstar/sflowlib.h	949;"	d
STACK_SHIFT	libstar/sflowlib.h	950;"	d
STANDARD	json11/json11.hpp	/^    STANDARD, COMMENTS$/;"	e	enum:json11::JsonParse
START_MONTH	libstar/lock.c	55;"	d	file:
START_YEAR	libstar/lock.c	54;"	d	file:
STATE_ADD	libstar/dvdlib.c	1421;"	d	file:
STATE_CODE	libstar/xtn.c	/^	STATE_CODE,		\/\/we expect a code$/;"	e	enum:__anon175	file:
STATE_DATA	libstar/xtn.c	/^	STATE_DATA,		\/\/we expect a data byte$/;"	e	enum:__anon175	file:
STATE_END	libstar/dvdlib.c	1422;"	d	file:
STATE_OPTION	libstar/xtn.c	/^	STATE_OPTION		\/\/we expect an option$/;"	e	enum:__anon175	file:
STATE_PING	libstar/xnms.h	/^	STATE_PING	= 0x0002,		\/\/ SNMP 정보 수집에 실패해 PING 하는 중$/;"	e	enum:__anon143
STATE_PING_FAIL	libstar/xnms.h	/^	STATE_PING_FAIL	= 0x0020,		\/\/ SNMP 정보 수집에 실패해 PING 하는 중$/;"	e	enum:__anon143
STATE_SNMP	libstar/xnms.h	/^	STATE_SNMP	= 0x0004,		\/\/ SNMP 정보 수집 중$/;"	e	enum:__anon143
STATE_SNMP_FAIL	libstar/xnms.h	/^	STATE_SNMP_FAIL	= 0x0040,		\/\/ SNMP 정보 수집 중$/;"	e	enum:__anon143
STATE_SNMP_TOO_SLOW	libstar/xnms.h	/^	STATE_SNMP_TOO_SLOW = 0x0080,		\/\/ SNMP 정보 수집 시간이 30초 이상 소요되는 경우 별도 thread에서 처리$/;"	e	enum:__anon143
STEP	lib/md5.c	31;"	d	file:
STORE32H	lib/sha256.c	20;"	d	file:
STORE64H	lib/sha256.c	30;"	d	file:
STORE64H	lib/sha512.c	26;"	d	file:
STRING	json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::final::Type
SUM_IFVAL	libstar/snmpsub.c	1106;"	d	file:
SYBASE_DB	libstar/xdb.h	/^	SYBASE_DB,$/;"	e	enum:__anon114
S_ISCHR	libstar/xutil.h	88;"	d
S_ISDIR	libstar/xutil.h	85;"	d
S_ISREG	libstar/xutil.h	82;"	d
SaveData	libstar/hash.h	/^	void		SaveData(hashent_t *he, void *val, uint datalen)	{ hash_savedata(he, val, datalen); }$/;"	f	class:CHash
SaveData	libstar/xlist.h	/^	xlistnode_t	*SaveData(xlistnode_t *node, void *data, int datalen)	{ return xlist_savedata(node, data, datalen); }$/;"	f	class:CXList
SetConsoleMode	libstar/xtn.c	104;"	d	file:
SetConsoleTextAttribute	libstar/xtn.c	105;"	d	file:
SetData	libstar/hash.h	/^	void		SetData(hashent_t *he, void *val, uint datalen)		{ hash_setdata(he, val, datalen); }$/;"	f	class:CHash
SetData	libstar/xlist.h	/^	xlistnode_t	*SetData(xlistnode_t *node, void *data, int datalen)	{ return xlist_setdata(node, data, datalen); }$/;"	f	class:CXList
SetPdu	libstar/xsnmp.h	/^	BOOL		SetPdu(int type)				{ return xsnmp_setpdu(m_xs, type); }$/;"	f	class:CXSnmp
SetTimeout	libstar/xsnmp.h	/^	void		SetTimeout(int timeoutMS = 1000, uint retries = 3)	{ xsnmp_settimeout(m_xs, timeoutMS, retries); }$/;"	f	class:CXSnmp
Sha1Context	lib/sha1.h	/^}	Sha1Context;$/;"	t	typeref:struct:__anon20
Sha1Finalise	lib/sha1.c	/^void	Sha1Finalise(Sha1Context *Context, SHA1_HASH *Digest)$/;"	f
Sha1Hash	lib/test_hashlib.c	/^    SHA1_HASH       Sha1Hash;$/;"	m	struct:__anon181	file:
Sha1Initialise	lib/sha1.c	/^void	Sha1Initialise(Sha1Context *Context)$/;"	f
Sha1Update	lib/sha1.c	/^void	Sha1Update(Sha1Context *Context, const void *Buffer, const uint32_t BufferSize)$/;"	f
Sha256Context	lib/sha256.h	/^} Sha256Context;$/;"	t	typeref:struct:__anon22
Sha256Finalise	lib/sha256.c	/^void	Sha256Finalise(Sha256Context *Context, SHA256_HASH *Digest)$/;"	f
Sha256Hash	lib/test_hashlib.c	/^    SHA256_HASH     Sha256Hash;$/;"	m	struct:__anon181	file:
Sha256Initialise	lib/sha256.c	/^void	Sha256Initialise(Sha256Context *Context)$/;"	f
Sha256Round	lib/sha256.c	67;"	d	file:
Sha256Update	lib/sha256.c	/^void	Sha256Update(Sha256Context *Context, const void *Buffer, uint32_t BufferSize)$/;"	f
Sha512Context	lib/sha512.h	/^}	Sha512Context;$/;"	t	typeref:struct:__anon24
Sha512Finalise	lib/sha512.c	/^void	Sha512Finalise(Sha512Context *Context, SHA512_HASH *Digest)$/;"	f
Sha512Hash	lib/test_hashlib.c	/^    SHA512_HASH     Sha512Hash;$/;"	m	struct:__anon181	file:
Sha512Initialise	lib/sha512.c	/^void	Sha512Initialise(Sha512Context *Context)$/;"	f
Sha512Round	lib/sha512.c	74;"	d	file:
Sha512Update	lib/sha512.c	/^void	Sha512Update(Sha512Context *Context, const void *Buffer, uint32_t BufferSize)$/;"	f
Sigma0	lib/sha256.c	62;"	d	file:
Sigma0	lib/sha512.c	69;"	d	file:
Sigma1	lib/sha256.c	63;"	d	file:
Sigma1	lib/sha512.c	70;"	d	file:
SnmpPdu	libstar/xsnmp.h	/^typedef struct snmp_pdu		SnmpPdu;$/;"	t	typeref:struct:snmp_pdu
SnmpSession	libstar/xsnmp.h	/^typedef struct snmp_session	SnmpSession;$/;"	t	typeref:struct:snmp_session
SnmpVarList	libstar/xsnmp.h	/^typedef struct variable_list	SnmpVarList;$/;"	t	typeref:struct:variable_list
SrbDir	libstar/dvdlib.c	/^const char	SrbDir[0x100] = {$/;"	v
SrbDir	libstar/oddlibwin.c	/^const char      SrbDir[0x100] = {$/;"	v
Stage	libstar/ssmtp.h	/^	int             Stage;			\/\/ SMTP transfer stage $/;"	m	struct:__anon101
Start	libstar/xnms.h	/^	int		Start()				{ xnms_start(m_xnms); }$/;"	f	class:CXNms
State	lib/sha1.h	/^    uint32_t        State[5];$/;"	m	struct:__anon20
Statics	json11/json11.cpp	/^    Statics() {}$/;"	f	struct:json11::Statics
Statics	json11/json11.cpp	/^struct Statics {$/;"	s	namespace:json11	file:
Stop	libstar/xnms.h	/^	void		Stop()				{ xnms_stop(m_xnms); }$/;"	f	class:CXNms
Subject	libstar/ssmtp.h	/^	char            Subject[MAX_ARG_LEN];	\/\/ Mail subject $/;"	m	struct:__anon101
Subtype	libstar/ssmtp.h	/^	int             Subtype;		\/\/ MIME subtype $/;"	m	struct:__anon100
SwapBytes	lib/rc4.c	16;"	d	file:
T1	libstar/md5.c	67;"	d	file:
T10	libstar/md5.c	76;"	d	file:
T11	libstar/md5.c	77;"	d	file:
T12	libstar/md5.c	78;"	d	file:
T13	libstar/md5.c	79;"	d	file:
T14	libstar/md5.c	80;"	d	file:
T15	libstar/md5.c	81;"	d	file:
T16	libstar/md5.c	82;"	d	file:
T17	libstar/md5.c	83;"	d	file:
T18	libstar/md5.c	84;"	d	file:
T19	libstar/md5.c	85;"	d	file:
T2	libstar/md5.c	68;"	d	file:
T20	libstar/md5.c	86;"	d	file:
T21	libstar/md5.c	87;"	d	file:
T22	libstar/md5.c	88;"	d	file:
T23	libstar/md5.c	89;"	d	file:
T24	libstar/md5.c	90;"	d	file:
T25	libstar/md5.c	91;"	d	file:
T26	libstar/md5.c	92;"	d	file:
T27	libstar/md5.c	93;"	d	file:
T28	libstar/md5.c	94;"	d	file:
T29	libstar/md5.c	95;"	d	file:
T3	libstar/md5.c	69;"	d	file:
T30	libstar/md5.c	96;"	d	file:
T31	libstar/md5.c	97;"	d	file:
T32	libstar/md5.c	98;"	d	file:
T33	libstar/md5.c	99;"	d	file:
T34	libstar/md5.c	100;"	d	file:
T35	libstar/md5.c	101;"	d	file:
T36	libstar/md5.c	102;"	d	file:
T37	libstar/md5.c	103;"	d	file:
T38	libstar/md5.c	104;"	d	file:
T39	libstar/md5.c	105;"	d	file:
T4	libstar/md5.c	70;"	d	file:
T40	libstar/md5.c	106;"	d	file:
T41	libstar/md5.c	107;"	d	file:
T42	libstar/md5.c	108;"	d	file:
T43	libstar/md5.c	109;"	d	file:
T44	libstar/md5.c	110;"	d	file:
T45	libstar/md5.c	111;"	d	file:
T46	libstar/md5.c	112;"	d	file:
T47	libstar/md5.c	113;"	d	file:
T48	libstar/md5.c	114;"	d	file:
T49	libstar/md5.c	115;"	d	file:
T5	libstar/md5.c	71;"	d	file:
T50	libstar/md5.c	116;"	d	file:
T51	libstar/md5.c	117;"	d	file:
T52	libstar/md5.c	118;"	d	file:
T53	libstar/md5.c	119;"	d	file:
T54	libstar/md5.c	120;"	d	file:
T55	libstar/md5.c	121;"	d	file:
T56	libstar/md5.c	122;"	d	file:
T57	libstar/md5.c	123;"	d	file:
T58	libstar/md5.c	124;"	d	file:
T59	libstar/md5.c	125;"	d	file:
T6	libstar/md5.c	72;"	d	file:
T60	libstar/md5.c	126;"	d	file:
T61	libstar/md5.c	127;"	d	file:
T62	libstar/md5.c	128;"	d	file:
T63	libstar/md5.c	129;"	d	file:
T64	libstar/md5.c	130;"	d	file:
T7	libstar/md5.c	73;"	d	file:
T8	libstar/md5.c	74;"	d	file:
T9	libstar/md5.c	75;"	d	file:
TCPSTAT_CLOSED	libstar/snmpdef.h	387;"	d
TCPSTAT_CLOSE_WAIT	libstar/snmpdef.h	394;"	d
TCPSTAT_CLOSING	libstar/snmpdef.h	398;"	d
TCPSTAT_DELETETCB	libstar/snmpdef.h	404;"	d
TCPSTAT_ESTABLISHED	libstar/snmpdef.h	393;"	d
TCPSTAT_FIN_WAIT1	libstar/snmpdef.h	397;"	d
TCPSTAT_FIN_WAIT2	libstar/snmpdef.h	402;"	d
TCPSTAT_LAST_ACK	libstar/snmpdef.h	399;"	d
TCPSTAT_LISTEN	libstar/snmpdef.h	388;"	d
TCPSTAT_MAX	libstar/snmpdef.h	405;"	d
TCPSTAT_SYN_RECV	libstar/snmpdef.h	390;"	d
TCPSTAT_SYN_SENT	libstar/snmpdef.h	389;"	d
TCPSTAT_TIME_WAIT	libstar/snmpdef.h	403;"	d
TEMPLATE_CACHE_ENTRIES	libstar/nflowlib.h	567;"	d
TEST_BUF_SIZE	libstar/oddlibwin.c	14;"	d	file:
TOHEXDIGIT	lib/libhash.h	26;"	d
TOHEXDIGIT	libhash.h	26;"	d
TOPT_3270	libstar/xtn.c	/^	TOPT_3270 = 29,		\/\/ Telnet 3270 Regime$/;"	e	enum:__anon176	file:
TOPT_APRX	libstar/xtn.c	/^	TOPT_APRX = 4,		\/\/ Approx Message Size Negotiation$/;"	e	enum:__anon176	file:
TOPT_AUTH	libstar/xtn.c	/^	TOPT_AUTH = 37,		\/\/ Telnet Authentication Option$/;"	e	enum:__anon176	file:
TOPT_BIN	libstar/xtn.c	/^	TOPT_BIN = 0,		\/\/ Binary Transmission$/;"	e	enum:__anon176	file:
TOPT_BYTE	libstar/xtn.c	/^	TOPT_BYTE = 19,		\/\/ Byte Macro$/;"	e	enum:__anon176	file:
TOPT_DATA	libstar/xtn.c	/^	TOPT_DATA = 20,		\/\/ Data Entry Terminal$/;"	e	enum:__anon176	file:
TOPT_ECHO	libstar/xtn.c	/^	TOPT_ECHO = 1,		\/\/ Echo$/;"	e	enum:__anon176	file:
TOPT_ENVIR	libstar/xtn.c	/^	TOPT_ENVIR = 36,	\/\/ Telnet Environment Option$/;"	e	enum:__anon176	file:
TOPT_EOR	libstar/xtn.c	/^	TOPT_EOR = 25,		\/\/ End of Record$/;"	e	enum:__anon176	file:
TOPT_ERROR	libstar/xtn.c	/^	TOPT_ERROR = 256	\/\/ Magic number$/;"	e	enum:__anon176	file:
TOPT_EXT	libstar/xtn.c	/^	TOPT_EXT = 17,		\/\/ Extended ASCII$/;"	e	enum:__anon176	file:
TOPT_EXTOP	libstar/xtn.c	/^	TOPT_EXTOP = 255,	\/\/ Extended-Options-List$/;"	e	enum:__anon176	file:
TOPT_LINE	libstar/xtn.c	/^	TOPT_LINE = 34,		\/\/ Linemode$/;"	e	enum:__anon176	file:
TOPT_LOGO	libstar/xtn.c	/^	TOPT_LOGO = 18,		\/\/ Logout$/;"	e	enum:__anon176	file:
TOPT_NAWS	libstar/xtn.c	/^	TOPT_NAWS = 31,		\/\/ Negotiate About Window Size$/;"	e	enum:__anon176	file:
TOPT_NENVIR	libstar/xtn.c	/^	TOPT_NENVIR = 39,	\/\/ Telnet Environment Option$/;"	e	enum:__anon176	file:
TOPT_OCRD	libstar/xtn.c	/^	TOPT_OCRD = 10,		\/\/ Output Carriage-Return Disposition$/;"	e	enum:__anon176	file:
TOPT_OFD	libstar/xtn.c	/^	TOPT_OFD = 13,		\/\/ Output Formfeed Disposition$/;"	e	enum:__anon176	file:
TOPT_OHT	libstar/xtn.c	/^	TOPT_OHT = 11,		\/\/ Output Horizontal Tabstops$/;"	e	enum:__anon176	file:
TOPT_OHTD	libstar/xtn.c	/^	TOPT_OHTD = 12,		\/\/ Output Horizontal Tab Disposition$/;"	e	enum:__anon176	file:
TOPT_OLD	libstar/xtn.c	/^	TOPT_OLD = 16,		\/\/ Output Linefeed Disposition$/;"	e	enum:__anon176	file:
TOPT_OLW	libstar/xtn.c	/^	TOPT_OLW = 8,		\/\/ Output Line Width$/;"	e	enum:__anon176	file:
TOPT_OM	libstar/xtn.c	/^	TOPT_OM = 27,		\/\/ Output Marking$/;"	e	enum:__anon176	file:
TOPT_OPS	libstar/xtn.c	/^	TOPT_OPS = 9,		\/\/ Output Page Size$/;"	e	enum:__anon176	file:
TOPT_OVT	libstar/xtn.c	/^	TOPT_OVT = 14,		\/\/ Output Vertical Tabstops$/;"	e	enum:__anon176	file:
TOPT_OVTD	libstar/xtn.c	/^	TOPT_OVTD = 15,		\/\/ Output Vertical Tab Disposition$/;"	e	enum:__anon176	file:
TOPT_RECN	libstar/xtn.c	/^	TOPT_RECN = 2,		\/\/ Reconnection$/;"	e	enum:__anon176	file:
TOPT_REM	libstar/xtn.c	/^	TOPT_REM = 7,		\/\/ Remote Controlled Trans and Echo$/;"	e	enum:__anon176	file:
TOPT_RFC	libstar/xtn.c	/^	TOPT_RFC = 33,		\/\/ Remote Flow Control$/;"	e	enum:__anon176	file:
TOPT_SNDL	libstar/xtn.c	/^	TOPT_SNDL = 23,		\/\/ Send Location$/;"	e	enum:__anon176	file:
TOPT_STAT	libstar/xtn.c	/^	TOPT_STAT = 5,		\/\/ Status$/;"	e	enum:__anon176	file:
TOPT_SUP	libstar/xtn.c	/^	TOPT_SUP = 21,		\/\/ SUPDUP$/;"	e	enum:__anon176	file:
TOPT_SUPO	libstar/xtn.c	/^	TOPT_SUPO = 22,		\/\/ SUPDUP Output$/;"	e	enum:__anon176	file:
TOPT_SUPP	libstar/xtn.c	/^	TOPT_SUPP = 3,		\/\/ Suppress Go Ahead$/;"	e	enum:__anon176	file:
TOPT_TACACS	libstar/xtn.c	/^	TOPT_TACACS = 26,	\/\/ TACACS User Identification$/;"	e	enum:__anon176	file:
TOPT_TERM	libstar/xtn.c	/^	TOPT_TERM = 24,		\/\/ Terminal Type (0x18)$/;"	e	enum:__anon176	file:
TOPT_TIM	libstar/xtn.c	/^	TOPT_TIM = 6,		\/\/ Timing Mark$/;"	e	enum:__anon176	file:
TOPT_TLN	libstar/xtn.c	/^	TOPT_TLN = 28,		\/\/ Terminal Location Number$/;"	e	enum:__anon176	file:
TOPT_TS	libstar/xtn.c	/^	TOPT_TS = 32,		\/\/ Terminal Speed$/;"	e	enum:__anon176	file:
TOPT_X3	libstar/xtn.c	/^	TOPT_X3 = 30,		\/\/ X.3 PAD$/;"	e	enum:__anon176	file:
TOPT_XDL	libstar/xtn.c	/^	TOPT_XDL = 35,		\/\/ X Display Location$/;"	e	enum:__anon176	file:
TO_CLIENT	libstar/gw.h	/^	TO_CLIENT,$/;"	e	enum:__anon37
TO_GATEWAY	libstar/gw.h	/^	TO_GATEWAY,$/;"	e	enum:__anon37
TPROPT	libstar/xdebug.h	184;"	d
TRACE	libstar/netbios.c	484;"	d	file:
TRACE	libstar/snmpdump.c	20;"	d	file:
TRACE	libstar/xnms.c	28;"	d	file:
TRANSLATEASPI32ADDRESS	libstar/dvdlib.c	/^typedef BOOL(*TRANSLATEASPI32ADDRESS) (PDWORD, PDWORD);$/;"	t	file:
TRANSLATEASPI32ADDRESS	libstar/oddlibwin.c	/^typedef         BOOL(*TRANSLATEASPI32ADDRESS) (PDWORD, PDWORD);$/;"	t	file:
TRIAL_MONTH	libstar/lock.c	59;"	d	file:
TRIAL_YEAR	libstar/lock.c	58;"	d	file:
TRUE	libstar/type.h	25;"	d
TTL	libstar/xicmp.h	/^	uchar		TTL;			\/\/ Time To Live$/;"	m	struct:__anon131
TTL_MASK	libstar/sflowlib.h	951;"	d
TTL_SHIFT	libstar/sflowlib.h	952;"	d
T_MASK	libstar/md5.c	66;"	d	file:
T_PING_ALL	libstar/xping.h	/^	T_PING_ALL	= 0,$/;"	e	enum:__anon155
T_PING_FAIL	libstar/xping.h	/^	T_PING_FAIL,$/;"	e	enum:__anon155
T_PING_OK	libstar/xping.h	/^	T_PING_OK,$/;"	e	enum:__anon155
TargetId	libstar/dvdlib.c	/^	char		TargetId;$/;"	m	struct:__anon28	file:
TargetId	libstar/oddlibwin.c	/^	char            TargetId;$/;"	m	struct:__anon65	file:
TestMd5	lib/test_hashlib.c	/^static	bool	TestMd5 (void)$/;"	f	file:
TestRc4	lib/test_hashlib.c	/^static	bool	TestRc4(void)$/;"	f	file:
TestSha1	lib/test_hashlib.c	/^static	bool	TestSha1(void)$/;"	f	file:
TestSha256	lib/test_hashlib.c	/^static	bool	TestSha256(void)$/;"	f	file:
TestSha512	lib/test_hashlib.c	/^static	bool	TestSha512(void)$/;"	f	file:
TestVector	lib/test_hashlib.c	/^} TestVector;$/;"	t	typeref:struct:__anon181	file:
To	libstar/ssmtp.h	/^	SRECV          To;			\/\/ All recipients addresses $/;"	m	struct:__anon101
ToResponse	libstar/ssmtp.h	/^	SRECV          ToResponse;		\/\/ List of failed recipients containing the response for each failure $/;"	m	struct:__anon101
TotalLength	libstar/xicmp.h	/^	ushort		TotalLength;		\/\/ total length of the packet$/;"	m	struct:__anon131
TraceRoute	libstar/xping.c	/^int	CXPing::TraceRoute(CString szHostName, CUIntArray& arRetAddr, CUIntArray& arDelayUS)$/;"	f	class:CXPing
TransformFunction	lib/md5.c	/^static	void	*TransformFunction(Md5Context *ctx, const void *data, uintmax_t size)$/;"	f	file:
TransformFunction	lib/sha1.c	/^static	void	TransformFunction(uint32_t state[5], const uint8_t buffer[64])$/;"	f	file:
TransformFunction	lib/sha256.c	/^static	void	TransformFunction(Sha256Context *Context, uint8_t *Buffer)$/;"	f	file:
TransformFunction	lib/sha512.c	/^static	void	TransformFunction(Sha512Context *Context, uint8_t *Buffer)$/;"	f	file:
Type	json11/json11.hpp	/^    enum Type {$/;"	g	class:json11::final
Type	libstar/ssmtp.h	/^	int             Type;			\/\/ MIME type $/;"	m	struct:__anon100
TypeOfService	libstar/xicmp.h	/^	uchar		TypeOfService;		\/\/ Type of service$/;"	m	struct:__anon131
UDPSTAT_CONNECTED	libstar/snmpdef.h	435;"	d
UDPSTAT_IDLE	libstar/snmpdef.h	434;"	d
UDPSTAT_MAX	libstar/snmpdef.h	437;"	d
UDPSTAT_UNBOUND	libstar/snmpdef.h	433;"	d
UDPSTAT_UNKNOWN	libstar/snmpdef.h	436;"	d
UDP_HEADER_SIZE	libstar/netbios.c	68;"	d	file:
USE_FAST_HASH	libstar/fhash.c	29;"	d	file:
USE_FAST_HASH	libstar/hash.c	41;"	d	file:
USE_FAST_HASH	libstar/shash.c	31;"	d	file:
USE_FAST_HASH	libstar/vhash.c	40;"	d	file:
USE_NETSCALER_L4	libstar/snmpdef.h	18;"	d
Unlock	libstar/xlist.h	/^	void	Unlock()				{ xlist_lock(m_xl); }$/;"	f	class:CXList
User	libstar/ssmtp.h	/^	char            User[MAX_ARG_LEN];	\/\/ Auth username $/;"	m	struct:__anon101
V1_MAXFLOWS	libstar/nflowlib.h	550;"	d
V5_MAXFLOWS	libstar/nflowlib.h	551;"	d
V7_MAXFLOWS	libstar/nflowlib.h	552;"	d
V8_10_MAXFLOWS	libstar/nflowlib.h	270;"	d
V8_10_MAXFLOWS	libstar/nflowlib.h	562;"	d
V8_11_MAXFLOWS	libstar/nflowlib.h	271;"	d
V8_11_MAXFLOWS	libstar/nflowlib.h	563;"	d
V8_12_MAXFLOWS	libstar/nflowlib.h	272;"	d
V8_12_MAXFLOWS	libstar/nflowlib.h	564;"	d
V8_13_MAXFLOWS	libstar/nflowlib.h	273;"	d
V8_13_MAXFLOWS	libstar/nflowlib.h	565;"	d
V8_14_MAXFLOWS	libstar/nflowlib.h	274;"	d
V8_14_MAXFLOWS	libstar/nflowlib.h	566;"	d
V8_1_MAXFLOWS	libstar/nflowlib.h	261;"	d
V8_1_MAXFLOWS	libstar/nflowlib.h	553;"	d
V8_2_MAXFLOWS	libstar/nflowlib.h	262;"	d
V8_2_MAXFLOWS	libstar/nflowlib.h	554;"	d
V8_3_MAXFLOWS	libstar/nflowlib.h	263;"	d
V8_3_MAXFLOWS	libstar/nflowlib.h	555;"	d
V8_4_MAXFLOWS	libstar/nflowlib.h	264;"	d
V8_4_MAXFLOWS	libstar/nflowlib.h	556;"	d
V8_5_MAXFLOWS	libstar/nflowlib.h	265;"	d
V8_5_MAXFLOWS	libstar/nflowlib.h	557;"	d
V8_6_MAXFLOWS	libstar/nflowlib.h	266;"	d
V8_6_MAXFLOWS	libstar/nflowlib.h	558;"	d
V8_7_MAXFLOWS	libstar/nflowlib.h	267;"	d
V8_7_MAXFLOWS	libstar/nflowlib.h	559;"	d
V8_8_MAXFLOWS	libstar/nflowlib.h	268;"	d
V8_8_MAXFLOWS	libstar/nflowlib.h	560;"	d
V8_9_MAXFLOWS	libstar/nflowlib.h	269;"	d
V8_9_MAXFLOWS	libstar/nflowlib.h	561;"	d
VERB_DO	libstar/xtn.c	/^	VERB_DO   = 253,$/;"	e	enum:__anon174	file:
VERB_DONT	libstar/xtn.c	/^	VERB_DONT = 254$/;"	e	enum:__anon174	file:
VERB_SB	libstar/xtn.c	/^	VERB_SB   = 250,$/;"	e	enum:__anon174	file:
VERB_WILL	libstar/xtn.c	/^	VERB_WILL = 251,$/;"	e	enum:__anon174	file:
VERB_WONT	libstar/xtn.c	/^	VERB_WONT = 252,$/;"	e	enum:__anon174	file:
VHASH_ALLOC	libstar/vhash.c	32;"	d	file:
VHASH_ALLOC	libstar/vhash.c	35;"	d	file:
VHASH_DEBUG	libstar/vhash.c	29;"	d	file:
VHASH_FREE	libstar/vhash.c	33;"	d	file:
VHASH_FREE	libstar/vhash.c	36;"	d	file:
VHASH_FUNC	libstar/vhash.c	44;"	d	file:
VHASH_FUNC	libstar/vhash.c	46;"	d	file:
VM_MAX_ADDR	hvm.c	13;"	d	file:
VSTR	libstar/xdebug.h	37;"	d
VSTR	libstar/xstr.h	31;"	d
VT	libstar/xtn.c	186;"	d	file:
VTHREAD	libstar/type.h	216;"	d
VTHREAD	libstar/type.h	218;"	d
Value	json11/json11.cpp	/^    explicit Value(T &&value)      : m_value(move(value)) {}$/;"	f	class:json11::Value
Value	json11/json11.cpp	/^    explicit Value(const T &value) : m_value(value) {}$/;"	f	class:json11::Value
Value	json11/json11.cpp	/^class Value : public JsonValue {$/;"	c	namespace:json11	file:
Version	libstar/xicmp.h	/^	uchar		Version:4;		\/\/ Version of IP$/;"	m	struct:__anon131
WILL	libstar/xtn.c	200;"	d	file:
WINSproxy	libstar/xsock.h	/^	int		WINSproxy;$/;"	m	struct:__anon166
WO	libstar/aria.c	146;"	d	file:
WONT	libstar/xtn.c	201;"	d	file:
WORM_ERR	libstar/worm.h	/^	WORM_ERR		= -1,$/;"	e	enum:__anon107
WORM_ERR_EXIST	libstar/worm.h	/^	WORM_ERR_EXIST,$/;"	e	enum:__anon107
WORM_ERR_FILE_OPEN	libstar/worm.h	/^	WORM_ERR_FILE_OPEN,$/;"	e	enum:__anon107
WORM_ERR_INVALID_CHAR	libstar/worm.h	/^	WORM_ERR_INVALID_CHAR,$/;"	e	enum:__anon107
WORM_ERR_MARK	libstar/worm.h	/^	WORM_ERR_MARK,$/;"	e	enum:__anon107
WORM_ERR_MEMORY_ALLOC	libstar/worm.h	/^	WORM_ERR_MEMORY_ALLOC,$/;"	e	enum:__anon107
WORM_ERR_NOT_FILE	libstar/worm.h	/^	WORM_ERR_NOT_FILE,$/;"	e	enum:__anon107
WORM_ERR_NOT_FOLDER	libstar/worm.h	/^	WORM_ERR_NOT_FOLDER,$/;"	e	enum:__anon107
WORM_ERR_NOT_FOUND	libstar/worm.h	/^	WORM_ERR_NOT_FOUND,$/;"	e	enum:__anon107
WORM_ERR_OVERWRITE	libstar/worm.h	/^	WORM_ERR_OVERWRITE,$/;"	e	enum:__anon107
WORM_ERR_PERM	libstar/worm.h	/^	WORM_ERR_PERM,$/;"	e	enum:__anon107
WORM_ERR_QUOTA_OVER	libstar/worm.h	/^	WORM_ERR_QUOTA_OVER,$/;"	e	enum:__anon107
WORM_ERR_READ_FAIL	libstar/worm.h	/^	WORM_ERR_READ_FAIL,$/;"	e	enum:__anon107
WORM_ERR_RECV_FAIL	libstar/worm.h	/^	WORM_ERR_RECV_FAIL,$/;"	e	enum:__anon107
WORM_ERR_SEND_FAIL	libstar/worm.h	/^	WORM_ERR_SEND_FAIL	= -100,$/;"	e	enum:__anon107
WORM_ERR_UNKNOWN_TYPE	libstar/worm.h	/^	WORM_ERR_UNKNOWN_TYPE,$/;"	e	enum:__anon107
WORM_ERR_WRITE_FAIL	libstar/worm.h	/^	WORM_ERR_WRITE_FAIL,$/;"	e	enum:__anon107
WORM_MARK	libstar/worm.h	24;"	d
WORM_OK	libstar/worm.h	/^	WORM_OK			= 0,$/;"	e	enum:__anon107
WORM_VERSION	libstar/worm.h	23;"	d
WordLoad	libstar/aria.c	157;"	d	file:
WordLoad	libstar/aria.c	171;"	d	file:
WordLoad	libstar/aria.c	172;"	d	file:
WordM1	libstar/aria.c	238;"	d	file:
WordM1	libstar/aria.c	243;"	d	file:
X1	libstar/aria.c	/^const uint X1[256] = {$/;"	v
X2	libstar/aria.c	/^const uint X2[256] = {$/;"	v
X86_64	libstar/osconfig.h	18;"	d
XCRON_ALWAYS	libstar/xtime.h	136;"	d
XFLOW_TYPE_NETFLOW	libstar/xflowlib.h	/^	XFLOW_TYPE_NETFLOW	= 1,$/;"	e	enum:__anon127
XFLOW_TYPE_SFLOW	libstar/xflowlib.h	/^	XFLOW_TYPE_SFLOW	= 2,$/;"	e	enum:__anon127
XID_CACHE_SIZE	libstar/snoop.h	72;"	d
XLIST_MAX_DATA_SIZE	libstar/xlist.h	20;"	d
XTN_MAX_CMD	libstar/xtn.h	19;"	d
XTN_TYPE_CMD	libstar/xtn.h	/^	XTN_TYPE_CMD	= 0,$/;"	e	enum:__anon179
XTN_TYPE_RESULT	libstar/xtn.h	/^	XTN_TYPE_RESULT,$/;"	e	enum:__anon179
_AAA	libstar/aria.c	55;"	d	file:
_ALLOC	libstar/xstr.h	40;"	d
_BBB	libstar/aria.c	56;"	d	file:
_CCC	libstar/aria.c	57;"	d	file:
_DDD	libstar/aria.c	58;"	d	file:
_DRIVE_INFO	libstar/oddlibwin.c	/^}	_DRIVE_INFO;$/;"	t	typeref:struct:__anon65	file:
_FreeASPI32Buffer	libstar/dvdlib.c	/^static FREEASPI32BUFFER _FreeASPI32Buffer = NULL;$/;"	v	file:
_FreeASPI32Buffer	libstar/oddlibwin.c	/^static FREEASPI32BUFFER _FreeASPI32Buffer = NULL;$/;"	v	file:
_GNU_SOURCE	libstar/proflib.c	25;"	d	file:
_GetASPI32Buffer	libstar/dvdlib.c	/^static GETASPI32BUFFER _GetASPI32Buffer = NULL;$/;"	v	file:
_GetASPI32Buffer	libstar/oddlibwin.c	/^static GETASPI32BUFFER _GetASPI32Buffer = NULL;$/;"	v	file:
_GetASPI32SupportInfo	libstar/dvdlib.c	/^static GETASPI32SUPPORTINFO _GetASPI32SupportInfo = NULL;$/;"	v	file:
_GetASPI32SupportInfo	libstar/oddlibwin.c	/^static GETASPI32SUPPORTINFO _GetASPI32SupportInfo = NULL;$/;"	v	file:
_NETBIOS_H	libstar/netbios.h	11;"	d
_SFLAddress	libstar/sflowlib.h	/^typedef struct _SFLAddress$/;"	s
_SFLAddress_value	libstar/sflowlib.h	/^typedef union _SFLAddress_value$/;"	u
_SFLCounters_sample	libstar/sflowlib.h	/^typedef struct _SFLCounters_sample$/;"	s
_SFLCounters_sample_element	libstar/sflowlib.h	/^typedef struct _SFLCounters_sample_element$/;"	s
_SFLCounters_sample_expanded	libstar/sflowlib.h	/^typedef struct _SFLCounters_sample_expanded$/;"	s
_SFLCounters_type	libstar/sflowlib.h	/^typedef union _SFLCounters_type$/;"	u
_SFLEthernet_counters	libstar/sflowlib.h	/^typedef struct _SFLEthernet_counters$/;"	s
_SFLExtended_as_path_segment	libstar/sflowlib.h	/^typedef struct _SFLExtended_as_path_segment$/;"	s
_SFLExtended_gateway	libstar/sflowlib.h	/^typedef struct _SFLExtended_gateway$/;"	s
_SFLExtended_mpls	libstar/sflowlib.h	/^typedef struct _SFLExtended_mpls$/;"	s
_SFLExtended_mpls_FTN	libstar/sflowlib.h	/^typedef struct _SFLExtended_mpls_FTN$/;"	s
_SFLExtended_mpls_LDP_FEC	libstar/sflowlib.h	/^typedef struct _SFLExtended_mpls_LDP_FEC$/;"	s
_SFLExtended_mpls_tunnel	libstar/sflowlib.h	/^typedef struct _SFLExtended_mpls_tunnel$/;"	s
_SFLExtended_mpls_vc	libstar/sflowlib.h	/^typedef struct _SFLExtended_mpls_vc$/;"	s
_SFLExtended_nat	libstar/sflowlib.h	/^typedef struct _SFLExtended_nat$/;"	s
_SFLExtended_process	libstar/sflowlib.h	/^typedef struct _SFLExtended_process$/;"	s
_SFLExtended_router	libstar/sflowlib.h	/^typedef struct _SFLExtended_router$/;"	s
_SFLExtended_switch	libstar/sflowlib.h	/^typedef struct _SFLExtended_switch$/;"	s
_SFLExtended_url	libstar/sflowlib.h	/^typedef struct _SFLExtended_url$/;"	s
_SFLExtended_user	libstar/sflowlib.h	/^typedef struct _SFLExtended_user$/;"	s
_SFLExtended_vlan_tunnel	libstar/sflowlib.h	/^typedef struct _SFLExtended_vlan_tunnel$/;"	s
_SFLFlow_sample	libstar/sflowlib.h	/^typedef struct _SFLFlow_sample$/;"	s
_SFLFlow_sample_element	libstar/sflowlib.h	/^typedef struct _SFLFlow_sample_element$/;"	s
_SFLFlow_sample_expanded	libstar/sflowlib.h	/^typedef struct _SFLFlow_sample_expanded$/;"	s
_SFLFlow_type	libstar/sflowlib.h	/^typedef union _SFLFlow_type$/;"	u
_SFLIf_counters	libstar/sflowlib.h	/^typedef struct _SFLIf_counters$/;"	s
_SFLLabelStack	libstar/sflowlib.h	/^typedef struct _SFLLabelStack$/;"	s
_SFLProcess	libstar/sflowlib.h	/^typedef struct _SFLProcess$/;"	s
_SFLProcessor_counters	libstar/sflowlib.h	/^typedef struct _SFLProcessor_counters$/;"	s
_SFLSample_datagram_hdr	libstar/sflowlib.h	/^typedef struct _SFLSample_datagram_hdr$/;"	s
_SFLSampled_ethernet	libstar/sflowlib.h	/^typedef struct _SFLSampled_ethernet$/;"	s
_SFLSampled_header	libstar/sflowlib.h	/^typedef struct _SFLSampled_header$/;"	s
_SFLSampled_ipv4	libstar/sflowlib.h	/^typedef struct _SFLSampled_ipv4$/;"	s
_SFLSampled_ipv6	libstar/sflowlib.h	/^typedef struct _SFLSampled_ipv6$/;"	s
_SFLString	libstar/sflowlib.h	/^typedef struct _SFLString$/;"	s
_SFLTokenring_counters	libstar/sflowlib.h	/^typedef struct _SFLTokenring_counters$/;"	s
_SFLVg_counters	libstar/sflowlib.h	/^typedef struct _SFLVg_counters$/;"	s
_SFLVlan_counters	libstar/sflowlib.h	/^typedef struct _SFLVlan_counters$/;"	s
_SFSample	libstar/sflowlib.h	/^typedef struct _SFSample$/;"	s
_SNOOP_H	libstar/snoop.h	11;"	d
_SendASPI32Command	libstar/dvdlib.c	/^static SENDASPI32COMMAND _SendASPI32Command = NULL;$/;"	v	file:
_SendASPI32Command	libstar/oddlibwin.c	/^static SENDASPI32COMMAND _SendASPI32Command = NULL;$/;"	v	file:
_TranslateASPI32Address	libstar/dvdlib.c	/^static TRANSLATEASPI32ADDRESS _TranslateASPI32Address = NULL;$/;"	v	file:
_TranslateASPI32Address	libstar/oddlibwin.c	/^static TRANSLATEASPI32ADDRESS _TranslateASPI32Address = NULL;$/;"	v	file:
_XTIME_T	libstar/xtime.h	38;"	d
_XX	libstar/aria.c	59;"	d	file:
__ARIA_H	libstar/aria.h	11;"	d
__ARRAY_H	libstar/array.h	12;"	d
__BIG_ENDIAN	libstar/type.h	101;"	d
__BIG_ENDIAN	libstar/type.h	192;"	d
__BIG_ENDIAN	libstar/type.h	37;"	d
__BIG_ENDIAN	libstar/type.h	85;"	d
__CONTRACT_H__	contract.h	6;"	d
__DVDLIB_H	libstar/dvdlib.h	2;"	d
__FAVOR_BSD	libstar/xpcap.h	47;"	d
__FAVOR_BSD	libstar/xpcap.h	49;"	d
__FHASH_H	libstar/fhash.h	18;"	d
__GW_H	libstar/gw.h	17;"	d
__HDACLIB_H__	hdaclib.h	5;"	d
__IDEA_H	libstar/idea.h	12;"	d
__INADDRSZ	libstar/xsock.c	1612;"	d	file:
__IO64_H	libstar/io64.h	9;"	d
__JSON2_H__	json2.h	5;"	d
__JSON2_H__	myjson/json2.h	5;"	d
__JSON_H__	myjson/json.h	6;"	d
__LIBHASH_H__	lib/libhash.h	6;"	d
__LIBHASH_H__	libhash.h	6;"	d
__LIBSTAR_H	libstar/libstar.h	12;"	d
__LITTLE_ENDIAN	libstar/snoop.h	28;"	d
__LITTLE_ENDIAN	libstar/type.h	129;"	d
__LITTLE_ENDIAN	libstar/type.h	169;"	d
__LJM_HASH_H	libstar/hash.h	29;"	d
__LOCK_H	libstar/lock.h	16;"	d
__LOGLIB_H	libstar/loglib.h	12;"	d
__NFLOWLIB_H	libstar/nflowlib.h	12;"	d
__NODE_H__	node.h	5;"	d
__OCILIB_H	libstar/ocilib.h	18;"	d
__ODDLIB_H	libstar/oddlib.h	2;"	d
__OSCONFIG_H	libstar/osconfig.h	2;"	d
__RE_H	libstar/re.h	12;"	d
__RPCCMD_H__	rpc.h	6;"	d
__SFLOWLIB_H	libstar/sflowlib.h	8;"	d
__SHASH_H	libstar/shash.h	19;"	d
__SHMEM_H	libstar/shmem.h	11;"	d
__SMIME_H	libstar/smime.h	14;"	d
__SMSLIB_H	libstar/smslib.h	18;"	d
__SNMPDEF_H	libstar/snmpdef.h	12;"	d
__SSMTP_H	libstar/ssmtp.h	14;"	d
__THRPOOL_H	libstar/thrpool.h	12;"	d
__TYPE_H	libstar/type.h	12;"	d
__UDP_H	libstar/udp.h	14;"	d
__USE_LARGEFILE64	libstar/io64.h	15;"	d
__VHASH_H	libstar/vhash.h	21;"	d
__WORM_H	libstar/worm.h	16;"	d
__XAPP_H	libstar/xapp.h	12;"	d
__XDB_H	libstar/xdb.h	12;"	d
__XDEBUG_H	libstar/xdebug.h	12;"	d
__XFLOWLIB_H	libstar/xflowlib.h	12;"	d
__XHASH_H	libstar/xhash.h	15;"	d
__XICMP_H	libstar/xicmp.h	18;"	d
__XINDEX_H	libstar/xindex.h	12;"	d
__XLIST_H	libstar/xlist.h	12;"	d
__XLOCK_H	libstar/xlock.h	12;"	d
__XNMS_H	libstar/xnms.h	17;"	d
__XPCAP_H	libstar/xpcap.h	16;"	d
__XPING_H	libstar/xping.h	25;"	d
__XQUEUE_H	libstar/xqueue.h	12;"	d
__XSNMP_H	libstar/xsnmp.h	12;"	d
__XSOCK_H	libstar/xsock.h	12;"	d
__XSSL_H	libstar/xssl.h	12;"	d
__XSTR_H	libstar/xstr.h	12;"	d
__XTIME_H	libstar/xtime.h	12;"	d
__XTN_H	libstar/xtn.h	12;"	d
__XUTIL_H	libstar/xutil.h	12;"	d
__min	lib/test_rc4.c	18;"	d	file:
__sess_max	libstar/snmpdef.h	/^	uint		__sess_max;		\/\/ $/;"	m	struct:__anon96
__unused	libstar/sflowlib.h	/^      uint16_t	__unused;$/;"	m	struct:icmphdr::__anon67::__anon69
_actmon	libstar/xdebug.c	/^actmon_t	_actmon[100] = {0};$/;"	v
_agenttype	libstar/xdebug.c	/^char	_agenttype[100] = {0};$/;"	v
_allochash	libstar/xdebug.c	/^static	shash_t	*_allochash = NULL;$/;"	v	file:
_ansi_state	libstar/xtn.c	/^enum _ansi_state$/;"	g	file:
_aspibuf	libstar/dvdlib.c	/^static BYTE	*_aspibuf = NULL;$/;"	v	file:
_assettxid	test.c	/^static	char	_assettxid[128] = {0};$/;"	v	file:
_cfghash	hvm.c	/^vhash_t	*_cfghash = NULL;$/;"	v
_cmdwaitms	libstar/xutil.c	/^static	uint	_cmdwaitms = 2000;$/;"	v	file:
_deflog	libstar/xdebug.c	/^static	logdata_t	_deflog = {NULL, "srderr", "", 0, 0, LOG_OPT_PRINT_DATETIME};$/;"	v	file:
_delayms	libstar/oddlibwin.c	/^int		_delayms = 0;		\/\/ 10ms delay$/;"	v
_drive_list	libstar/dvdlib.c	/^dvddrvinfo_t	_drive_list[MAX_DVD_DRIVE] = {0};$/;"	v
_dvd_init	libstar/dvdlib.c	/^static BOOL	_dvd_init = FALSE;$/;"	v	file:
_dvddrvi	libstar/dvdlib.c	/^static dvddrv_t _dvddrvi[MAX_DVD_DRIVE] = {0};$/;"	v	file:
_dvdinfo	libstar/dvdlib.c	/^dvdinfo_t	_dvdinfo = {0};$/;"	v
_dvdname	libstar/oddlibwin.c	/^char		*_dvdname = "";$/;"	v
_enable_fileno_count	libstar/xdebug.c	/^int	_enable_fileno_count = 0;$/;"	v
_enable_sockno_count	libstar/xdebug.c	/^int	_enable_sockno_count = 0;$/;"	v
_entnum	libstar/xsnmptype.c	/^char		**_entnum = NULL;$/;"	v
_exitdaemon	libstar/xdebug.c	/^int	_exitdaemon = 0;		\/\/ 1이면 모든 thread 종료..$/;"	v
_filehash	libstar/loglib.c	/^static	vhash_t		*_filehash = NULL;$/;"	v	file:
_filenohash	libstar/xdebug.c	/^shash_t		*_filenohash = NULL;$/;"	v
_firstfailtime	libstar/loglib.c	/^static	time_t		_firstfailtime = 0;		\/\/ 마지막 실패 시간 (5분 경과시 보내지 않음)$/;"	v	file:
_fromaddr	test.c	/^static	char	_fromaddr[128] = {0};$/;"	v	file:
_hdac	hvm.c	/^hdac_t	*_hdac = NULL;$/;"	v
_hdac_debug	hdaclib.c	/^const	char	*_hdac_debug = "";	\/\/"cmd;result";	\/\/ cmd;result;json$/;"	v
_hdac_error_code	hdaclib.c	/^int	_hdac_error_code = 0;$/;"	v
_hdac_error_msg	hdaclib.c	/^char	_hdac_error_msg[512] = {0};$/;"	v
_homedir	libstar/xdebug.c	/^char	_homedir[200] = {0};$/;"	v
_hostiplist	libstar/xsock.c	/^char	_hostiplist[MAX_XIFINFO][20] = {0};$/;"	v
_hostmaclist	libstar/xsock.c	/^char	_hostmaclist[MAX_XIFINFO][20] = {0};		\/\/ 최대 50개 IF 지원..$/;"	v
_jsonbuf	myjson/json.c	/^static	char	*_jsonbuf = NULL;	\/\/ \\0 terminated string list$/;"	v	file:
_list	myjson/json.c	/^static	json_t	*_list = NULL;$/;"	v	file:
_little_endian	libstar/aria.c	/^static	int	_little_endian = -1;$/;"	v	file:
_lockdata	libstar/xlock.c	/^static	lockdata_t	*_lockdata = NULL;$/;"	v	file:
_logbuf	libstar/xdebug.c	/^static	char	_xlogfile[200] = {0}, *_logbuf = NULL;$/;"	v	file:
_logfilehash	libstar/xdebug.c	/^static	shash_t		*_logfilehash = NULL;$/;"	v	file:
_logfilename	libstar/xdebug.c	/^char		*_logfilename = NULL;$/;"	v
_logfuncname	libstar/xdebug.c	/^char		*_logfuncname = NULL;$/;"	v
_loglineno	libstar/xdebug.c	/^int		_loglineno = 0;$/;"	v
_loglock	libstar/xdebug.c	/^xlock_t		_loglock = {0};$/;"	v
_logopt_clear_comment	libstar/xstr.c	/^static	int	_logopt_clear_comment = 1;$/;"	v	file:
_logoutfp	libstar/loglib.c	/^static	FILE		*_logoutfp = NULL;$/;"	v	file:
_logsize	libstar/xdebug.c	/^static	uint	_logsize = 10 * 1024 * 1024;$/;"	v	file:
_maxdvd	libstar/dvdlib.c	/^static int	_maxdvd = 0;$/;"	v	file:
_mem_debug_itv	libstar/xdebug.c	/^int	_mem_debug_itv = 0;		\/\/ >0이면 지정된 시간 주기로 메모리 덤프 $/;"	v
_metatxid	test.c	/^static	char	_metatxid[128] = {0};$/;"	v	file:
_mtx	myjson/json.c	/^static	pthread_mutex_t	_mtx = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
_mtx	myjson/json2.c	/^static	pthread_mutex_t	_mtx = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
_name_addr_map_created	name_map.c	/^static	bool	_name_addr_map_created = false;$/;"	v	file:
_nlist	myjson/json.c	/^static	int	_nlist = 0;$/;"	v	file:
_nms_data_hash	libstar/xsnmptype.c	/^vhash_t		*_nms_data_hash = NULL;$/;"	v
_nms_oid_map_hash	libstar/xsnmptype.c	/^vhash_t		*_nms_oid_map_hash = NULL;$/;"	v
_nprivoid	libstar/xsnmptype.c	/^int		_nprivoid = 0;$/;"	v
_nsyslog_rule	libstar/syslog.c	/^int			_nsyslog_rule = 0;$/;"	v
_ntokens	myjson/json.c	/^static	int	_ntokens = 0;$/;"	v	file:
_ntrap_rule	libstar/syslog.c	/^int			_ntrap_rule = 0;$/;"	v
_numlockdata	libstar/xlock.c	/^static	int		_numlockdata = 0;$/;"	v	file:
_numthread	libstar/xutil.c	/^static	int	_numthread = 0;$/;"	v	file:
_nvmthr	hvm.c	/^int	_nvmthr = 0;$/;"	v
_nwa	libstar/oddlibwin.c	/^int		_nwa = 0;$/;"	v
_nxdebugfilter	libstar/xdebug.c	/^int	_nxdebugfilter = 0;$/;"	v
_nxdebugopt	libstar/xdebug.c	/^int	_nxdebugopt = 0;$/;"	v
_nxlongoption	libstar/xdebug.c	/^int	_nxlongoption = 0;$/;"	v
_oddidx	libstar/oddlibwin.c	/^int		_oddidx = 0;		\/\/ 드라이브 인덱스$/;"	v
_oddq	libstar/oddlibwin.c	/^static	xlist_t	*_oddq = NULL;$/;"	v	file:
_option	libstar/xtn.c	/^}	_option;$/;"	t	typeref:enum:__anon176	file:
_outfp	myjson/test.c	/^FILE	*_outfp = NULL;$/;"	v
_ping_simul_hash	libstar/xping.c	/^vhash_t	*_ping_simul_hash = NULL;$/;"	v
_pop3timeout	libstar/pop3.c	/^static	int	_pop3timeout = 10;$/;"	v	file:
_privoid	libstar/xsnmptype.c	/^privoid_t	*_privoid = NULL;$/;"	v
_sa	libstar/xtn.c	/^static	int	_sa = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;$/;"	v	file:
_selfdelay	libstar/xtime.c	/^static	double	_selfdelay = 0.0;$/;"	v	file:
_send_limit_created	hdaclib.c	/^static	bool	_send_limit_created = false;$/;"	v	file:
_smtptimeout	libstar/smtp.c	/^static	int	_smtptimeout = 20;$/;"	v	file:
_sock_timeoutMS	libstar/xsock.c	/^static	int	_sock_timeoutMS = 20000;$/;"	v	file:
_sockfd	libstar/smslib.c	/^static	int	_sockfd = -1;$/;"	v	file:
_socknohash	libstar/xdebug.c	/^shash_t		*_socknohash = NULL;$/;"	v
_startaddr	libstar/oddlibwin.c	/^int		_startaddr = 0;		\/\/REC_START_LBA;	\/\/ 0x10000;	(0~0x10000은 데이터가 들어감)$/;"	v
_state	libstar/xtn.c	/^}	_state;$/;"	t	typeref:enum:__anon175	file:
_syslog_port	libstar/syslog.c	/^static	int	_syslog_port = 514;$/;"	v	file:
_syslog_rule	libstar/syslog.c	/^trap_syslog_filter_t	_syslog_rule[MAX_SYSLOG_FILTER] = {0};$/;"	v
_toaddr	test.c	/^static	char	_toaddr[128] = {0};$/;"	v	file:
_toaddr2	test.c	/^static	char	_toaddr2[128] = {0};$/;"	v	file:
_tokens	myjson/json.c	/^static	char	**_tokens = NULL;$/;"	v	file:
_totalalloc	libstar/xdebug.c	/^uint	_totalalloc = 0;$/;"	v
_totalalloccount	libstar/xdebug.c	/^uint	_totalalloccount = 0;$/;"	v
_totalfreecount	libstar/xdebug.c	/^uint	_totalfreecount = 0;$/;"	v
_trap_rule	libstar/syslog.c	/^trap_syslog_filter_t	_trap_rule[MAX_TRAP_FILTER] = {0};$/;"	v
_trapcallback	libstar/xsnmptrap.c	/^static	trap_callback_t	*_trapcallback = NULL;$/;"	v	file:
_ttyfd	libstar/xstr.c	/^static	int	_ttyfd = -1;$/;"	v	file:
_txid	test.c	/^static	char	_txid[128] = {0};$/;"	v	file:
_verb	libstar/xtn.c	/^}	_verb;$/;"	t	typeref:enum:__anon174	file:
_vmthr	hvm.c	/^vmthr_t	_vmthr[VM_MAX_ADDR] = {0};$/;"	v
_xalarmq	libstar/xtime.c	/^vhash_t		*_xalarmq = NULL;$/;"	v
_xdb	libstar/xdb.c	/^xdb_t		_xdb = {0};$/;"	v
_xdb2	libstar/xdb.c	/^xdb_t		_xdb2 = {0};	\/\/ 세션을 2개 만들어서 비상시는 2번째 세션으로 시도..$/;"	v
_xdebugfilter	libstar/xdebug.c	/^char	*_xdebugfilter[255] = {NULL};	\/\/ 필터링 조건 (내용이 있으면 해당 내용과 매칭되는 것만 출력)$/;"	v
_xdebuglev	libstar/xdebug.c	/^int	_xdebuglev[255] = {0};		\/\/ 각 리소스별 디버깅을 위해 설정 가능 $/;"	v
_xdebuglock	libstar/xdebug.c	/^xlock_t	_xdebuglock = {0};$/;"	v
_xdebugopt	libstar/xdebug.c	/^char	*_xdebugopt[255] = {NULL};	\/\/ 각 리소스별 디버깅을 위해 설정 가능 $/;"	v
_xfilename	libstar/xdebug.c	/^char   *_xfilename = NULL;$/;"	v
_xlevel	libstar/xdebug.c	/^int	_xlevel = 0;$/;"	v
_xlineno	libstar/xdebug.c	/^int	_xlineno = 0;$/;"	v
_xlocaltimer	libstar/xtime.c	/^time32		_xlocaltimer = 0;$/;"	v
_xlock_check	libstar/xlock.c	/^static	int		_xlock_check = 0;$/;"	v	file:
_xlogfile	libstar/xdebug.c	/^static	char	_xlogfile[200] = {0}, *_logbuf = NULL;$/;"	v	file:
_xlogfp	libstar/xdebug.c	/^static	FILE	*_xlogfp = NULL;$/;"	v	file:
_xlogfunc	libstar/xdebug.c	/^static	void	(*_xlogfunc) (char *buf) = NULL;$/;"	v	file:
_xlongoption	libstar/xdebug.c	/^char	*_xlongoption[100][2] = {NULL};	\/\/ 긴 옵션 문자열 (name, value)$/;"	v
_xmonhash	libstar/xdebug.c	/^vhash_t		*_xmonhash = NULL;$/;"	v
_xontimehash	libstar/xtime.c	/^vhash_t		*_xontimehash = NULL;$/;"	v
_xoption	libstar/xdebug.c	/^int	_xoption[255] = {0};		\/\/ 각 파트별 디버깅을 위해 설정 가능 $/;"	v
_xoptionstr	libstar/xdebug.c	/^char	*_xoptionstr[255] = {NULL};	\/\/ 각 파트별 디버깅을 위해 설정 가능 $/;"	v
_xprintdate	libstar/xdebug.c	/^int	_xprintdate = 1;		\/\/ 0="출력안함" 1="MM-DD HH:II:SS" 2="YYYY-MM-DD HH:II:SS" 3="HH:II:SS.ms"$/;"	v
_xprinterr	libstar/xdebug.c	/^int	_xprinterr = 0;$/;"	v
_xprof	libstar/xtime.c	/^xprof_t		_xprof[1000] = {0};		\/\/ 코드의 수행시간 측정용 $/;"	v
_xprof_enable	libstar/xtime.c	/^static	int	_xprof_enable = 1;$/;"	v	file:
_xprof_gettimeofday_delay_ns	libstar/xtime.c	/^static	uint	_xprof_gettimeofday_delay_ns = 0;$/;"	v	file:
_xprofclk	libstar/xtime.c	/^static	xprofclk_t	_xprofclk[MAX_XPROF] = {0};$/;"	v	file:
_xrealprint	libstar/xdebug.c	/^int	_xrealprint = 1;$/;"	v
_xsigcount	libstar/xdebug.c	/^uint	_xsigcount[256] = {0};$/;"	v
_xsigfile	libstar/xdebug.c	/^char	*_xsigfile = (char *)"";$/;"	v
_xsiglineno	libstar/xdebug.c	/^int	_xsiglineno = 0;$/;"	v
_xsigstr	libstar/xdebug.c	/^char	*_xsigstr = (char *)"";$/;"	v
_xsock_open_check_numthr	libstar/xsock.c	/^static	int	_xsock_open_check_numthr = 0;$/;"	v	file:
_xsock_timeout	libstar/xsock.c	/^static	xsock_t	_xsock_timeout[100] = {0};$/;"	v	file:
_xthr_hash	libstar/xutil.c	/^vhash_t		*_xthr_hash = NULL;	\/\/ Key="함수명" Data=생성된 thread 수$/;"	v
_xtimediff	libstar/xtime.c	/^int		_xtimediff = 0;$/;"	v
_xtimer	libstar/xtime.c	/^time32		_xtimer = 0;$/;"	v
a	lib/md5.h	/^    uint32_t     a;$/;"	m	struct:__anon16
abcd	libstar/md5.h	/^    md5_word_t abcd[4];		\/* digest buffer *\/$/;"	m	struct:md5_state_s
abort	contract.c	/^int	hdac_contract::abort()$/;"	f	class:hdac_contract
abort_contract	contract.c	/^int	hdac_admin::abort_contract(const char *stream)$/;"	f	class:hdac_admin
accept_running	libstar/gw.h	/^	uint	accept_running;		\/\/ Client를 accept 하는 thread 동작중이면 1$/;"	m	struct:gwinfo
acceptsock	libstar/gw.h	/^	int	acceptsock;		\/\/ Client accept용 socket $/;"	m	struct:gwrule
ack	libstar/xpcap.h	/^	uint		seq, ack;$/;"	m	struct:__anon153
activeOpens	libstar/snmpdef.h	/^	uint	activeOpens;		\/\/ TCP 접속이 Closed 상태에서 SYN-SENT 상태로의$/;"	m	struct:__anon84
active_conn	libstar/snmpdef.h	/^	uint		active_conn;		\/\/ The number requests in the surge queue. Gauge32(66 - gauge32)$/;"	m	struct:__anon96
actmon_check	libstar/xdebug.c	/^int	actmon_check(int limit)$/;"	f
actmon_t	libstar/xdebug.h	/^}	actmon_t;$/;"	t	typeref:struct:__anon124
adapter	libstar/xsock.h	/^	char		adapter[100];$/;"	m	struct:__anon166
adapter_address	libstar/netbios.c	/^	uchar		adapter_address[6];$/;"	m	struct:__anon49	file:
add	myjson/json2.c	/^json& json::add(const jsonnode node)$/;"	f	class:json
add	myjson/json2.c	/^json& json::add(json js)$/;"	f	class:json
add_tail	myjson/json.h	/^	json_t *add_tail(json_t *node, json_t *sub)$/;"	f	class:json
addedgenode	myjson/json.c	/^static	json_t	*addedgenode(int type, const char *value, int depth)$/;"	f	file:
additional_record_count	libstar/netbios.c	/^	ushort		additional_record_count;$/;"	m	struct:__anon47	file:
additional_record_count	libstar/netbios.c	/^	ushort		additional_record_count;$/;"	m	struct:__anon48	file:
addmultisigaddress	rpc.h	/^	string addmultisigaddress(const int nrequired, const char *keys, const char *account = "")$/;"	f	class:hdac
addnode	myjson/json.c	/^static	json_t	*addnode(int type, json_t *tailp, int depth)$/;"	f	file:
addnode	rpc.h	/^	string addnode(const char *node, const char *op)$/;"	f	class:hdac
addr	hdaclib.h	/^	char	addr[HDAC_ADDR_LEN];$/;"	m	struct:__anon6
addr	hvm.c	/^	char	addr[40];$/;"	m	struct:__anon11	file:
addr	libstar/xicmp.h	/^	uint		addr;			\/\/ 수신시 주소가 정확하지 못하므로 데이터 부분에 넣어서 보내자...$/;"	m	struct:__anon133
addr	libstar/xicmp.h	/^	uint		addr;			\/\/ 수신시 주소가 정확하지 못하므로 데이터 부분에 넣어서 보내자...$/;"	m	struct:__anon134
addr	libstar/xnms.h	/^	uint		addr;$/;"	m	struct:xnmsnode
addr	libstar/xsnmp.h	/^	uint		addr;$/;"	m	struct:__anon158
addr	libstar/xsnmpif.c	/^	uint	addr;			\/\/ nodeip$/;"	m	struct:__anon164	file:
addr	libstar/xtn.h	/^	uint		addr;$/;"	m	struct:xtn
addr	node.h	/^	char	addr[HDAC_ADDR_LEN];$/;"	m	struct:__anon14
addr2str	libstar/xstr.c	/^char	*addr2str(uint addr, char *buf)$/;"	f
address	libstar/sflowlib.h	/^	SFLAddress_value address;$/;"	m	struct:_SFLAddress
addrhash	libstar/xping.h	/^	hash_t		*addrhash;		\/\/ IP -> 응답시간 매핑$/;"	m	struct:xping
addrlist	libstar/xicmp.h	/^	uint		*addrlist;		\/\/ Multi-ping시 파라미터 전달용...$/;"	m	struct:__anon136
addtail	myjson/json.c	/^static	json_t	*addtail(json_t *head, json_t *tail)$/;"	f	file:
adj_speed	libstar/snmpsub.c	/^static	float	adj_speed(snmpif_t *ifp, float interval)$/;"	f	file:
admin	contract.h	/^	char	admin[HDAC_ADDR_LEN];		\/\/ admin address$/;"	m	struct:__anon1
adminstatus	libstar/snmpdef.h	/^	int	adminstatus;		\/\/ 1=running 2=down$/;"	m	struct:__anon78
adminstatus	libstar/xnms.h	/^	int		adminstatus;$/;"	m	struct:__anon150
adminstatusName	libstar/xsnmpif.c	/^char	*adminstatusName(int status, char *buf)$/;"	f
age	libstar/snmpdef.h	/^	int	age;			\/\/ sec's since last update of route	{ipRouteEntry 10} RW $/;"	m	struct:__anon82
agentSubId	libstar/sflowlib.h	/^	uint            agentSubId;$/;"	m	struct:_SFSample
agent_addr	libstar/sflowlib.h	/^	SFLAddress      agent_addr;$/;"	m	struct:_SFSample
agent_address	libstar/sflowlib.h	/^	SFLAddress      agent_address;	\/* IP address of sampling agent *\/$/;"	m	struct:_SFLSample_datagram_hdr
agentip	libstar/xnms.h	/^	char		agentip[20];		\/\/ 어느 Agent에서 검색을 했는지 $/;"	m	struct:__anon147
agentip	libstar/xnms.h	/^	char		agentip[20];		\/\/ 어느 Agent에서 검색을 했는지 $/;"	m	struct:__anon148
agentip	libstar/xsnmp.h	/^	char	agentip[20];		\/\/ 어느 Agent에서 검색을 했는지$/;"	m	struct:__anon161
agg_method	libstar/nflowlib.h	/^	uint8		agg_method;	\/\/ aggregation method$/;"	m	struct:__anon60
agg_version	libstar/nflowlib.h	/^	uint8		agg_version;	\/\/ Version of the aggregation export=2$/;"	m	struct:__anon60
alerton	libstar/xnms.h	/^	int		alerton;		\/\/ 1이면 각종 이벤트 발생시킴 $/;"	m	struct:xnmsnode
aliasname	libstar/snmpdef.h	/^	char	aliasname[32];		\/\/ 이 노드의 별칭 $/;"	m	struct:__anon76
allocated	libstar/hash.h	/^	int		allocated;	\/\/ data를 hash_savedata()로 저장한 경우 1$/;"	m	struct:hashentry
allocated	libstar/vhash.h	/^	uchar		allocated;	\/\/ data를 vhash_savedata()로 저장한 경우 1$/;"	m	struct:vhashentry
allocated	libstar/xlist.h	/^	int		allocated;	\/\/ data가 debug_malloc()에 의해 할당되었으면 1$/;"	m	struct:xlistnode
allocinfo_t	libstar/xdebug.c	/^}	allocinfo_t;$/;"	t	typeref:struct:__anon121	file:
allocsize	libstar/array.h	/^	int		allocsize;		\/\/ 데이터 블록 할당 크기 (이 단위로 블록들 추가됨)$/;"	m	struct:__anon27
allocsize	libstar/fhash.h	/^	uint		allocsize;$/;"	m	struct:__anon35
allocsize	libstar/hash.h	/^	uint		allocsize;$/;"	m	struct:__anon41
allocsize	libstar/shash.h	/^	uint		allocsize;$/;"	m	struct:__anon71
allocsize	libstar/vhash.h	/^	uint		allocsize;		\/\/ 현재 hash table에서 allocation된 총량 $/;"	m	struct:__anon105
amount	contract.h	/^	double	amount;				\/\/ amount$/;"	m	struct:__anon1
amount	hdaclib.h	/^	char	amount[32];$/;"	m	struct:__anon3
amount	node.h	/^	double	amount;$/;"	m	struct:__anon14
ansi	libstar/xtn.c	/^void ansi(SOCKET server,unsigned char data)$/;"	f
ansi_erase_line	libstar/xtn.c	/^void ansi_erase_line(char* buffer)$/;"	f
ansi_erase_screen	libstar/xtn.c	/^void ansi_erase_screen(char* buffer)$/;"	f
ansi_move_up	libstar/xtn.c	/^void ansi_move_up(char* buffer)$/;"	f
ansi_set_position	libstar/xtn.c	/^void ansi_set_position(char* buffer)$/;"	f
ansi_set_screen_attribute	libstar/xtn.c	/^void ansi_set_screen_attribute(char* buffer)$/;"	f
answer_count	libstar/netbios.c	/^	ushort		answer_count;$/;"	m	struct:__anon47	file:
answer_count	libstar/netbios.c	/^	ushort		answer_count;$/;"	m	struct:__anon48	file:
apc_t	libstar/snmpdef.h	/^}	apc_t;$/;"	t	typeref:struct:__anon97
appendfile	libstar/xutil.c	/^int	appendfile(const char *fname, void *buf, int buflen)$/;"	f
appendrawexchange	rpc.h	/^	string appendrawexchange(const char *hex, const char *txid, const int vout, const char *ask_assets)$/;"	f	class:hdac
approvefrom	rpc.h	/^	string approvefrom(const char *from_addr, const char *upgrade_id, const bool approve)$/;"	f	class:hdac
arg	libstar/proflib.c	/^	void           *arg;$/;"	m	struct:wrapper_s	file:
aria_crypt	libstar/aria.c	/^int	aria_crypt(void *orginbuf, int len, void *orgoutbuf, char *passwd, int keysize, int decoding)$/;"	f
aria_crypt_overwrite	libstar/aria.c	/^int	aria_crypt_overwrite(void *iobuf, int len, char *passwd, int keysize, int decoding)$/;"	f
arp	libstar/xpcap.h	/^	struct ether_arp *arp;			\/\/ ARP packet pointer$/;"	m	struct:__anon153	typeref:struct:__anon153::ether_arp
arplen	libstar/xpcap.h	/^	int		arplen;$/;"	m	struct:__anon153
array	json11/json11.hpp	/^    typedef std::vector<Json> array;$/;"	t	class:json11::final
array_add	libstar/array.c	/^char	*array_add(register array_t *ap, register char *instp, int instsize, int *ret_idx)$/;"	f
array_addtail	libstar/array.c	/^char	*array_addtail(register array_t *ap, register char *instp, int instsize, int *ret_idx)$/;"	f
array_clear	libstar/array.c	/^char	*array_clear(register array_t *ap, int nth)$/;"	f
array_delete	libstar/array.c	/^void	array_delete(register array_t *ap, int nth)$/;"	f
array_deleteall	libstar/array.c	/^void	array_deleteall(register array_t *ap)$/;"	f
array_find	libstar/array.c	/^int	array_find(register array_t *ap, register char *instp, int cmpsize)$/;"	f
array_find_empty	libstar/array.c	/^int	array_find_empty(register array_t *ap)$/;"	f
array_find_last_empty	libstar/array.c	/^int	array_find_last_empty(register array_t *ap)$/;"	f
array_free	libstar/array.h	43;"	d
array_get	libstar/array.c	/^char	*array_get(register array_t *ap, int nth)$/;"	f
array_get_empty	libstar/array.c	/^char	*array_get_empty(register array_t *ap)$/;"	f
array_get_last_empty	libstar/array.c	/^char	*array_get_last_empty(register array_t *ap)$/;"	f
array_getsize	libstar/array.c	/^int	array_getsize(register array_t *ap)$/;"	f
array_init	libstar/array.c	/^array_t	*array_init(int allocsize, int instsize, char *opt)$/;"	f
array_insert	libstar/array.c	/^char	*array_insert(register array_t *ap, int nth, char *instp, int instsize)$/;"	f
array_items	json11/json11.cpp	/^const vector<Json> &      JsonValue::array_items()               const { return statics().empty_vector; }$/;"	f	class:json11::JsonValue
array_items	json11/json11.cpp	/^const vector<Json> & Json::array_items()          const { return m_ptr->array_items();  }$/;"	f	class:json11::Json
array_lock	libstar/array.c	/^void	array_lock(array_t *ap)$/;"	f
array_numitem	libstar/array.c	/^int	array_numitem(register array_t *ap)$/;"	f
array_pop	libstar/array.c	/^void	array_pop(register array_t *ap)$/;"	f
array_push	libstar/array.c	/^char	*array_push(register array_t *ap, char *instp, int instsize, int *ret_idx)$/;"	f
array_resize	libstar/array.c	/^array_t	*array_resize(register array_t *ap)$/;"	f
array_set	libstar/array.c	/^char	*array_set(register array_t *ap, int nth, char *instp, int instsize)$/;"	f
array_shift	libstar/array.c	/^char	*array_shift(register array_t *ap)$/;"	f
array_t	libstar/array.h	/^}	array_t;$/;"	t	typeref:struct:__anon27
array_unlock	libstar/array.c	/^void	array_unlock(array_t *ap)$/;"	f
as	libstar/sflowlib.h	/^	as;$/;"	m	struct:_SFLExtended_as_path_segment	typeref:union:_SFLExtended_as_path_segment::__anon70
as	libstar/sflowlib.h	/^	uint            as;	\/* AS number for this gateway *\/$/;"	m	struct:_SFLExtended_gateway
as_esc	libstar/xtn.c	/^	as_esc,$/;"	e	enum:_ansi_state	file:
as_esc1	libstar/xtn.c	/^	as_esc1$/;"	e	enum:_ansi_state	file:
as_normal	libstar/xtn.c	/^	as_normal,$/;"	e	enum:_ansi_state	file:
ascii_name	libstar/netbios.c	/^	char		ascii_name[16];$/;"	m	struct:__anon46	file:
askfor	libstar/xtn.c	/^inline void askfor (SOCKET server, _verb verb,_option option)$/;"	f
asset_amount	hdaclib.h	/^	char	asset_amount[32];$/;"	m	struct:__anon3
asset_name	hdaclib.h	/^	char	asset_name[128];		\/\/ IN optional$/;"	m	struct:__anon10
asset_name	hdaclib.h	/^	char	asset_name[128];$/;"	m	struct:__anon3
async_cond	libstar/thrpool.h	/^	pthread_cond_t	async_cond;		\/\/ Non-Windows 시그널용..$/;"	m	struct:thrpool
async_lock	libstar/thrpool.h	/^	pthread_mutex_t	async_lock;		\/\/ xlock_t on Windows$/;"	m	struct:thrpool
attemptFails	libstar/snmpdef.h	/^	uint	attemptFails;		\/\/ TCP 접속이 SYN-SENT 상태 또는 SYN-RCVD 상태에서 $/;"	m	struct:__anon84
auth	libstar/xnms.h	/^	xnmsauth_t	auth;			\/\/ 장비 로그인시 인증 정보 $/;"	m	struct:xnmsnode
autoconfig	libstar/xsock.h	/^	int		autoconfig;$/;"	m	struct:__anon166
autoreadcmd	libstar/xutil.c	/^_ALLOC	char	*autoreadcmd(const char *cmd, int *retbytes, int *reterrbytes, int readerr)$/;"	f
autoreadcmdv	libstar/xutil.c	/^_ALLOC	char	**autoreadcmdv(const char *cmd, int *nline, int *nerrline, int readerr)$/;"	f
autoreadfile	libstar/xutil.c	/^_ALLOC	void	*autoreadfile(const char *fname, int *retbytes)$/;"	f
autoreadfilev	libstar/xutil.c	/^_ALLOC	char	**autoreadfilev(const char *fname, int *nline)$/;"	f
avg_svr_ttfb	libstar/snmpdef.h	/^	uint		avg_svr_ttfb;		\/\/ Gauge32(66 - gauge32)$/;"	m	struct:__anon96
avg_tx_time	libstar/snmpdef.h	/^	float		avg_tx_time;		\/\/ Average transaction time between netscaler and the service behind it. TimeTicks(67 - timeticks)$/;"	m	struct:__anon96
avgiflistday	libstar/xnms.h	/^	snmpif_t	*curiflistday, *oldiflistday, *miniflistday, *maxiflistday, *avgiflistday;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
avgiflisthour	libstar/xnms.h	/^	snmpif_t	*curiflisthour, *oldiflisthour, *miniflisthour, *maxiflisthour, *avgiflisthour;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
b	lib/md5.h	/^    uint32_t     b;$/;"	m	struct:__anon16
b58digits_map	lib/base58.c	/^static const int8_t b58digits_map[] = {$/;"	v	file:
b58digits_ordered	lib/base58.c	/^static const char b58digits_ordered[] = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";$/;"	v	file:
bAspiBufInited	libstar/oddlibwin.c	/^static BOOL     bAspiBufInited = FALSE;$/;"	v	file:
bDvdRecInit	libstar/oddlibwin.c	/^static BOOL     bDvdRecInit = FALSE;$/;"	v	file:
backupwallet	rpc.h	/^	string backupwallet(const char *dest)$/;"	f	class:hdac
bandwidthmbps	libstar/snmpdef.h	/^	float	bandwidthmbps;		\/\/ 실제 라인의 대역폭 $/;"	m	struct:__anon78
base58_check	lib/base58.c	/^int	base58_check(const void *bin, size_t binsz, const char *base58str, size_t b58sz)$/;"	f
base58_check_encode	lib/base58.c	/^bool	base58_check_encode(char *b58c, size_t *b58c_sz, uint8_t ver, const void *data, size_t datasz)$/;"	f
base58_decode	lib/base58.c	/^bool base58_decode(void *bin, size_t *binszp, const char *b58, size_t b58sz)$/;"	f
base58_encode	lib/base58.c	/^bool	base58_encode(char *b58, size_t *b58sz, const void *data, size_t binsz)$/;"	f
baseid	libstar/xicmp.h	/^	int		baseid;			\/\/ ID를 위한 기본 값$/;"	m	struct:__anon136
bcc	libstar/ssmtplib.h	/^	char		*bcc[256];$/;"	m	struct:__anon103
bgp_nextHop	libstar/sflowlib.h	/^	SFLAddress      bgp_nextHop;$/;"	m	struct:_SFSample
bin2hex	lib/libhash.c	/^char	*bin2hex(char *hexbuf, const void *binbuf, const size_t binbuflen)$/;"	f
bin2hexstr	libstar/xdb.c	/^char	*bin2hexstr(void *data, int size)$/;"	f
binmode	libstar/xapp.h	/^	int		binmode;$/;"	m	struct:__anon113
bkpltype	libstar/xnms.h	/^	char		bkpltype[40];		\/\/ .2 Backplane type$/;"	m	struct:__anon147
blk	lib/sha1.c	33;"	d	file:
blk0	lib/sha1.c	30;"	d	file:
block	lib/md5.h	/^    uint32_t     block[16];$/;"	m	struct:__anon16
block	libstar/xflowlib.h	/^	char	block[MAX_FLOW_PACKET_SIZE];$/;"	m	struct:__anon128
blocksize	libstar/xflowlib.h	/^	int	blocksize;$/;"	m	struct:__anon128
bomb	libstar/xnms.h	/^	char		*bomb;$/;"	m	struct:__anon151
bool_t	libstar/snoop.h	/^typedef int		bool_t;$/;"	t
bool_value	json11/json11.cpp	/^bool                      JsonValue::bool_value()                const { return false; }$/;"	f	class:json11::JsonValue
bool_value	json11/json11.cpp	/^bool Json::bool_value()                           const { return m_ptr->bool_value();   }$/;"	f	class:json11::Json
boolean_t	libstar/type.h	/^typedef unsigned char		boolean_t;$/;"	t
bps	libstar/xflowlib.h	/^	int		bps;		\/\/ 초당 처리한 byte 수$/;"	m	struct:__anon130
bridgeport	libstar/xsnmp.h	/^	int	bridgeport;$/;"	m	struct:__anon160
bridgeport	libstar/xsnmp.h	/^	int	bridgeport;$/;"	m	struct:__anon161
broadcast	libstar/snmpdef.h	/^	int	broadcast;$/;"	m	struct:__anon80
broadcast	libstar/xsock.h	/^	char		broadcast[20];$/;"	m	struct:__anon166
broadcastPkts	libstar/sflowlib.h	/^	uint            broadcastPkts;$/;"	m	struct:_SFLVlan_counters
buf	lib/sha256.h	/^    uint8_t     buf[64];$/;"	m	struct:__anon22
buf	lib/sha512.h	/^    uint8_t     buf[128];$/;"	m	struct:__anon24
buf	libstar/md5.h	/^    md5_byte_t buf[64];		\/* accumulate block *\/$/;"	m	struct:md5_state_s
buf	libstar/worm.h	/^	char		buf[64];$/;"	m	struct:__anon110
buf	libstar/xsock.h	/^	char		*buf;		\/\/ NF용 $/;"	m	struct:xsocket
buffer	lib/md5.h	/^    uint8_t      buffer[64];$/;"	m	struct:__anon16
buffer_t	libstar/xstr.h	/^}	buffer_t;$/;"	t	typeref:struct:__anon168
buffering	libstar/ocilib.h	/^	int		buffering;	\/* cached buffering flag. 0 - off, 1 - on, 2 - on and buffer was used *\/ $/;"	m	struct:__anon62
bytes	lib/md5.h	/^    uint8_t      bytes [MD5_HASH_SIZE];$/;"	m	struct:__anon17
bytes	lib/sha1.h	/^    uint8_t      bytes [SHA1_HASH_SIZE];$/;"	m	struct:__anon21
bytes	lib/sha256.h	/^    uint8_t      bytes [SHA256_HASH_SIZE];$/;"	m	struct:__anon23
bytes	lib/sha512.h	/^    uint8_t      bytes [SHA512_HASH_SIZE];$/;"	m	struct:__anon25
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ number of bytes$/;"	m	struct:struct_export_v8_1
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ number of bytes$/;"	m	struct:struct_export_v8_2
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ number of bytes$/;"	m	struct:struct_export_v8_3
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ number of bytes$/;"	m	struct:struct_export_v8_4
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ number of bytes$/;"	m	struct:struct_export_v8_5
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ octets sent in duration$/;"	m	struct:__anon53
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ octets sent in duration$/;"	m	struct:__anon55
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ octets sent in duration$/;"	m	struct:__anon57
bytes	libstar/nflowlib.h	/^	uint32		bytes;		\/\/ octets sent in duration$/;"	m	struct:__anon59
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_10
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_11
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_12
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_13
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_14
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_6
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_7
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_8
bytes	libstar/nflowlib.h	/^	uint32       bytes;	\/* Octets sent in duration *\/$/;"	m	struct:struct_export_v8_9
bytes	libstar/xflowlib.h	/^	uint32		bytes;$/;"	m	struct:__anon129
bytes_high32	libstar/snmpdef.h	/^	uint		bytes_high32;$/;"	m	struct:__anon96
bytes_low32	libstar/snmpdef.h	/^	uint		bytes_low32;$/;"	m	struct:__anon96
c	lib/md5.h	/^    uint32_t     c;$/;"	m	struct:__anon16
c	lib/sha1.c	/^    uint8_t     c [64];$/;"	m	union:__anon19	file:
c	libstar/nflowlib.h	/^	struct template_cache_entry *c[TEMPLATE_CACHE_ENTRIES];$/;"	m	struct:template_cache	typeref:struct:template_cache::template_cache_entry
c1printf	libstar/xdebug.h	128;"	d
c2printf	libstar/xdebug.h	127;"	d
c3printf	libstar/xdebug.h	126;"	d
c4printf	libstar/xdebug.h	125;"	d
c5printf	libstar/xdebug.h	124;"	d
c_test	myjson/test.c	/^void	c_test()$/;"	f
cache_struct	libstar/snoop.h	/^struct cache_struct {$/;"	s
calcsize	myjson/json2.c	/^void json::calcsize()$/;"	f	class:json
calcstat	libstar/xnms.c	/^static	void	calcstat(xnmsnode_t *xn)$/;"	f	file:
call	libstar/xtime.h	/^	uint		call;$/;"	m	struct:__anon173
callback	hdaclib.h	/^	void	*callback;	\/\/ RPC Callback function $/;"	m	struct:__anon9
callback	libstar/gw.h	/^	void	(*callback) (xsock_t *sock, int event, char *buf, int buflen);$/;"	m	struct:gwinfo
callback	libstar/smslib.c	/^	char	callback[11];		\/\/ 메시지 회신번호(호출자)$/;"	m	struct:__anon74	file:
callback	libstar/thrpool.h	/^	void		(*callback) (struct thrdata *thrdata, void *userdata);$/;"	m	struct:thrdata
callback	libstar/xflowlib.h	/^	void (*callback) (struct xflow *xfp, xflow_rawdata_t *rawp, int nthentry);$/;"	m	struct:xflow
callback	libstar/xnms.h	/^	void		(*callback) (int type, int term, struct xnmsnode *xn);$/;"	m	struct:xnmsnode
callback	libstar/xpcap.h	/^	xpcapcbf_t	callback;		\/\/ callback 함수 $/;"	m	struct:__anon153
callback	libstar/xping.h	/^	void		(*callback) (int evtype, struct xping *xp, uint addr, int responseUS);$/;"	m	struct:xping
callback	libstar/xsock.h	/^	void		(*callback) (struct xsocket *sock, int event, char *buf, int buflen);$/;"	m	struct:xsocket
callback	libstar/xtn.h	/^	void (*callback) (struct xtn *tnp, int type, char *buf);$/;"	m	struct:xtn
callbackfunc	libstar/xdebug.h	/^	void	(*callbackfunc) (char *buf);	\/\/ Callback function$/;"	m	struct:__anon126
caller	libstar/smslib.c	/^	char	caller[10];		\/\/ 메시지 작성자이름(실제 전송되지 않습니다.)$/;"	m	struct:__anon74	file:
callno	libstar/smslib.c	/^	char	callno[11];		\/\/ 메시지 수신번호$/;"	m	struct:__anon74	file:
callno	libstar/smslib.c	/^	char	callno[11];		\/\/ 메시지 수신번호$/;"	m	struct:__anon75	file:
caplen	libstar/xpcap.h	/^	int		caplen;			\/\/ 실제 캡쳐된 패킷 크기 (snaplen에서 명시된 크기를 넘지 못함)$/;"	m	struct:__anon153
caplen	libstar/xpcap.h	/^	uint		caplen;			\/\/ 캡쳐된 패킷의 크기 $/;"	m	struct:__anon152
cb_retlen	libstar/ocilib.h	/^	ub4		cb_retlen;	\/* *\/   $/;"	m	struct:__anon61
cc	libstar/ssmtplib.h	/^	char		*cc[256];$/;"	m	struct:__anon103
cfgbuf	libstar/xnms.h	/^	char		*cfgbuf;		\/\/ 결과 문자열 $/;"	m	struct:xnmsnode
cfgterm	libstar/xnms.h	/^	int		cfgterm;		\/\/ Configuration 정보 수집 주기$/;"	m	struct:xnmsnode
cfgthrid	libstar/xnms.h	/^	int		cfgthrid;			\/\/ Thread ID$/;"	m	struct:__anon149
cflag	libstar/re.h	/^	int		cflag;$/;"	m	struct:__anon66
charset	libstar/ocilib.h	/^	ub2		charset;	\/* charset ID *\/$/;"	m	struct:ociconn
check	contract.c	/^int	hdac_contract::check()$/;"	f	class:hdac_contract
check	libstar/sflowlib.h	/^    uint16_t check;$/;"	m	struct:iphdr
check_file_result	myjson/test.c	/^int	check_file_result(const char *func, const int num)$/;"	f
check_itv	libstar/loglib.h	/^	int		check_itv;$/;"	m	struct:logparam
check_result	myjson/test.c	/^int	check_result(const char *func, const char *result, const int pass)$/;"	f
checked	libstar/xdebug.c	/^	int		checked;$/;"	m	struct:__anon120	file:
checksum	libstar/sflowlib.h	/^  uint16_t checksum;$/;"	m	struct:icmphdr
chksum	hdaclib.h	/^	char	chksum[100];$/;"	m	struct:__anon5
cipher_idea	libstar/idea.c	/^static void cipher_idea(word16 in[4], word16 out[4], register const IDEAkey Z)$/;"	f	file:
cisco_chassis_t	libstar/snmpdef.h	/^}	cisco_chassis_t;$/;"	t	typeref:struct:__anon88
cisco_module_t	libstar/snmpdef.h	/^}	cisco_module_t;$/;"	t	typeref:struct:__anon89
cisco_port_t	libstar/snmpdef.h	/^}	cisco_port_t;$/;"	t	typeref:struct:__anon90
cleanup	myjson/json.h	/^	void cleanup()$/;"	f	class:json
clear	json2.h	/^	void	clear()$/;"	f	class:tokeninfo
clear	myjson/json2.c	/^void json::clear()$/;"	f	class:json
clear	myjson/json2.h	/^	void	clear()$/;"	f	class:tokeninfo
clearmempool	rpc.h	/^	string clearmempool()$/;"	f	class:hdac
clearoption	libstar/xdebug.c	/^int	clearoption(char *opt)$/;"	f
cleartime	libstar/vhash.h	/^	time_t		cleartime;		\/\/ 전체 삭제한 시간 $/;"	m	struct:__anon105
clock	libstar/xtime.c	/^	double		clock;$/;"	m	struct:__anon170	file:
close	contract.h	/^	void	close()$/;"	f	class:hdac_admin
close	contract.h	/^	void	close()$/;"	f	class:hdac_contract
close	node.h	/^	void	close()$/;"	f	class:hdac_node
close	node.h	/^	void	close()$/;"	f	class:hdac_virtual_device
close_contract	contract.c	/^int	hdac_admin::close_contract(const hdac_map_t *map)$/;"	f	class:hdac_admin
close_same_session	libstar/gw.h	/^	uint	close_same_session;	\/\/ 1이면 동일 주소, port에서 접속시 소켓 닫고 새 연결 사용 $/;"	m	struct:gwrule
closetime	libstar/xdebug.c	/^	time32		closetime;$/;"	m	struct:__anon120	file:
cmd	libstar/xtn.c	/^	unsigned char cmd;$/;"	m	struct:codec_st	file:
cmd	rpc.h	/^	string cmd(const char *data)$/;"	f	class:hdac
cmdjson	hdaclib.h	/^	char	*cmdjson;	\/\/ response JSON$/;"	m	struct:__anon9
cmp	myjson/json2.c	/^bool json::cmp(const json& cmpjson)$/;"	f	class:json
cmpf	libstar/hash.h	/^	int		(*cmpf)(const void *, const void *, size_t);$/;"	m	struct:__anon41
cmpsize	libstar/fhash.h	/^	int		cmpsize;		\/\/ 비교 엔트리 수 $/;"	m	struct:__anon35
cmpsize	libstar/shash.h	/^	int		cmpsize;		\/\/ 비교 엔트리 수 $/;"	m	struct:__anon71
cmpsize	libstar/vhash.h	/^	int		cmpsize;		\/\/ 최대 선형 검색 회수 (1 page unit)$/;"	m	struct:__anon105
code	libstar/sflowlib.h	/^  uint8_t code;		\/* type sub-code *\/$/;"	m	struct:icmphdr
codebuf	libstar/xtn.c	/^char codebuf[256] = {0};$/;"	v
codec	libstar/xtn.c	/^} codec[NUM_CODEC] = {$/;"	v	typeref:struct:codec_st
codec_st	libstar/xtn.c	/^struct codec_st$/;"	s	file:
codeptr	libstar/xtn.c	/^unsigned char codeptr;$/;"	v
col	libstar/xdb.h	/^	int		col;$/;"	m	struct:__anon115
coldata	libstar/xdb.h	/^	char		*coldata;	\/\/ 각 컬럼의 데이터가 '\\0'로 구분되어 들어가 있음. 마지막은 '\\0\\0' 임..$/;"	m	struct:__anon117
coldata	libstar/xdb.h	/^	char		*coldata[MAX_DB_COL];	\/\/ 각 컬럼의 문자 데이터 $/;"	m	struct:__anon116
colhash	libstar/ocilib.h	/^	vhash_t		*colhash;	\/* hash containing all the result columns *\/$/;"	m	struct:ocistmt
collect	libstar/xnms.c	/^static	int	collect(xnms_t *xnms, xnmsnode_t *xn)$/;"	f	file:
collect_snmp	libstar/xnms.c	/^static	int	collect_snmp(xnms_t *xnms, xnmsnode_t *xn, xsnmp_t *xs)$/;"	f	file:
collectifnum	libstar/xnms.h	/^	int		collectifnum;		\/\/ 정보를 입수해야 하는 IF의 수 $/;"	m	struct:xnmsnode
colsize	libstar/xdb.h	/^	int		colsize;	\/\/ 현재 컬럼의 크기 $/;"	m	struct:__anon117
colsize	libstar/xdb.h	/^	int		colsize[MAX_DB_COL];	\/\/ 컬럼의 크기 $/;"	m	struct:__anon116
combineunspent	rpc.h	/^	string combineunspent(const char *addr, const int minconf = 1, const int maxcombines = 100, const int mininputs = 2, const int maxinputs = 100, const int maxtime = 15)$/;"	f	class:hdac
comhwver	libstar/xnms.h	/^	char		comhwver[20];		\/\/ .4$/;"	m	struct:__anon146
comindex	libstar/xnms.h	/^	int		comindex;		\/\/ 1.3.6.1.4.1.9.5.1.2.18.1.1$/;"	m	struct:__anon146
comlist	libstar/xnms.h	/^	nmschassiscom_t	comlist[1];		\/\/ Component list (64개 어레이)$/;"	m	struct:__anon147
command	libstar/sflowlib.h	/^	SFLString       command;$/;"	m	struct:_SFLProcess
command	libstar/snmpdef.h	/^	char		command[32];$/;"	m	struct:__anon85
command	libstar/snmpdef.h	/^	char	command[32];		\/\/ 사용 프로그램명$/;"	m	struct:__anon92
command	libstar/snmpdef.h	/^	char	command[32];$/;"	m	struct:__anon87
comment	hdaclib.h	/^	char	*comment;		\/\/ comment (allocated)$/;"	m	struct:__anon7
comment	hdaclib.h	/^	char	*comment;$/;"	m	struct:__anon6
comment_hash	hdaclib.h	/^	char	comment_hash[128];$/;"	m	struct:__anon6
comment_hash	hdaclib.h	/^	char	comment_hash[128];$/;"	m	struct:__anon7
commodel	libstar/xnms.h	/^	char		commodel[20];		\/\/ .5$/;"	m	struct:__anon146
communities	libstar/sflowlib.h	/^	uint           *communities;	\/* set of communities *\/$/;"	m	struct:_SFLExtended_gateway
communities	libstar/sflowlib.h	/^	uint           *communities;$/;"	m	struct:_SFSample
communities_len	libstar/sflowlib.h	/^	uint            communities_len;$/;"	m	struct:_SFSample
communities_length	libstar/sflowlib.h	/^	uint            communities_length;	\/* number of communities *\/$/;"	m	struct:_SFLExtended_gateway
community	libstar/snmpdef.h	/^	char	community[40];		\/\/ 이 I\/F의 별칭 $/;"	m	struct:__anon78
community	libstar/xnms.h	/^	char		community[64];$/;"	m	struct:xnmsnode
community	libstar/xsnmp.h	/^	char		community[64];$/;"	m	struct:__anon158
completerawexchange	rpc.h	/^	string completerawexchange(const char *hex, const char *txid, const int vout, const char *ask_assets, const char *data = "")$/;"	f	class:hdac
comserial	libstar/xnms.h	/^	char		comserial[20];		\/\/ .3$/;"	m	struct:__anon146
comtype	libstar/xnms.h	/^	char		comtype[40];		\/\/ .2$/;"	m	struct:__anon146
cond	libstar/thrpool.h	/^	pthread_cond_t	cond;		\/\/ Non-Windows 시그널용..$/;"	m	struct:thrdata
cond	libstar/xlock.h	/^	pthread_cond_t	cond;$/;"	m	struct:__anon141
conffile	libstar/lock.h	/^	char		conffile[200];		\/\/ config file path$/;"	m	struct:__anon44
conffile	libstar/loglib.h	/^	char		conffile[200];$/;"	m	struct:logparam
connection	libstar/http.c	/^	char	connection[30];	\/\/ close \/ Keep-Alive... $/;"	m	struct:__anon43	file:
connhash	libstar/gw.h	/^	hash_t	*connhash;		\/\/ Client 접속 리스트용 hash (접속된 모든 clients)$/;"	m	struct:gwinfo
connhash	libstar/gw.h	/^	hash_t	*connhash;		\/\/ Client 접속 리스트용 hash. 해당 포트에 연결된 것만 (gwinfo.connhash와 중복 처리됨)$/;"	m	struct:gwrule
connp	libstar/ocilib.h	/^	ociconn_t	*connp;		\/* parent connection handle *\/$/;"	m	struct:__anon62
connp	libstar/ocilib.h	/^	ociconn_t	*connp;		\/* parent connection handle *\/$/;"	m	struct:ocistmt
consume_comment	json11/json11.cpp	/^    bool consume_comment() {$/;"	f	struct:json11::__anon15::final
consume_garbage	json11/json11.cpp	/^    void consume_garbage() {$/;"	f	struct:json11::__anon15::final
consume_whitespace	json11/json11.cpp	/^    void consume_whitespace() {$/;"	f	struct:json11::__anon15::final
contact	libstar/snmpdef.h	/^	char	contact[64];$/;"	m	struct:__anon76
contents	hdaclib.h	/^	void	*contents;$/;"	m	struct:__anon6
contents_hash	hdaclib.h	/^	char	contents_hash[128];$/;"	m	struct:__anon6
contents_hash	hdaclib.h	/^	char	contents_hash[128];$/;"	m	struct:__anon7
contents_len	hdaclib.h	/^	size_t	contents_len;$/;"	m	struct:__anon6
conv	libstar/loglib.h	/^	char		conv[40];	\/\/ conv=파일 변환 $/;"	m	struct:__anon45
convfunc	libstar/loglib.h	/^	int		(*convfunc) (struct logparam *param, char *path, char *newpath, const char *state);$/;"	m	struct:logparam
copy	myjson/json.h	/^	json_t *copy(const json_t *src, int ncopy = 999999, int opt = 0)$/;"	f	class:json
copyright_fail	libstar/xdebug.c	/^int 	copyright_fail()$/;"	f
count	libstar/md5.h	/^    md5_word_t count[2];	\/* message length in bits, lsw first *\/$/;"	m	struct:md5_state_s
count	libstar/nflowlib.h	/^	uint16		count;		\/\/  number of flow entries$/;"	m	struct:__anon52
count	libstar/nflowlib.h	/^	uint16		count;		\/\/  number of flow entries$/;"	m	struct:__anon54
count	libstar/nflowlib.h	/^	uint16		count;		\/\/  number of flow entries$/;"	m	struct:__anon58
count	libstar/nflowlib.h	/^	uint16		count;		\/\/ number of flow entries$/;"	m	struct:__anon60
count	libstar/nflowlib.h	/^	uint16		count;		\/\/ the number of records in PDU$/;"	m	struct:__anon56
count	libstar/xdebug.c	/^	int	count;			\/\/ 최종 할당 카운트 $/;"	m	struct:__anon121	file:
count	libstar/xdebug.h	/^	int		count;$/;"	m	struct:__anon122
count	libstar/xlist.h	/^	int		count;		\/\/ 노드 수$/;"	m	struct:xlist
count	libstar/xlock.h	/^	int		count;		\/\/ 0==free, >0 locked$/;"	m	struct:__anon140
count	libstar/xlock.h	/^	int		count;		\/\/ 0==free, >0 locked$/;"	m	struct:__anon141
counterBlock	libstar/sflowlib.h	/^	SFLCounters_type counterBlock;$/;"	m	struct:_SFLCounters_sample_element
counterBlockVersion	libstar/sflowlib.h	/^	uint            counterBlockVersion;$/;"	m	struct:_SFSample
cpp_test	myjson/test.c	/^void	cpp_test()$/;"	f
cpp_test	myjson/test2.c	/^void	cpp_test()$/;"	f
cprintf	libstar/xdebug.h	129;"	d
cprintf	libstar/xstr.c	1677;"	d	file:
cprintf	libstar/xtn.c	12;"	d	file:
create	rpc.h	/^	string create(const char *entity_type, const char *entity_name, const bool open, const char *custom_fields = "")$/;"	f	class:hdac
create_thread	libstar/xutil.h	69;"	d
createfrom	rpc.h	/^	string createfrom(const char *from_addr, const char *entity_type, const char *entity_name, const bool open, const char *custom_fields)$/;"	f	class:hdac
createkeypairs	rpc.h	/^	string createkeypairs(const int count = 1)$/;"	f	class:hdac
createmultisig	rpc.h	/^	string createmultisig(const int nrequired, const char *keys)$/;"	f	class:hdac
createrawexchange	rpc.h	/^	string createrawexchange(const char *txid, const int vout, const char *ask_assets)$/;"	f	class:hdac
createrawsendfrom	rpc.h	/^	string createrawsendfrom(const char *from_addr, const char *json_data, const char *data = "", const char *action = "")$/;"	f	class:hdac
crtime	libstar/udp.h	/^	time32	crtime;			\/\/ socket 생성 시각 $/;"	m	struct:__anon104
crtime	libstar/xsock.h	/^	time32		crtime;		\/\/ socket 생성 시각 $/;"	m	struct:xsocket
crypt_md5_aria	libstar/lock.c	/^int	crypt_md5_aria(char *inbuf, int inbufsz, char *outbuf, int outbufsz, int iscrypt)$/;"	f
cryptoff	libstar/xsock.h	/^	int		cryptoff;	\/\/ 암호화된 소켓이 아니면 1$/;"	m	struct:xsocket
cstypename	libstar/xnms.h	/^	char		cstypename[40];		\/\/ .1 chassis type$/;"	m	struct:__anon147
cur_client_conn	libstar/snmpdef.h	/^	uint		cur_client_conn;	\/\/ Gauge32(66 - gauge32)$/;"	m	struct:__anon96
cur_conn64	libstar/snmpdef.h	/^	uint64		cur_conn64;		\/\/ 현재 세션 누적 $/;"	m	struct:__anon96
curdeleted	libstar/xlist.h	/^	int		curdeleted;	\/\/ curnode가 삭제된 경우.. curnode는 next node로 세팅된다. $/;"	m	struct:__anon138
curentry	libstar/fhash.h	/^	int		curentry;		\/\/ 현재 검색\/loop 중인 엔트리 위치 $/;"	m	struct:__anon35
curentry	libstar/hash.h	/^	int             curentry;	\/\/ hash_first() \/ hash_next()$/;"	m	struct:__anon42
curentry	libstar/shash.h	/^	int		curentry;		\/\/ 현재 검색\/loop 중인 엔트리 위치 $/;"	m	struct:__anon72
curfind	libstar/vhash.h	/^	int             curfind;		\/\/ vhash_find() \/ vhash_findnext()$/;"	m	struct:__anon106
curfindtable	libstar/vhash.h	/^	int		curfindtable;		\/\/ 현재 검색중인 테이블 인덱스 $/;"	m	struct:__anon106
curiflist	libstar/xnms.h	/^	snmpif_t	*curiflist, *oldiflist;		\/\/ 5분 단위 I\/F 통계 정보$/;"	m	struct:xnmsnode
curiflistday	libstar/xnms.h	/^	snmpif_t	*curiflistday, *oldiflistday, *miniflistday, *maxiflistday, *avgiflistday;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
curiflisthour	libstar/xnms.h	/^	snmpif_t	*curiflisthour, *oldiflisthour, *miniflisthour, *maxiflisthour, *avgiflisthour;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
curl	hdaclib.h	/^	CURL	*curl;$/;"	m	struct:__anon9
curl_errbuf	hdaclib.h	/^	char	curl_errbuf[CURL_ERROR_SIZE + 1];$/;"	m	struct:__anon9
curlen	lib/sha256.h	/^    uint32_t    curlen;$/;"	m	struct:__anon22
curlen	lib/sha512.h	/^    uint32_t    curlen;$/;"	m	struct:__anon24
curnode	libstar/hash.h	/^	struct hashentry *curnode;	\/\/ 현재 traverse 중인 노드$/;"	m	struct:__anon42	typeref:struct:__anon42::hashentry
curnode	libstar/xlist.h	/^	xlistnode_t	*curnode;	\/\/ 현재 traverse 중인 노드의 위치$/;"	m	struct:__anon138
curnumif	libstar/xnms.h	/^	int		curnumif, oldnumif;$/;"	m	struct:xnmsnode
curnumifday	libstar/xnms.h	/^	int		daycount, curnumifday, oldnumifday;$/;"	m	struct:xnmsnode
curnumifhour	libstar/xnms.h	/^	int		hourcount, curnumifhour, oldnumifhour;$/;"	m	struct:xnmsnode
curnumsess	libstar/xnms.h	/^	int		curnumsess, oldnumsess;$/;"	m	struct:xnmsnode
curnumxif	libstar/xnms.h	/^	int		curnumxif, oldnumxif;$/;"	m	struct:xnmsnode
curp	libstar/xstr.h	/^	char	*curp;	\/\/ 버퍼에서 현재의 위치 $/;"	m	struct:__anon168
curpos	libstar/xtn.h	/^	int		curpos;		\/\/ 현재 위치 (한 줄씩 읽을 경우..)$/;"	m	struct:xtn
currEstab	libstar/snmpdef.h	/^	uint	currEstab;		\/\/ 현 상태에서 ESTABLISHED 또는 Closed-Wait 인 TCP 접속의 개수 $/;"	m	struct:__anon84
curretry	libstar/xping.h	/^	int		curretry;		\/\/ 현재 재시도 횟수$/;"	m	struct:xping
curscan	libstar/xping.h	/^	int		curscan;		\/\/ 현재 Scan 회수$/;"	m	struct:xping
cursesslist	libstar/xnms.h	/^	l4sess_t	*cursesslist, *oldsesslist;	\/\/ 5분 단위 L4 Session 정보 $/;"	m	struct:xnmsnode
cursys	libstar/xnms.h	/^	snmpsys_t	*cursys, *oldsys;		\/\/ System 정보$/;"	m	struct:xnmsnode
curxiflist	libstar/xnms.h	/^	snmpxif_t	*curxiflist, *oldxiflist;	\/\/ 5분 단위 I\/F 통계 정보$/;"	m	struct:xnmsnode
d	lib/md5.h	/^    uint32_t     d;$/;"	m	struct:__anon16
d1printf	libstar/xdebug.h	114;"	d
d2printf	libstar/xdebug.h	113;"	d
d3printf	libstar/xdebug.h	112;"	d
d4printf	libstar/xdebug.h	111;"	d
d5printf	libstar/xdebug.h	110;"	d
d6printf	libstar/xdebug.h	109;"	d
d7printf	libstar/xdebug.h	108;"	d
daddr	libstar/sflowlib.h	/^    uint32_t daddr;$/;"	m	struct:iphdr
data	hdaclib.h	/^	hdac_auth_data2_t data[MAX_AUTH_DATA];$/;"	m	struct:__anon5
data	libstar/ocilib.h	/^	void		*data;		\/* *\/   $/;"	m	struct:__anon61
data	libstar/snmpdef.h	/^	void	*data[IDX_MAXDATA];	\/\/ 데이타 $/;"	m	struct:__anon93
data	libstar/ssmtp.h	/^	char            data[MAX_RECEIVER][MAX_DOMAIN_LEN];$/;"	m	struct:__anon99
data	libstar/ssmtp.h	/^	void           *data;			\/\/ actual data to mail $/;"	m	struct:__anon100
data	libstar/ssmtplib.h	/^	void           *data;$/;"	m	struct:__anon102
data	libstar/xicmp.h	/^	void		*data;			\/\/ ICMP 패킷에 같이 보낼 사용자 정의 구조체 (최대 4KB)$/;"	m	struct:__anon136
data	libstar/xicmp.h	/^	xicmpdata_t	data;$/;"	m	struct:__anon135
data	libstar/xpcap.h	/^	char		*data;			\/\/ TCP\/UDP data area$/;"	m	struct:__anon153
data	libstar/xsnmp.h	/^	char		data[128];		\/\/ 데이터에 의한 분류..$/;"	m	struct:__anon163
data	libstar/xstr.h	/^	char	*data;	\/\/ 버퍼의 저장 데이터 $/;"	m	struct:__anon168
data_hdr_v9	libstar/nflowlib.h	/^struct data_hdr_v9$/;"	s
data_len	libstar/ssmtp.h	/^	unsigned long   data_len;		\/\/ data length $/;"	m	struct:__anon100
data_len	libstar/ssmtplib.h	/^	unsigned long   data_len;$/;"	m	struct:__anon102
data_size	libstar/ocilib.h	/^	ub2		data_size;	\/* data size *\/ $/;"	m	struct:__anon61
data_type	libstar/ocilib.h	/^	ub2		data_type;	\/* column data type *\/ $/;"	m	struct:__anon61
dataaddr	libstar/xapp.h	/^	uint		dataaddr;	\/\/ FTP data 서버 주소 $/;"	m	struct:__anon113
datacallback	libstar/xnms.h	/^	void		(*datacallback) (int type, void *data);$/;"	m	struct:xnmsnode
datagramVersion	libstar/sflowlib.h	/^	uint            datagramVersion;$/;"	m	struct:_SFSample
datagram_version	libstar/sflowlib.h	/^	uint            datagram_version;	\/* (enum SFLDatagram_version) = VERSION5 = 5 *\/$/;"	m	struct:_SFLSample_datagram_hdr
datalen	libstar/dvdlib.h	/^	int		datalen;		\/\/ 현재 블록의 길이$/;"	m	struct:__anon31
datalen	libstar/gw.h	/^	uint	datalen;		\/\/ 데이터 블록의 크기 $/;"	m	struct:__anon38
datalen	libstar/gw.h	/^	uint	datalen;		\/\/ 데이터 블록의 크기 $/;"	m	struct:__anon39
datalen	libstar/oddlib.h	/^	int		datalen;		\/\/ 현재 블록의 길이$/;"	m	struct:__anon64
datalen	libstar/xdb.h	/^	int		datalen;$/;"	m	struct:__anon116
datalen	libstar/xicmp.h	/^	int		datalen;		\/\/ ICMP 패킷에 같이 보낼 사용자 정의 구조체의 크기$/;"	m	struct:__anon136
datap	libstar/sflowlib.h	/^	uint           *datap;$/;"	m	struct:_SFSample
dataport	libstar/xapp.h	/^	int		dataport;	\/\/ FTP data 서버 포트 $/;"	m	struct:__anon113
datasize	libstar/worm.h	/^	char		datasize[16];$/;"	m	struct:__anon108
datasock	libstar/xapp.h	/^	int		datasock;	\/\/ FTP Data 전송용 socket$/;"	m	struct:__anon113
day	libstar/xtime.c	/^	uchar    mon, day;		\/\/ 1..12월  1..31일 $/;"	m	struct:__anon169	file:
daycount	libstar/xnms.h	/^	int		daycount, curnumifday, oldnumifday;$/;"	m	struct:xnmsnode
dayterm	libstar/xnms.h	/^	int		dayterm;		\/\/ 1일 주기 통계 $/;"	m	struct:xnmsnode
dbname	libstar/xdb.h	/^	char		dbname[64];$/;"	m	struct:__anon118
dbscanf	libstar/xdb.c	/^int	dbscanf(xdb_t *xdb, ...)$/;"	f
dbtype	libstar/xdb.h	/^	int		dbtype;		\/\/ MYSQL_DB,...$/;"	m	struct:__anon118
dcd_dport	libstar/sflowlib.h	/^	uint            dcd_dport;$/;"	m	struct:_SFSample
dcd_dstIP	libstar/sflowlib.h	/^	struct in_addr  dcd_dstIP;$/;"	m	struct:_SFSample	typeref:struct:_SFSample::in_addr
dcd_ipProtocol	libstar/sflowlib.h	/^	uint            dcd_ipProtocol;$/;"	m	struct:_SFSample
dcd_ipTTL	libstar/sflowlib.h	/^	uint            dcd_ipTTL;$/;"	m	struct:_SFSample
dcd_ipTos	libstar/sflowlib.h	/^	uint            dcd_ipTos;$/;"	m	struct:_SFSample
dcd_sport	libstar/sflowlib.h	/^	uint            dcd_sport;$/;"	m	struct:_SFSample
dcd_srcIP	libstar/sflowlib.h	/^	struct in_addr  dcd_srcIP;$/;"	m	struct:_SFSample	typeref:struct:_SFSample::in_addr
dcd_tcpFlags	libstar/sflowlib.h	/^	uint            dcd_tcpFlags;$/;"	m	struct:_SFSample
ddww_echo	libstar/xtn.c	/^void ddww_echo(SOCKET server,_verb verb, _option option)$/;"	f
ddww_error	libstar/xtn.c	/^void ddww_error(SOCKET server,_verb verb,_option option)$/;"	f
ddww_supp	libstar/xtn.c	/^void ddww_supp(SOCKET server,_verb verb,_option option) \/\/Suppress GA$/;"	f
ddww_term	libstar/xtn.c	/^void ddww_term(SOCKET server,_verb verb,_option option) \/\/Subnegotiate terminal type$/;"	f
de_key_idea	libstar/idea.c	/^static void de_key_idea(IDEAkey Z, IDEAkey DK)$/;"	f	file:
debug_alloc_buf	libstar/xdebug.c	/^static	int	debug_alloc_buf(const char *file, const int lineno, int size, char *buf)$/;"	f	file:
debug_calloc	libstar/xdebug.h	193;"	d
debug_dump_buf	libstar/xdebug.c	/^static	int	debug_dump_buf(int timeout)$/;"	f	file:
debug_free	libstar/xdebug.h	194;"	d
debug_free_buf	libstar/xdebug.c	/^static	int	debug_free_buf(const char *file, const int lineno, char *buf)$/;"	f	file:
debug_malloc	libstar/xdebug.h	191;"	d
debug_realoc	libstar/xdebug.h	192;"	d
debug_strdup	libstar/xdebug.h	195;"	d
decodeIPLayer4	libstar/sflowlib.c	/^static	void	decodeIPLayer4(SFSample * sample, uchar * ptr, uint ipProtocol)$/;"	f	file:
decodeIPV4	libstar/sflowlib.c	/^static	void	decodeIPV4(SFSample * sample)$/;"	f	file:
decodeLinkLayer	libstar/sflowlib.c	/^static	void	decodeLinkLayer(SFSample * sample)$/;"	f	file:
decodeMpls	libstar/sflowlib.c	/^static	void	decodeMpls(SFSample * sample)$/;"	f	file:
decoderawexchange	rpc.h	/^	string decoderawexchange(const char *tx_hex, const bool verbose = false)$/;"	f	class:hdac
decoderawtx	rpc.h	/^	string decoderawtx(const char *tx_hex)$/;"	f	class:hdac
defaultTTL	libstar/snmpdef.h	/^	int	defaultTTL;$/;"	m	struct:__anon81
default_port	libstar/xsnmptrap.c	/^static	char	*default_port = (char *)"udp:162";$/;"	v	file:
default_prompt	libstar/xnms.h	/^	char		default_prompt[80];		\/\/ 기본 telnet 프롬프트 $/;"	m	struct:__anon149
default_prompt	libstar/xnms.h	/^	char		default_prompt[80];$/;"	m	struct:__anon145
delayms	libstar/xicmp.h	/^	int		delayms;		\/\/ 지연 시각 (ms)$/;"	m	struct:__anon136
delconf	libstar/xstr.c	/^int	delconf(char *filename, char *name)$/;"	f
deleted	libstar/xnms.h	/^	int		deleted;		\/\/ 삭제된 경우 1 $/;"	m	struct:xnmsnode
deny_same_addr	libstar/gw.h	/^	uint	deny_same_addr;		\/\/ 1이면 동일 주소, port에서 접속시 deny$/;"	m	struct:gwrule
depth	json2.h	/^	short	depth;$/;"	m	class:jsonnode
depth	libstar/sflowlib.h	/^	uint            depth;$/;"	m	struct:_SFLLabelStack
depth	myjson/json.h	/^	int	depth;$/;"	m	struct:jsonnode
depth	myjson/json2.h	/^	short	depth;$/;"	m	class:jsonnode
descid	libstar/ocilib.h	/^	int		descid;		\/* descriptor id for descriptors *\/$/;"	m	struct:__anon61
descriptor	libstar/ocilib.h	/^	dvoid		*descriptor;	\/* OCI descriptor handle *\/$/;"	m	struct:__anon62
destIPAddress	libstar/xicmp.h	/^	uint		destIPAddress;		\/\/ Destination Address$/;"	m	struct:__anon131
destaddr	libstar/snmpdef.h	/^	char	destaddr[20];		\/\/ dest ip addr for this route		{ipRouteEntry 1 } RW $/;"	m	struct:__anon82
dev	libstar/xpcap.h	/^	char		*dev;$/;"	m	struct:__anon154
device	libstar/snmpdef.h	/^	char	device[20];		\/\/ 동일하면 같은 소켓을 공유해 쓰는 것이다...(thread간) "37182"$/;"	m	struct:__anon92
device	libstar/xsock.h	/^	char		device[100];$/;"	m	struct:xsocket
devname	libstar/xpcap.h	/^	char		*devname;		\/\/ Unix에서는 "eth0"과 같이 쓰고 윈도우에서는 "0" "1"과 같이 순번 지정 $/;"	m	struct:__anon154
dhcp	libstar/xsock.h	/^	int		dhcp;$/;"	m	struct:__anon166
dhcpserver	libstar/xsock.h	/^	char		dhcpserver[20];$/;"	m	struct:__anon166
diffsum	libstar/xtime.h	/^	xtime_t		diffsum;$/;"	m	struct:__anon173
direction	libstar/sflowlib.h	/^	uint            direction;	\/* enum SFLExtended_url_direction *\/$/;"	m	struct:_SFLExtended_url
dirp	libstar/xutil.h	/^	DIR		*dirp;$/;"	m	struct:__anon180
disable_snmp_bulk	libstar/xnms.h	/^	int		disable_snmp_bulk;	\/\/ 1이면 GETNEXT$/;"	m	struct:xnmsnode
disable_snmp_bulk	libstar/xsnmp.h	/^	int		disable_snmp_bulk;	\/\/ 1이면 순서대로 SNMP 정보 입수 $/;"	m	struct:__anon158
disablerawtx	rpc.h	/^	string disablerawtx(const char *tx_hex)$/;"	f	class:hdac
discards	libstar/sflowlib.h	/^	uint            discards;$/;"	m	struct:_SFLVlan_counters
disp_error	libstar/fhash.h	/^	int		disp_error;$/;"	m	struct:__anon35
disp_error	libstar/hash.h	/^	int		disp_error;$/;"	m	struct:__anon41
disp_error	libstar/shash.h	/^	int		disp_error;$/;"	m	struct:__anon71
disp_error	libstar/vhash.h	/^	int		disp_error;$/;"	m	struct:__anon105
dnsprefix	libstar/xsock.h	/^	char		dnsprefix[100];$/;"	m	struct:__anon166
dnsserver	libstar/xsock.h	/^	char		dnsserver[4][20];$/;"	m	struct:__anon166
dos_qdepth	libstar/snmpdef.h	/^	uint		dos_qdepth;		\/\/ Counter32(65 - cntr32)$/;"	m	struct:__anon96
dot12HCInHighPriorityOctets	libstar/sflowlib.h	/^	uint64          dot12HCInHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12HCInNormPriorityOctets	libstar/sflowlib.h	/^	uint64          dot12HCInNormPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12HCOutHighPriorityOctets	libstar/sflowlib.h	/^	uint64          dot12HCOutHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12InDataErrors	libstar/sflowlib.h	/^	uint            dot12InDataErrors;$/;"	m	struct:_SFLVg_counters
dot12InHighPriorityFrames	libstar/sflowlib.h	/^	uint            dot12InHighPriorityFrames;$/;"	m	struct:_SFLVg_counters
dot12InHighPriorityOctets	libstar/sflowlib.h	/^	uint64          dot12InHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12InIPMErrors	libstar/sflowlib.h	/^	uint            dot12InIPMErrors;$/;"	m	struct:_SFLVg_counters
dot12InNormPriorityFrames	libstar/sflowlib.h	/^	uint            dot12InNormPriorityFrames;$/;"	m	struct:_SFLVg_counters
dot12InNormPriorityOctets	libstar/sflowlib.h	/^	uint64          dot12InNormPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12InNullAddressedFrames	libstar/sflowlib.h	/^	uint            dot12InNullAddressedFrames;$/;"	m	struct:_SFLVg_counters
dot12InOversizeFrameErrors	libstar/sflowlib.h	/^	uint            dot12InOversizeFrameErrors;$/;"	m	struct:_SFLVg_counters
dot12OutHighPriorityFrames	libstar/sflowlib.h	/^	uint            dot12OutHighPriorityFrames;$/;"	m	struct:_SFLVg_counters
dot12OutHighPriorityOctets	libstar/sflowlib.h	/^	uint64          dot12OutHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12TransitionIntoTrainings	libstar/sflowlib.h	/^	uint            dot12TransitionIntoTrainings;$/;"	m	struct:_SFLVg_counters
dot3StatsAlignmentErrors	libstar/sflowlib.h	/^	uint            dot3StatsAlignmentErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsCarrierSenseErrors	libstar/sflowlib.h	/^	uint            dot3StatsCarrierSenseErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsDeferredTransmissions	libstar/sflowlib.h	/^	uint            dot3StatsDeferredTransmissions;$/;"	m	struct:_SFLEthernet_counters
dot3StatsExcessiveCollisions	libstar/sflowlib.h	/^	uint            dot3StatsExcessiveCollisions;$/;"	m	struct:_SFLEthernet_counters
dot3StatsFCSErrors	libstar/sflowlib.h	/^	uint            dot3StatsFCSErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsFrameTooLongs	libstar/sflowlib.h	/^	uint            dot3StatsFrameTooLongs;$/;"	m	struct:_SFLEthernet_counters
dot3StatsInternalMacReceiveErrors	libstar/sflowlib.h	/^	uint            dot3StatsInternalMacReceiveErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsInternalMacTransmitErrors	libstar/sflowlib.h	/^	uint            dot3StatsInternalMacTransmitErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsLateCollisions	libstar/sflowlib.h	/^	uint            dot3StatsLateCollisions;$/;"	m	struct:_SFLEthernet_counters
dot3StatsMultipleCollisionFrames	libstar/sflowlib.h	/^	uint            dot3StatsMultipleCollisionFrames;$/;"	m	struct:_SFLEthernet_counters
dot3StatsSQETestErrors	libstar/sflowlib.h	/^	uint            dot3StatsSQETestErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsSingleCollisionFrames	libstar/sflowlib.h	/^	uint            dot3StatsSingleCollisionFrames;$/;"	m	struct:_SFLEthernet_counters
dot3StatsSymbolErrors	libstar/sflowlib.h	/^	uint            dot3StatsSymbolErrors;$/;"	m	struct:_SFLEthernet_counters
dot5StatsACErrors	libstar/sflowlib.h	/^	uint            dot5StatsACErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsAbortTransErrors	libstar/sflowlib.h	/^	uint            dot5StatsAbortTransErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsBurstErrors	libstar/sflowlib.h	/^	uint            dot5StatsBurstErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsFrameCopiedErrors	libstar/sflowlib.h	/^	uint            dot5StatsFrameCopiedErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsFreqErrors	libstar/sflowlib.h	/^	uint            dot5StatsFreqErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsHardErrors	libstar/sflowlib.h	/^	uint            dot5StatsHardErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsInternalErrors	libstar/sflowlib.h	/^	uint            dot5StatsInternalErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsLineErrors	libstar/sflowlib.h	/^	uint            dot5StatsLineErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsLobeWires	libstar/sflowlib.h	/^	uint            dot5StatsLobeWires;$/;"	m	struct:_SFLTokenring_counters
dot5StatsLostFrameErrors	libstar/sflowlib.h	/^	uint            dot5StatsLostFrameErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsReceiveCongestions	libstar/sflowlib.h	/^	uint            dot5StatsReceiveCongestions;$/;"	m	struct:_SFLTokenring_counters
dot5StatsRecoverys	libstar/sflowlib.h	/^	uint            dot5StatsRecoverys;$/;"	m	struct:_SFLTokenring_counters
dot5StatsRemoves	libstar/sflowlib.h	/^	uint            dot5StatsRemoves;$/;"	m	struct:_SFLTokenring_counters
dot5StatsSignalLoss	libstar/sflowlib.h	/^	uint            dot5StatsSignalLoss;$/;"	m	struct:_SFLTokenring_counters
dot5StatsSingles	libstar/sflowlib.h	/^	uint            dot5StatsSingles;$/;"	m	struct:_SFLTokenring_counters
dot5StatsSoftErrors	libstar/sflowlib.h	/^	uint            dot5StatsSoftErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsTokenErrors	libstar/sflowlib.h	/^	uint            dot5StatsTokenErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsTransmitBeacons	libstar/sflowlib.h	/^	uint            dot5StatsTransmitBeacons;$/;"	m	struct:_SFLTokenring_counters
dprintf	libstar/xdebug.h	115;"	d
driver1	libstar/xhash.c	/^void driver1()$/;"	f
driver2	libstar/xhash.c	/^void driver2()$/;"	f
driver3	libstar/xhash.c	/^void driver3()$/;"	f
driver4	libstar/xhash.c	/^ void driver4()$/;"	f
driver5	libstar/xhash.c	/^void driver5()$/;"	f
dropEvents	libstar/sflowlib.h	/^	uint            dropEvents;$/;"	m	struct:_SFSample
drop_conn64	libstar/snmpdef.h	/^	uint64		drop_conn64;		\/\/ 드롭 세션 누적 $/;"	m	struct:__anon96
drops	libstar/sflowlib.h	/^	uint            drops;	\/* Number of times a packet was dropped due to$/;"	m	struct:_SFLFlow_sample
drops	libstar/sflowlib.h	/^	uint            drops;	\/* Number of times a packet was dropped due to$/;"	m	struct:_SFLFlow_sample_expanded
drv_info	libstar/oddlibwin.c	/^static _DRIVE_INFO drv_info[MAX_SCAN_DRIVE];$/;"	v	file:
ds_class	libstar/sflowlib.h	/^	uint            ds_class;	\/* EXPANDED *\/$/;"	m	struct:_SFLCounters_sample_expanded
ds_class	libstar/sflowlib.h	/^	uint            ds_class;	\/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
ds_class	libstar/sflowlib.h	/^	uint            ds_class;$/;"	m	struct:_SFSample
ds_index	libstar/sflowlib.h	/^	uint            ds_index;	\/* EXPANDED *\/$/;"	m	struct:_SFLCounters_sample_expanded
ds_index	libstar/sflowlib.h	/^	uint            ds_index;	\/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
ds_index	libstar/sflowlib.h	/^	uint            ds_index;$/;"	m	struct:_SFSample
dsn	libstar/xdb.h	/^	char		dsn[32];$/;"	m	struct:__anon118
dst	libstar/sflowlib.h	/^	SFLAddress      dst;	\/* Destination address *\/$/;"	m	struct:_SFLExtended_nat
dstMask	libstar/sflowlib.h	/^	uint            dstMask;$/;"	m	struct:_SFSample
dst_as	libstar/nflowlib.h	/^	uint16       dst_as;	\/* Destination AS *\/$/;"	m	struct:struct_export_v8_12
dst_as	libstar/nflowlib.h	/^	uint16       dst_as;	\/* Destination AS *\/$/;"	m	struct:struct_export_v8_13
dst_as	libstar/nflowlib.h	/^	uint16       dst_as;	\/* originating AS of destination address *\/$/;"	m	struct:struct_export_v8_9
dst_as	libstar/sflowlib.h	/^	uint            dst_as;$/;"	m	struct:_SFSample
dst_as_path	libstar/sflowlib.h	/^	SFLExtended_as_path_segment *dst_as_path;	\/* list of seqs or sets *\/$/;"	m	struct:_SFLExtended_gateway
dst_as_path	libstar/sflowlib.h	/^	uint           *dst_as_path;$/;"	m	struct:_SFSample
dst_as_path_len	libstar/sflowlib.h	/^	uint            dst_as_path_len;$/;"	m	struct:_SFSample
dst_as_path_segments	libstar/sflowlib.h	/^	uint            dst_as_path_segments;	\/* number of segments in path *\/$/;"	m	struct:_SFLExtended_gateway
dst_charset	libstar/sflowlib.h	/^	uint            dst_charset;$/;"	m	struct:_SFLExtended_user
dst_ip	libstar/sflowlib.h	/^	struct in6_addr dst_ip;	\/* Destination IP Address *\/$/;"	m	struct:_SFLSampled_ipv6	typeref:struct:_SFLSampled_ipv6::in6_addr
dst_ip	libstar/sflowlib.h	/^	struct in_addr  dst_ip;	\/\/ Destination IP Address $/;"	m	struct:_SFLSampled_ipv4	typeref:struct:_SFLSampled_ipv4::in_addr
dst_ip	libstar/sflowlib.h	/^	uint8           dst_ip[16];$/;"	m	struct:_SFLSampled_ipv6
dst_mac	libstar/sflowlib.h	/^	uint8           dst_mac[8];$/;"	m	struct:_SFLSampled_ethernet
dst_mask	libstar/nflowlib.h	/^	uint8        dst_mask;	\/* Destination Prefix mask length *\/$/;"	m	struct:struct_export_v8_12
dst_mask	libstar/nflowlib.h	/^	uint8        dst_mask;	\/* Destination Prefix mask length *\/$/;"	m	struct:struct_export_v8_13
dst_mask	libstar/nflowlib.h	/^	uint8        dst_mask;	\/* Destination Prefix mask length *\/$/;"	m	struct:struct_export_v8_14
dst_mask	libstar/sflowlib.h	/^	uint            dst_mask;	\/* Destination address prefix mask bits *\/$/;"	m	struct:_SFLExtended_router
dst_peer_as	libstar/sflowlib.h	/^	uint            dst_peer_as;$/;"	m	struct:_SFSample
dst_port	libstar/sflowlib.h	/^	uint            dst_port;	\/* TCP\/UDP destination port number or equivalent *\/$/;"	m	struct:_SFLSampled_ipv6
dst_port	libstar/sflowlib.h	/^	uint            dst_port;	\/\/ TCP\/UDP destination port number or equivalent $/;"	m	struct:_SFLSampled_ipv4
dst_prefix	libstar/nflowlib.h	/^	uint32       dst_prefix;	\/* Destination Prefix *\/$/;"	m	struct:struct_export_v8_12
dst_prefix	libstar/nflowlib.h	/^	uint32       dst_prefix;	\/* Destination Prefix *\/$/;"	m	struct:struct_export_v8_13
dst_prefix	libstar/nflowlib.h	/^	uint32       dst_prefix;	\/* Destination Prefix *\/$/;"	m	struct:struct_export_v8_14
dst_priority	libstar/sflowlib.h	/^	uint            dst_priority;	\/* The 802.1p priority *\/$/;"	m	struct:_SFLExtended_switch
dst_user	libstar/sflowlib.h	/^	SFLString       dst_user;$/;"	m	struct:_SFLExtended_user
dst_user	libstar/sflowlib.h	/^	char            dst_user[SA_MAX_EXTENDED_USER_LEN + 1];$/;"	m	struct:_SFSample
dst_user_charset	libstar/sflowlib.h	/^	uint            dst_user_charset;$/;"	m	struct:_SFSample
dst_user_len	libstar/sflowlib.h	/^	uint            dst_user_len;$/;"	m	struct:_SFSample
dst_vlan	libstar/sflowlib.h	/^	uint            dst_vlan;	\/* The 802.1Q VLAN id of outgoing frame *\/$/;"	m	struct:_SFLExtended_switch
dstaddr	libstar/gw.h	/^	uint	dstaddr[1];		\/\/ G\/W에서 패킷을 전송해야 할 주소 (0=전체, IP 또는 IP list가 올 수 있음)$/;"	m	struct:__anon38
dstaddr	libstar/gw.h	/^	uint	dstaddr[255];		\/\/ G\/W에서 패킷을 전송해야 할 주소 (0=전체, IP 또는 IP list가 올 수 있음)$/;"	m	struct:__anon39
dstaddr	libstar/nflowlib.h	/^	ipv4addr	dstaddr;	\/\/ destination IP address$/;"	m	struct:__anon53
dstaddr	libstar/nflowlib.h	/^	ipv4addr	dstaddr;	\/\/ destination IP address$/;"	m	struct:__anon55
dstaddr	libstar/nflowlib.h	/^	ipv4addr	dstaddr;	\/\/ destination IP address$/;"	m	struct:__anon57
dstaddr	libstar/nflowlib.h	/^	ipv4addr	dstaddr;	\/\/ destination IP address$/;"	m	struct:__anon59
dstaddr	libstar/nflowlib.h	/^	uint32       dstaddr;	\/* destination IP address *\/$/;"	m	struct:struct_export_v8_6
dstaddr	libstar/nflowlib.h	/^	uint32       dstaddr;	\/* destination IP address *\/$/;"	m	struct:struct_export_v8_7
dstaddr	libstar/nflowlib.h	/^	uint32       dstaddr;	\/* destination IP address *\/$/;"	m	struct:struct_export_v8_8
dstaddr	libstar/xflowlib.h	/^	ipv4addr	dstaddr;	\/\/ destination IP address$/;"	m	struct:__anon129
dstaddr	libstar/xpcap.h	/^	uint		dstaddr;		\/\/ Destination IP$/;"	m	struct:__anon153
dstas	libstar/nflowlib.h	/^	uint16		dstas;		\/\/ destination AS$/;"	m	struct:struct_export_v8_1
dstas	libstar/nflowlib.h	/^	uint16		dstas;		\/\/ destination AS$/;"	m	struct:struct_export_v8_4
dstas	libstar/nflowlib.h	/^	uint16		dstas;		\/\/ destination AS$/;"	m	struct:struct_export_v8_5
dstas	libstar/nflowlib.h	/^	uint16		dstas;		\/\/ originating AS of destination address (always 0)$/;"	m	struct:__anon59
dstas	libstar/nflowlib.h	/^	uint16		dstas;		\/\/ originating AS of destination address$/;"	m	struct:__anon55
dstas	libstar/nflowlib.h	/^	uint16		dstas;		\/\/ originating AS of destination address$/;"	m	struct:__anon57
dstas	libstar/xflowlib.h	/^	int		dstas;$/;"	m	struct:__anon129
dstcclass	libstar/xflowlib.h	/^	ipv4addr	dstcclass;	\/\/ destination IP address$/;"	m	struct:__anon129
dstmac	libstar/xflowlib.h	/^	uchar		dstmac[8];$/;"	m	struct:__anon129
dstmac	libstar/xpcap.h	/^	uchar		*dstmac;		\/\/ Destination physical address$/;"	m	struct:__anon153
dstmask	libstar/nflowlib.h	/^	uint8		dstmask;	\/\/ destination address prefix mask bits (always 0)$/;"	m	struct:__anon59
dstmask	libstar/nflowlib.h	/^	uint8		dstmask;	\/\/ destination address prefix mask bits$/;"	m	struct:__anon55
dstmask	libstar/nflowlib.h	/^	uint8		dstmask;	\/\/ destination address prefix mask bits$/;"	m	struct:__anon57
dstmask	libstar/nflowlib.h	/^	uint8		dstmask;	\/\/ destination netmask length (bits)$/;"	m	struct:struct_export_v8_5
dstmask	libstar/nflowlib.h	/^	uint8		dstmask;	\/\/ destination network mask length (bits)$/;"	m	struct:struct_export_v8_4
dstmask	libstar/xflowlib.h	/^	uint32		dstmask;$/;"	m	struct:__anon129
dstname	libstar/xpcap.h	/^	char		*dstname;		\/\/ ARP에서 메모리 할당됨 (flag가 F_SUM으로 되어 있은 때만)$/;"	m	struct:__anon153
dstnet	libstar/nflowlib.h	/^	ipv4addr	dstnet;		\/\/ destination network$/;"	m	struct:struct_export_v8_4
dstnet	libstar/nflowlib.h	/^	ipv4addr	dstnet;		\/\/ destination network$/;"	m	struct:struct_export_v8_5
dstport	libstar/nflowlib.h	/^	uint16		dstport;	\/\/ TCP\/UDP destination port number or equivalent$/;"	m	struct:__anon53
dstport	libstar/nflowlib.h	/^	uint16		dstport;	\/\/ TCP\/UDP destination port number or equivalent$/;"	m	struct:__anon55
dstport	libstar/nflowlib.h	/^	uint16		dstport;	\/\/ TCP\/UDP destination port number or equivalent$/;"	m	struct:__anon57
dstport	libstar/nflowlib.h	/^	uint16		dstport;	\/\/ TCP\/UDP destination port number or equivalent,$/;"	m	struct:__anon59
dstport	libstar/nflowlib.h	/^	uint16		dstport;	\/\/ destination port$/;"	m	struct:struct_export_v8_2
dstport	libstar/nflowlib.h	/^	uint16       dstport;	\/* Destination port *\/$/;"	m	struct:struct_export_v8_14
dstport	libstar/nflowlib.h	/^	uint16       dstport;	\/* TCP\/UDP destination port *\/$/;"	m	struct:struct_export_v8_8
dstport	libstar/nflowlib.h	/^	uint16       dstport;	\/* TCP\/UDP dst port number of equivalent *\/$/;"	m	struct:struct_export_v8_10
dstport	libstar/xflowlib.h	/^	int		dstport;$/;"	m	struct:__anon129
dstport	libstar/xpcap.h	/^	int		dstport;		\/\/ IP destination port$/;"	m	struct:__anon153
dsttype	libstar/gw.h	/^	uint	dsttype;		\/\/ 도착지 타입 (GW_GATEWAY, GW_AGENT, GW_MANAGER... 사용자 정의도 가능)$/;"	m	struct:__anon38
dsttype	libstar/gw.h	/^	uint	dsttype;		\/\/ 도착지 타입 (GW_GATEWAY, GW_AGENT, GW_MANAGER... 사용자 정의도 가능)$/;"	m	struct:__anon39
dummy	libstar/dvdlib.h	/^	char		dummy[64 - 20];$/;"	m	struct:__anon31
dummy	libstar/oddlib.h	/^	char		dummy[64 - 20];$/;"	m	struct:__anon64
dummy	libstar/snmpdef.h	/^	char		dummy[32];$/;"	m	struct:__anon96
dummy	libstar/snmpdef.h	/^	char		dummy[36];$/;"	m	struct:__anon77
dummy	libstar/snmpdef.h	/^	char		dummy[96];$/;"	m	struct:__anon96
dummy	libstar/snmpdef.h	/^	char	dummy[40];$/;"	m	struct:__anon78
dummy	libstar/snmpdef.h	/^	char	dummy[92];$/;"	m	struct:__anon76
dummy	libstar/xdb.h	/^	char		dummy[252];$/;"	m	struct:__anon118
dummy	libstar/xicmp.h	/^	char		dummy[40];$/;"	m	struct:__anon135
dummy	libstar/xicmp.h	/^	char		dummy[PACKET_SIZE - sizeof(IcmpHeader) - 16];$/;"	m	struct:__anon133
dummy	libstar/xnms.h	/^	char		dummy[100];$/;"	m	struct:__anon145
dummy	libstar/xnms.h	/^	char		dummy[40];$/;"	m	struct:__anon147
dummy	libstar/xnms.h	/^	char		dummy[40];$/;"	m	struct:__anon148
dummy	libstar/xsnmp.h	/^	char	dummy[40];$/;"	m	struct:__anon161
dump	json11/json11.cpp	/^static void dump(NullStruct, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^static void dump(bool value, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^static void dump(const Json::array &values, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^static void dump(const Json::object &values, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^static void dump(const string &value, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^static void dump(double value, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^static void dump(int value, string &out)$/;"	f	namespace:json11
dump	json11/json11.cpp	/^void Json::dump(string &out) const$/;"	f	class:json11::Json
dump	json11/json11.hpp	/^    std::string dump() const {$/;"	f	class:json11::final
dump	myjson/json.h	/^	int dump(FILE *outfp = NULL, const int nspc = 4, int opt = 0)$/;"	f	class:json
dump	myjson/json2.c	/^string json::dump(FILE *outfp)$/;"	f	class:json
dump_common_packet	libstar/xflowconv.c	/^void	dump_common_packet(xflow_rawdata_t *rawp)$/;"	f
dump_flow_packet	libstar/nflowlib.c	/^static	void	dump_flow_packet(uchar *pkt, int pktsize)$/;"	f	file:
dump_sflow_packet	libstar/sflowlib.c	/^static	int	dump_sflow_packet(SFSample *spp)$/;"	f	file:
dumplist	myjson/json2.c	/^void json::dumplist(FILE *outfp)$/;"	f	class:json
dumpprivkey	rpc.h	/^	string dumpprivkey(const char *addr)$/;"	f	class:hdac
dumpwallet	rpc.h	/^	string dumpwallet(const char *filename)$/;"	f	class:hdac
dup	myjson/json2.c	/^json json::dup(int fromidx)$/;"	f	class:json
duration	libstar/netbios.c	/^	ushort		duration;$/;"	m	struct:__anon49	file:
dvd_add_write_queue	libstar/dvdlib.c	/^long	dvd_add_write_queue(char *path, long szfrom, long szto)$/;"	f
dvd_check_disk_recordable	libstar/dvdlib.c	/^static	int	dvd_check_disk_recordable(int drive)$/;"	f	file:
dvd_check_tray_status	libstar/dvdlib.c	/^DVDLIB_API int dvd_check_tray_status(int drvIdx)$/;"	f
dvd_data_block_in_drive	libstar/dvdlib.c	/^static	int dvd_data_block_in_drive(int drive, int *blocks_in_drive)$/;"	f	file:
dvd_disp_error	libstar/dvdlib.c	/^static void dvd_disp_error(LPTSTR lpszFunction)$/;"	f	file:
dvd_do_sync	libstar/dvdlib.c	/^static	int dvd_do_sync(int drive, int bImm)$/;"	f	file:
dvd_drive_inquiry	libstar/dvdlib.c	/^static	int dvd_drive_inquiry(int drive)$/;"	f	file:
dvd_drive_ready	libstar/dvdlib.c	/^DVDLIB_API int dvd_drive_ready(int drvIdx)$/;"	f
dvd_exec_write	libstar/dvdlib.c	/^static	int dvd_exec_write(int drive, BYTE * buf, int blen, int nwa)$/;"	f	file:
dvd_exit	libstar/dvdlib.c	/^DVDLIB_API	void	dvd_exit(int drvidx)$/;"	f
dvd_find_drive_index	libstar/dvdlib.c	/^static	int	dvd_find_drive_index(char *target_string, char *namebuf)$/;"	f	file:
dvd_free_aspi_buffer	libstar/dvdlib.c	/^static	int	dvd_free_aspi_buffer(void)$/;"	f	file:
dvd_get_device_num	libstar/dvdlib.c	/^static	int dvd_get_device_num(void)$/;"	f	file:
dvd_get_drive	libstar/dvdlib.c	/^DVDLIB_API int dvd_get_drive(char *target_drive_letter)$/;"	f
dvd_get_free_kbytes	libstar/dvdlib.c	/^DVDLIB_API int dvd_get_free_kbytes(int drive)$/;"	f
dvd_get_nwa	libstar/dvdlib.c	/^static	int dvd_get_nwa(int drive, int sess, int *nwa, int *free_block)$/;"	f	file:
dvd_get_queue_size	libstar/dvdlib.c	/^long	dvd_get_queue_size()$/;"	f
dvd_init	libstar/dvdlib.c	/^DVDLIB_API	int	dvd_init(char *drive_char)$/;"	f
dvd_init_aspi	libstar/dvdlib.c	/^static	int	dvd_init_aspi()$/;"	f	file:
dvd_init_aspi_buffer	libstar/dvdlib.c	/^static	int	dvd_init_aspi_buffer(void)$/;"	f	file:
dvd_packet_read	libstar/dvdlib.c	/^DVDLIB_API int dvd_packet_read(int drive, int lba, BYTE * buf, int buflen)$/;"	f
dvd_packet_write	libstar/dvdlib.c	/^DVDLIB_API int dvd_packet_write(int drive, BYTE * buf, int buflen)$/;"	f
dvd_r_discsize	libstar/dvdlib.c	/^	UCHAR		dvd_r_discsize;$/;"	m	struct:__anon28	file:
dvd_rec_init	libstar/dvdlib.c	/^DVDLIB_API int dvd_rec_init(void)$/;"	f
dvd_rec_shutdown	libstar/dvdlib.c	/^DVDLIB_API int dvd_rec_shutdown(void)$/;"	f
dvd_recordable	libstar/dvdlib.c	/^DVDLIB_API int dvd_recordable(int drive)$/;"	f
dvd_recv_track	libstar/dvdlib.c	/^static	int dvd_recv_track(int drive, int blen)$/;"	f	file:
dvd_scan	libstar/dvdlib.c	/^static	int	dvd_scan(void)$/;"	f	file:
dvd_send_packet	libstar/dvdlib.c	/^DVDLIB_API int dvd_send_packet(int drive, BYTE * aspibuf, UINT datalen,$/;"	f
dvd_set_write_page	libstar/dvdlib.c	/^static	int dvd_set_write_page(int drive, int LastSessionState)$/;"	f	file:
dvd_start_drive	libstar/dvdlib.c	/^DVDLIB_API int dvd_start_drive(int drive, int bImm)$/;"	f
dvd_stop_drive	libstar/dvdlib.c	/^DVDLIB_API int dvd_stop_drive(int drive, int bImm)$/;"	f
dvd_test_unit_ready	libstar/dvdlib.c	/^static	int dvd_test_unit_ready(int drive)$/;"	f	file:
dvd_tray_close	libstar/dvdlib.c	/^DVDLIB_API int dvd_tray_close(int drive, int bImm)$/;"	f
dvd_tray_open	libstar/dvdlib.c	/^DVDLIB_API int dvd_tray_open(int drive, int bImm)$/;"	f
dvd_update_changed_device	libstar/dvdlib.c	/^static	void dvd_update_changed_device(void)$/;"	f	file:
dvd_write_list	libstar/dvdlib.c	/^int	dvd_write_list(int drvidx, vhash_t *vht)$/;"	f
dvddrv_t	libstar/dvdlib.c	/^}	dvddrv_t;$/;"	t	typeref:struct:__anon28	file:
dvddrvinfo_t	libstar/dvdlib.h	/^}	dvddrvinfo_t;$/;"	t	typeref:struct:__anon34
dvdhdr_t	libstar/dvdlib.h	/^}	dvdhdr_t;$/;"	t	typeref:struct:__anon31
dvdhist_t	libstar/dvdlib.h	/^}	dvdhist_t;$/;"	t	typeref:struct:__anon32
dvdidx	libstar/dvdlib.h	/^	int		dvdidx;			\/\/ 드라이브 번호 $/;"	m	struct:__anon33
dvdidx	libstar/dvdlib.h	/^	int		dvdidx;$/;"	m	struct:__anon34
dvdinfo_t	libstar/dvdlib.h	/^}	dvdinfo_t;$/;"	t	typeref:struct:__anon33
dvdname	libstar/dvdlib.h	/^	char		dvdname[128];$/;"	m	struct:__anon33
dvdname	libstar/dvdlib.h	/^	char		dvdname[32];$/;"	m	struct:__anon34
dvdseq	libstar/dvdlib.h	/^	int		dvdseq;			\/\/ DVD sequence (_dvdseq)$/;"	m	struct:__anon32
dvdseq	libstar/dvdlib.h	/^	int		dvdseq;			\/\/ Disk 번호 (livedvd_num.dat에 저장됨)$/;"	m	struct:__anon33
echo	libstar/sflowlib.h	/^    } echo;			\/* echo datagram *\/$/;"	m	union:icmphdr::__anon67	typeref:struct:icmphdr::__anon67::__anon68
element	libstar/ssmtp.h	/^	unsigned int    element;$/;"	m	struct:__anon99
elements	libstar/sflowlib.h	/^	SFLCounters_sample_element *elements;$/;"	m	struct:_SFLCounters_sample
elements	libstar/sflowlib.h	/^	SFLCounters_sample_element *elements;$/;"	m	struct:_SFLCounters_sample_expanded
elements	libstar/sflowlib.h	/^	SFLFlow_sample_element *elements;$/;"	m	struct:_SFLFlow_sample
elements	libstar/sflowlib.h	/^	SFLFlow_sample_element *elements;$/;"	m	struct:_SFLFlow_sample_expanded
empty_map	json11/json11.cpp	/^    const map<string, Json> empty_map;$/;"	m	struct:json11::Statics	file:
empty_string	json11/json11.cpp	/^    const string empty_string;$/;"	m	struct:json11::Statics	file:
empty_vector	json11/json11.cpp	/^    const vector<Json> empty_vector;$/;"	m	struct:json11::Statics	file:
en_key_idea	libstar/idea.c	/^static void en_key_idea(word16 * userkey, word16 * Z)$/;"	f	file:
encap_levels	libstar/xpcap.h	/^	int		encap_levels;		\/\/ encapsulation level$/;"	m	struct:__anon153
encode_utf8	json11/json11.cpp	/^    void encode_utf8(long pt, string & out) {$/;"	f	struct:json11::__anon15::final
encryptwallet	rpc.h	/^	string encryptwallet(const char *passphrase)$/;"	f	class:hdac
endp	libstar/sflowlib.h	/^	uchar          *endp;$/;"	m	struct:_SFSample
endp	libstar/xstr.h	/^	char	*endp;	\/\/ 버퍼의 끝 $/;"	m	struct:__anon168
endtime	libstar/dvdlib.h	/^	time32		endtime;		\/\/ 레코딩 끝시간 (DVD 교체시 초기화됨)$/;"	m	struct:__anon32
endtime	libstar/dvdlib.h	/^	time32		starttime, endtime;	\/\/ 현재 DVD에 대한 기록 시작\/끝시각$/;"	m	struct:__anon33
endtime	libstar/xflowlib.h	/^	time32		endtime;	\/\/ sysUptime at end of flow$/;"	m	struct:__anon129
endtime	libstar/xtime.c	/^	double	endtime;$/;"	m	struct:__anon171	file:
endtm	libstar/xtime.h	/^	xtime_t		endtm;$/;"	m	struct:__anon173
engine_id	libstar/nflowlib.h	/^	uint8		engine_id;	\/\/  VIP2 slot number$/;"	m	struct:__anon54
engine_id	libstar/nflowlib.h	/^	uint8		engine_id;	\/\/ ID number of the flow switching engine$/;"	m	struct:__anon56
engine_id	libstar/nflowlib.h	/^	uint8		engine_id;	\/\/ ID number of the flow switching engine$/;"	m	struct:__anon58
engine_id	libstar/nflowlib.h	/^	uint8		engine_id;	\/\/ ID number of the flow switching engine$/;"	m	struct:__anon60
engine_id	libstar/xflowlib.h	/^	uint32		engine_id;$/;"	m	struct:__anon129
engine_type	libstar/nflowlib.h	/^	uint8		engine_type;	\/\/  no VIP = 0, VIP2 = 1$/;"	m	struct:__anon54
engine_type	libstar/nflowlib.h	/^	uint8		engine_type;	\/\/ type of flow switching engine$/;"	m	struct:__anon56
engine_type	libstar/nflowlib.h	/^	uint8		engine_type;	\/\/ type of flow switching engine$/;"	m	struct:__anon58
engine_type	libstar/nflowlib.h	/^	uint8		engine_type;	\/\/ type of flow switching engine$/;"	m	struct:__anon60
engine_type	libstar/xflowlib.h	/^	uint32		engine_type;$/;"	m	struct:__anon129
entp	libstar/xutil.h	/^	struct dirent	*entp;$/;"	m	struct:__anon180	typeref:struct:__anon180::dirent
entry	libstar/hash.h	/^	int		entry;		\/\/ hashval % tablesize;$/;"	m	struct:hashentry
entrysize	libstar/fhash.h	/^	int		entrysize;		\/\/ instsize + keylen + 1 (use)$/;"	m	struct:__anon35
entrysize	libstar/hash.h	/^	int		entrysize;	\/\/ hashent_t size (key, inst에 따라 크기가 변하므로)$/;"	m	struct:hashentry
entrysize	libstar/shash.h	/^	int		entrysize;		\/\/ instsize + keylen + 1 (use)$/;"	m	struct:__anon71
entrysize	libstar/vhash.h	/^	int		entrysize;$/;"	m	struct:__anon105
entryvec	libstar/vhash.h	/^	char		*entryvec[MAX_VHASH_TABLE];	\/\/ 최대 100개 테이블이 생성되게...$/;"	m	struct:__anon105
entsz	libstar/snmpdef.h	/^	int	entsz[IDX_MAXDATA];	\/\/ 데이타블럭의 entry size $/;"	m	struct:__anon93
enum_t	libstar/snoop.h	/^typedef int		enum_t;$/;"	t
env	libstar/ocilib.h	/^	OCIEnv		*env;		\/* private env handle *\/$/;"	m	struct:ociconn
err	json11/json11.cpp	/^    string &err;$/;"	m	struct:json11::__anon15::final	file:
err	libstar/ocilib.h	/^	OCIError	*err;		\/* private error handle *\/$/;"	m	struct:ociconn
err	libstar/ocilib.h	/^	OCIError	*err;		\/* private error handle *\/$/;"	m	struct:ocistmt
errcode	libstar/ocilib.h	/^	sword		errcode;	\/* last errcode *\/$/;"	m	struct:ociconn
errcode	libstar/ocilib.h	/^	sword		errcode;	\/* last errcode*\/$/;"	m	struct:ocistmt
errcode	libstar/re.h	/^	int		errcode;$/;"	m	struct:__anon66
error	libstar/gw.h	/^	int	error;			\/\/ Socket 접속이 안되어서 retry 중...$/;"	m	struct:gwrule
error	libstar/xpcap.h	/^	int		error;			\/\/ 캡쳐 디바이스 에러인 경우 에러코드 (0은 정상)$/;"	m	struct:__anon154
esc	json11/json11.cpp	/^static inline string esc(char c)$/;"	f	namespace:json11
estabResets	libstar/snmpdef.h	/^	uint	estabResets;		\/\/ TCP 접속이 ESTABLISHED 상태 또는 closed-Wait 상태에서 $/;"	m	struct:__anon84
estab_conn	libstar/snmpdef.h	/^	uint		estab_conn;		\/\/ The number of established connections. Counter32(65 - cntr32)$/;"	m	struct:__anon96
estimatefee	rpc.h	/^	string estimatefee(const int nblocks)$/;"	f	class:hdac
estimatepriority	rpc.h	/^	string estimatepriority(const int nblocks)$/;"	f	class:hdac
eth_dst	libstar/sflowlib.h	/^	uchar           eth_dst[8];$/;"	m	struct:_SFSample
eth_len	libstar/sflowlib.h	/^	uint            eth_len;	\/\/ The length of the MAC packet excluding lower layer encapsulations $/;"	m	struct:_SFLSampled_ethernet
eth_len	libstar/sflowlib.h	/^	uint            eth_len;$/;"	m	struct:_SFSample
eth_src	libstar/sflowlib.h	/^	uchar           eth_src[8];$/;"	m	struct:_SFSample
eth_type	libstar/sflowlib.h	/^	uint            eth_type;$/;"	m	struct:_SFLSampled_ethernet
eth_type	libstar/sflowlib.h	/^	uint            eth_type;$/;"	m	struct:_SFSample
ether	libstar/xpcap.h	/^	struct ether_header *ether;		\/\/ ethernet packet pointer$/;"	m	struct:__anon153	typeref:struct:__anon153::ether_header
etherlen	libstar/xpcap.h	/^	int		etherlen;		\/\/ 이더넷 패킷의 길이$/;"	m	struct:__anon153
ethernet	libstar/sflowlib.h	/^	SFLEthernet_counters ethernet;$/;"	m	union:_SFLCounters_type
ethernet	libstar/sflowlib.h	/^	SFLSampled_ethernet ethernet;$/;"	m	union:_SFLFlow_type
eventcallback	libstar/xnms.h	/^	void		(*eventcallback) (int evtype, struct xnmsnode *xn, void *curdata, void *olddata);$/;"	m	struct:xnmsnode
evlevel	libstar/xnms.h	/^	int		evlevel;$/;"	m	struct:__anon151
evlevel	libstar/xsnmp.h	/^	int		evlevel;		\/\/ nms_oidname.dat에 TRAP 관련 정보 저장용..$/;"	m	struct:__anon163
exclude	libstar/xnms.h	/^	char		*exclude;$/;"	m	struct:__anon151
execquery	libstar/xdb.h	/^	char		execquery[256];$/;"	m	struct:__anon118
exectimeout	libstar/xutil.c	/^int	exectimeout(char *cmd, int waitMS)$/;"	f
executed	libstar/ocilib.h	/^	unsigned	executed:1;	\/* statement executed flag *\/$/;"	m	struct:ocistmt
execvtimeout	libstar/xutil.c	/^int	execvtimeout(char *av[], int waitMS)$/;"	f
exit	libstar/thrpool.h	/^	int		exit;		\/\/ Thread 종료용 $/;"	m	struct:thrdata
exit	libstar/xpcap.h	/^	int		exit;			\/\/ 1이면 capture stop..$/;"	m	struct:__anon154
exit_thread	libstar/xutil.h	70;"	d
exitthread	libstar/xflowlib.h	/^	int		exitthread;	\/\/ 1이면 thread 종료 $/;"	m	struct:xflow
expect	json11/json11.cpp	/^    Json expect(const string &expected, Json res) {$/;"	f	struct:json11::__anon15::final
expire	libstar/lock.h	/^	char		expire[10];		\/\/ 종료일자: YYMMDD$/;"	m	struct:__anon44
expire	libstar/worm.h	/^	char		expire[20];		\/\/ 이 시간이 지나면 삭제됨 (YYYY-MM-DD hh:ii:ss 또는 초단위로 지정)$/;"	m	struct:__anon109
expire	libstar/worm.h	/^	char		expire[20];		\/\/ 이 시간이 지나면 삭제됨 (YYYY-MM-DD hh:ii:ss 또는 초단위로 지정)$/;"	m	struct:__anon110
ext	libstar/xdebug.h	/^	char		ext[40];		\/\/ default="%d.log"$/;"	m	struct:__anon126
extended_data_tag	libstar/sflowlib.h	/^	uint            extended_data_tag;$/;"	m	struct:_SFSample
extra_pkts	libstar/nflowlib.h	/^	uint32       extra_pkts;	\/* packets that exceed the contract *\/$/;"	m	struct:struct_export_v8_6
extra_pkts	libstar/nflowlib.h	/^	uint32       extra_pkts;	\/* packets that exceed the contract *\/$/;"	m	struct:struct_export_v8_7
extra_pkts	libstar/nflowlib.h	/^	uint32       extra_pkts;	\/* packets that exceed the contract *\/$/;"	m	struct:struct_export_v8_8
f	json11/json11.cpp	/^    const std::shared_ptr<JsonValue> f = make_shared<JsonBoolean>(false);$/;"	m	struct:json11::Statics	file:
factorstr	libstar/xsnmp.h	/^	char		factorstr[40];		\/\/ 간혹 MIB 값을 보정해야 하는 경우 (예: Foundry는 570은 5.7%임)$/;"	m	struct:__anon163
fail	json11/json11.cpp	/^    Json fail(string &&msg) {$/;"	f	struct:json11::__anon15::final
fail	json11/json11.cpp	/^    T fail(string &&msg, const T err_ret) {$/;"	f	struct:json11::__anon15::final
fail_conn64	libstar/snmpdef.h	/^	uint64		fail_conn64;		\/\/ 실패 세션 누적 $/;"	m	struct:__anon96
failed	json11/json11.cpp	/^    bool failed;$/;"	m	struct:json11::__anon15::final	file:
failretry	libstar/xdb.h	/^	int		failretry;		\/\/ xdb_exec() 실패시 몇번 재시도할지 결정 (default=1)$/;"	m	struct:__anon118
fallingAlarm	libstar/xsnmptrap.c	/^static oid      fallingAlarm[] = { 1, 3, 6, 1, 6, 3, 2, 1, 1, 3, 2 };$/;"	v	file:
fanstatus	libstar/xnms.h	/^	char		fanstatus[20];		\/\/ .9 $/;"	m	struct:__anon147
fantestok	libstar/xnms.h	/^	char		fantestok[10];		\/\/ .10	\/\/ 0=정상 $/;"	m	struct:__anon147
fbytes	libstar/xflowlib.h	/^	float		fbytes;		\/\/ Collector로 유입되는 flow에 대한 통계 데이터 보관용 $/;"	m	struct:__anon130
fd	libstar/snmpdef.h	/^	char	fd[20];			\/\/ "33u"$/;"	m	struct:__anon92
fd	libstar/xdebug.c	/^	int		fd;		\/\/ key...$/;"	m	struct:__anon120	file:
fd	libstar/xsock.h	/^	int		fd;		\/\/ Socket descriptor$/;"	m	struct:xsocket
fhash_close	libstar/fhash.h	67;"	d
fhash_create	libstar/fhash.c	/^static	FILE	*fhash_create(fhash_t *ht, char *filename, int tablesize, int entrysize, int keylen)$/;"	f	file:
fhash_delete	libstar/fhash.c	/^void		fhash_delete(register fhash_t *ht, register fhashent_t *fhe)$/;"	f
fhash_deleteall	libstar/fhash.c	/^void		fhash_deleteall(fhash_t *ht)$/;"	f
fhash_fast_func	libstar/fhash.c	/^uint32	fhash_fast_func(const char *data, size_t len)$/;"	f
fhash_find	libstar/fhash.c	/^fhashent_t	*fhash_find(register fhash_t *ht, void *key)$/;"	f
fhash_findempty	libstar/fhash.c	/^fhashent_t	*fhash_findempty(register fhash_t *ht, void *key, int *ret_entry)$/;"	f
fhash_findnext	libstar/fhash.c	/^fhashent_t	*fhash_findnext(register fhash_t *ht, void *key)$/;"	f
fhash_first	libstar/fhash.c	/^fhashent_t	*fhash_first(fhash_t *ht)$/;"	f
fhash_free	libstar/fhash.h	65;"	d
fhash_func	libstar/fhash.c	/^uint	fhash_func(const void *key, size_t len)$/;"	f
fhash_getdata	libstar/fhash.c	/^void		*fhash_getdata(fhash_t *ht, fhashent_t *fhe, int *datalen)$/;"	f
fhash_getkey	libstar/fhash.c	/^void		*fhash_getkey(fhash_t *ht, fhashent_t *fhe, int *keylen)$/;"	f
fhash_getsize	libstar/fhash.c	/^int	fhash_getsize(fhash_t *ht)$/;"	f
fhash_init	libstar/fhash.h	62;"	d
fhash_insert	libstar/fhash.h	77;"	d
fhash_lock	libstar/fhash.h	70;"	d
fhash_next	libstar/fhash.c	/^fhashent_t	*fhash_next(fhash_t *ht)$/;"	f
fhash_read	libstar/fhash.c	/^static	void	*fhash_read(fhash_t *ht, int nthentry)$/;"	f	file:
fhash_saveinfo	libstar/fhash.c	/^static	void	fhash_saveinfo(fhash_t *ht)$/;"	f	file:
fhash_t	libstar/fhash.h	/^}	fhash_t;$/;"	t	typeref:struct:__anon35
fhash_unlock	libstar/fhash.h	71;"	d
fhash_update	libstar/fhash.h	78;"	d
fhash_write	libstar/fhash.c	/^static	int	fhash_write(fhash_t *ht, int nthentry, void *buf)$/;"	f	file:
fhashent_t	libstar/fhash.h	/^}	fhashent_t;$/;"	t	typeref:struct:__anon36
file	libstar/xdebug.c	/^	char	*file;$/;"	m	struct:__anon121	file:
file	libstar/xdebug.h	/^	char		file[200];$/;"	m	struct:__anon126
file	libstar/xdebug.h	/^	char	file[100];$/;"	m	struct:__anon124
file	libstar/xlock.h	/^	char		*file;		\/\/ lock request file $/;"	m	struct:__anon141
file	libstar/xtime.c	/^	char		*file;$/;"	m	struct:__anon170	file:
fileloc	libstar/dvdlib.h	/^	uint		fileloc;		\/\/ 파일 내의 위치$/;"	m	struct:__anon31
fileloc	libstar/oddlib.h	/^	long		fileloc;		\/\/ 파일 내의 위치$/;"	m	struct:__anon64
filename	libstar/fhash.h	/^	char		filename[128];$/;"	m	struct:__anon35
filename	libstar/ssmtp.h	/^	char           *filename;		\/\/ if we will send appendix, this specifies the attached file name $/;"	m	struct:__anon100
filename	libstar/ssmtplib.h	/^	char            filename[256];$/;"	m	struct:__anon102
filename	libstar/xdebug.c	/^	char		filename[40];$/;"	m	struct:__anon120	file:
filename	libstar/xssl.h	/^	char		filename[100];		\/\/ socket open한 위치..$/;"	m	struct:__anon167
filename	libstar/xtime.h	/^	char		filename[100];$/;"	m	struct:__anon173
filename	libstar/xutil.h	/^	char		filename[256];$/;"	m	struct:__anon180
fileno_check	libstar/xdebug.c	/^int	fileno_check(int maxcount, int limit)$/;"	f
fileno_count	libstar/xdebug.c	/^static	void	fileno_count(const char *filename, const int lineno, const char *path, int fd, int isopen)$/;"	f	file:
filep	libstar/xdebug.h	/^	FILE		*filep;			\/\/ opened file pointer$/;"	m	struct:__anon126
fileptn	libstar/loglib.h	/^	char		fileptn[128];	\/\/ 파일 패턴 (이게 지정되면 logpath 하부를 모두 뒤져서 맞는 파일을 찾아냄)$/;"	m	struct:__anon45
filesize	libstar/dvdlib.h	/^	uint		filesize;		\/\/ 실제 파일 크기 $/;"	m	struct:__anon32
filter	libstar/xpcap.h	/^	char		*filter;		\/\/ 필터 $/;"	m	struct:__anon154
final	json11/json11.cpp	/^class JsonArray final : public Value<Json::ARRAY, Json::array> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^class JsonBoolean final : public Value<Json::BOOL, bool> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^class JsonDouble final : public Value<Json::NUMBER, double> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^class JsonInt final : public Value<Json::NUMBER, int> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^class JsonNull final : public Value<Json::NUL, NullStruct> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^class JsonObject final : public Value<Json::OBJECT, Json::object> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^class JsonString final : public Value<Json::STRING, string> {$/;"	c	namespace:json11	file:
final	json11/json11.cpp	/^struct JsonParser final {$/;"	s	namespace:json11::__anon15	file:
final	json11/json11.hpp	/^class Json final {$/;"	c	namespace:json11
final	libstar/xhash.c	127;"	d	file:
find	myjson/json.h	/^	json_t *find(const string name, int opt = 0)$/;"	f	class:json
find	myjson/json2.c	/^json json::find(const string name, const string opt)$/;"	f	class:json
find_at	myjson/json.h	/^	string find_at(const string jsonstr, const string name, const int nth)$/;"	f	class:json
find_value	myjson/json.h	/^	string find_value(const string name, int opt = 0)$/;"	f	class:json
findaddr	libstar/gwauto.c	/^static	int	findaddr(uint *addrlist, int naddr, uint targetaddr)$/;"	f	file:
findentry	libstar/hash.h	/^	int             findentry;	\/\/ hash_find() \/ hash_findnext()$/;"	m	struct:__anon42
findippair	libstar/gwauto.c	/^static	int	findippair(hash_t *ht, uint srcaddr, uint dstaddr)$/;"	f	file:
findnode	libstar/hash.h	/^	struct hashentry *findnode;	\/\/ hash_find()로 검색된 현재 노드$/;"	m	struct:__anon42	typeref:struct:__anon42::hashentry
findportpair	libstar/gwauto.c	/^static	int	findportpair(hash_t *ht, uint srcport, uint dstport)$/;"	f	file:
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ SysUptime at start of flow$/;"	m	struct:__anon53
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ SysUptime at start of flow$/;"	m	struct:__anon55
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ SysUptime at start of flow$/;"	m	struct:__anon57
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ SysUptime at start of flow$/;"	m	struct:__anon59
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ sysUptime at start of flow$/;"	m	struct:struct_export_v8_1
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ sysUptime at start of flow$/;"	m	struct:struct_export_v8_2
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ sysUptime at start of flow$/;"	m	struct:struct_export_v8_3
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ sysUptime at start of flow$/;"	m	struct:struct_export_v8_4
first	libstar/nflowlib.h	/^	uint32		first;		\/\/ sysUptime at start of flow$/;"	m	struct:struct_export_v8_5
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_10
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_11
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_12
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_13
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_14
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_6
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_7
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_8
first	libstar/nflowlib.h	/^	uint32       first;	\/* SysUpTime at start of flow *\/$/;"	m	struct:struct_export_v8_9
first_next	libstar/xlist.h	/^	int		first_next;	\/\/ traverse시 first()..next()이면 1 last()..prev()이면 0$/;"	m	struct:__anon138
firstfind	libstar/vhash.h	/^	int		firstfind;$/;"	m	struct:__anon106
firstrecvtime	libstar/udp.h	/^	time32	firstrecvtime;		\/\/ 최초 수신 시각$/;"	m	struct:__anon104
five_min_cpu	libstar/sflowlib.h	/^	uint            five_min_cpu;	\/* 5 minute average CPU utilization *\/$/;"	m	struct:_SFLProcessor_counters
five_sec_cpu	libstar/sflowlib.h	/^	uint            five_sec_cpu;	\/* 5 second average CPU utilization *\/$/;"	m	struct:_SFLProcessor_counters
fix_traffic	libstar/snmpsub.c	/^static	void	fix_traffic(snmpif_t *curif, snmpif_t *oldif, float interval)$/;"	f	file:
fixdepth	myjson/json2.c	/^void json::fixdepth()$/;"	f	class:json
fixquote	libstar/xstr.c	/^_ALLOC	char	*fixquote(char *orgstr)$/;"	f
fixtraffic	libstar/snmpdef.h	/^	int		fixtraffic;		\/\/ 1이면 이상 트래픽 0으로 세팅 $/;"	m	struct:__anon77
fixtraffic	libstar/snmpdef.h	/^	int	fixtraffic;		\/\/ 1이면 이상 트래픽 0으로 세팅 $/;"	m	struct:__anon78
fixtraffic	libstar/xnms.h	/^	int		fixtraffic;		\/\/ 이상 트래픽인 경우 fix.$/;"	m	struct:xnmsnode
fixtraffic	libstar/xsnmp.h	/^	int		fixtraffic;		\/\/ 이상 트래픽인 경우 fix$/;"	m	struct:__anon158
fixunit	libstar/xstr.c	/^char	*fixunit(double data, char *format, char *buf)$/;"	f
flag	libstar/dvdlib.h	/^	int		flag;			\/\/ hash에서 사용 $/;"	m	struct:__anon32
flag	libstar/vhash.h	/^	uchar		flag;$/;"	m	struct:vhashentry
flag	libstar/xping.h	/^	int		flag;			\/\/ F_PING_xxx$/;"	m	struct:xping
flags	libstar/netbios.c	/^	ushort		flags;$/;"	m	struct:__anon47	file:
flags	libstar/netbios.c	/^	ushort		flags;$/;"	m	struct:__anon48	file:
flags1	libstar/nflowlib.h	/^	uint8		flags1;		\/\/ Flags indicating, among other things, what flow fields are invalid.$/;"	m	struct:__anon59
flags2	libstar/nflowlib.h	/^	uint16		flags2;		\/\/ Flags indicating, among other things, what flows are invalid.$/;"	m	struct:__anon59
flowType	libstar/sflowlib.h	/^	SFLFlow_type    flowType;$/;"	m	struct:_SFLFlow_sample_element
flow_callback_t	libstar/xflowlib.h	/^typedef void (*flow_callback_t) (xflow_t *xfp, xflow_rawdata_t *rawp, int nthentry);$/;"	t
flow_id	libstar/nflowlib.h	/^	uint16       flow_id;	\/* 0 *\/$/;"	m	struct:template_hdr_v9
flow_id	libstar/nflowlib.h	/^	uint16       flow_id;	\/* >= 256 *\/$/;"	m	struct:data_hdr_v9
flow_len	libstar/nflowlib.h	/^	uint16       flow_len;$/;"	m	struct:data_hdr_v9
flow_len	libstar/nflowlib.h	/^	uint16       flow_len;$/;"	m	struct:template_hdr_v9
flow_rawcallback_t	libstar/xflowlib.h	/^typedef void (*flow_rawcallback_t) (xflow_t *xfp, uint routeraddr, int export_ver, int entry_count, void *rawdata, uint size);$/;"	t
flow_sequence	libstar/nflowlib.h	/^	uint32		flow_sequence;	\/\/  sequence number$/;"	m	struct:__anon54
flow_sequence	libstar/nflowlib.h	/^	uint32		flow_sequence;	\/\/  sequence number$/;"	m	struct:__anon58
flow_sequence	libstar/nflowlib.h	/^	uint32		flow_sequence;	\/\/ seq counter of total flows seen$/;"	m	struct:__anon56
flow_sequence	libstar/nflowlib.h	/^	uint32		flow_sequence;	\/\/ sequence number$/;"	m	struct:__anon60
flows	libstar/nflowlib.h	/^	uint32		flows;		\/\/ number of flows$/;"	m	struct:struct_export_v8_1
flows	libstar/nflowlib.h	/^	uint32		flows;		\/\/ number of flows$/;"	m	struct:struct_export_v8_2
flows	libstar/nflowlib.h	/^	uint32		flows;		\/\/ number of flows$/;"	m	struct:struct_export_v8_3
flows	libstar/nflowlib.h	/^	uint32		flows;		\/\/ number of flows$/;"	m	struct:struct_export_v8_4
flows	libstar/nflowlib.h	/^	uint32		flows;		\/\/ number of flows$/;"	m	struct:struct_export_v8_5
flows	libstar/nflowlib.h	/^	uint32       flows;	\/* Number of flows *\/$/;"	m	struct:struct_export_v8_10
flows	libstar/nflowlib.h	/^	uint32       flows;	\/* Number of flows *\/$/;"	m	struct:struct_export_v8_11
flows	libstar/nflowlib.h	/^	uint32       flows;	\/* Number of flows *\/$/;"	m	struct:struct_export_v8_12
flows	libstar/nflowlib.h	/^	uint32       flows;	\/* Number of flows *\/$/;"	m	struct:struct_export_v8_13
flows	libstar/nflowlib.h	/^	uint32       flows;	\/* Number of flows *\/$/;"	m	struct:struct_export_v8_14
flows	libstar/nflowlib.h	/^	uint32       flows;	\/* Number of flows *\/$/;"	m	struct:struct_export_v8_9
flows	libstar/xflowlib.h	/^	int		flows;		\/\/ Collector로 유입되는 flow에 대한 통계 데이터 보관용 $/;"	m	struct:__anon130
flows	libstar/xflowlib.h	/^	uint32		flows;$/;"	m	struct:__anon129
flowtype	libstar/xflowlib.h	/^	int		flowtype;	\/\/ XFLOW_TYPE_NETFLOW \/ XFLOW_TYPE_SFLOW$/;"	m	struct:xflow
flowtype	libstar/xflowlib.h	/^	int	flowtype;		\/\/ 'N'==NetFlow 'S'==SFLOW$/;"	m	struct:__anon128
footer	libstar/netbios.c	/^	nbname_response_footer_t *footer;$/;"	m	struct:__anon50	file:
forwDatagrams	libstar/snmpdef.h	/^	uint	forwDatagrams;$/;"	m	struct:__anon81
forwarding	libstar/snmpdef.h	/^	int	forwarding;$/;"	m	struct:__anon81
fps	libstar/xflowlib.h	/^	int		fps;		\/\/ 초당 처리한 flow entry 수$/;"	m	struct:__anon130
fpsbytes	libstar/xflowlib.h	/^	float		fpsbytes;$/;"	m	struct:__anon130
frag	libstar/sflowlib.h	/^    } frag;			\/* path mtu discovery *\/$/;"	m	union:icmphdr::__anon67	typeref:struct:icmphdr::__anon67::__anon69
fragCreates	libstar/snmpdef.h	/^	uint	fragCreates;$/;"	m	struct:__anon81
fragFails	libstar/snmpdef.h	/^	uint	fragFails;$/;"	m	struct:__anon81
fragOKs	libstar/snmpdef.h	/^	uint	fragOKs;$/;"	m	struct:__anon81
frag_off	libstar/sflowlib.h	/^    uint16_t frag_off;$/;"	m	struct:iphdr
fraglen	libstar/xpcap.h	/^	int		fraglen;$/;"	m	struct:__anon153
fraglist	libstar/xpcap.h	/^	void		*fraglist;		\/\/ 재조립을 위한 데이터.. $/;"	m	struct:__anon153
fragoffset	libstar/xpcap.h	/^	int		fragoffset;		\/\/ Fragmentation에서 위치 $/;"	m	struct:__anon153
frame_length	libstar/sflowlib.h	/^	uint            frame_length;	\/\/ Original length of packet before sampling $/;"	m	struct:_SFLSampled_header
free_memory	libstar/sflowlib.h	/^	uint64          free_memory;	\/* free memory (in bytes) *\/$/;"	m	struct:_SFLProcessor_counters
free_ncbs	libstar/netbios.c	/^	ushort		free_ncbs;$/;"	m	struct:__anon49	file:
free_shmem	libstar/shmem.c	/^void	free_shmem(key_t key, uint size)$/;"	f
freekb	libstar/dvdlib.h	/^	uint		rec_count, freekb, totalkb;	\/\/ 현재 DVD에 대한 기록 카운트, 여유용량, 전체용량$/;"	m	struct:__anon33
frmps_received	libstar/netbios.c	/^	ushort		frmps_received;$/;"	m	struct:__anon49	file:
frmps_transmitted	libstar/netbios.c	/^	ushort		frmps_transmitted;$/;"	m	struct:__anon49	file:
from	libstar/re.h	/^	int		from, to;$/;"	m	struct:__anon66
from	libstar/ssmtplib.h	/^	char		from[80];$/;"	m	struct:__anon103
fromaddr	hdaclib.h	/^	char	fromaddr[HDAC_ADDR_LEN];	\/\/ from address$/;"	m	struct:__anon8
fromaddr	hdaclib.h	/^	char	fromaddr[HDAC_ADDR_LEN];$/;"	m	struct:__anon3
fseek64	libstar/xutil.c	/^off64_t	fseek64(FILE *fp, off64_t offset, int whence)$/;"	f
fsize	libstar/xdebug.c	/^	float	fsize;			\/\/ 할당된 용량 $/;"	m	struct:__anon121	file:
fsize64	libstar/xutil.c	/^off64_t	fsize64(FILE *fp)$/;"	f
ftell64	libstar/xutil.c	/^off64_t	ftell64(FILE *fp)$/;"	f
ftp_closedata	libstar/ftp.c	/^int	ftp_closedata(xftp_t *ftp)$/;"	f
ftp_command	libstar/ftp.c	/^int	ftp_command(xftp_t *ftp, char *command)$/;"	f
ftp_free	libstar/xapp.h	92;"	d
ftp_get	libstar/ftp.c	/^int	ftp_get(xftp_t *ftp, char *remotename, char *localname, int binary)$/;"	f
ftp_init	libstar/ftp.c	/^xftp_t	*ftp_init(char *url, int port, char *userid, char *passwd, char *opt)$/;"	f
ftp_login	libstar/ftp.c	/^int	ftp_login(xftp_t *ftp, char *userid, char *passwd)$/;"	f
ftp_modename	libstar/ftp.c	/^const	char	*ftp_modename(int mode)$/;"	f
ftp_opendata	libstar/ftp.c	/^int	ftp_opendata(xftp_t *ftp, char *remotename, int mode)$/;"	f
ftp_put	libstar/ftp.c	/^int	ftp_put(xftp_t *ftp, char *localname, char *remotename, int binary)$/;"	f
ftp_recv	libstar/ftp.c	/^int	ftp_recv(xftp_t *ftp, void *buf, int buflen)$/;"	f
ftp_send	libstar/ftp.c	/^int	ftp_send(xftp_t *ftp, void *buf, int buflen)$/;"	f
ftp_waitstr	libstar/ftp.c	/^void	ftp_waitstr(xftp_t *ftp, char *str)$/;"	f
fullend	libstar/xutil.h	/^	char		*fullend;			\/\/ fullname 중에서 path 위치..$/;"	m	struct:__anon180
fullname	libstar/xutil.h	/^	char		fullname[512];$/;"	m	struct:__anon180
func	libstar/lock.h	/^	char		func[16];		\/\/ 세부 기능제어용 (미정의)$/;"	m	struct:__anon44
func	libstar/xdebug.h	/^	char	func[100];$/;"	m	struct:__anon124
fwver	libstar/xnms.h	/^	char		fwver[40];		\/\/ .19	\/\/ Firmware version$/;"	m	struct:__anon148
gTestVectors	lib/test_hashlib.c	/^static TestVector gTestVectors [] = $/;"	v	file:
gateway	libstar/sflowlib.h	/^	SFLExtended_gateway gateway;$/;"	m	union:_SFLFlow_type
gateway	libstar/sflowlib.h	/^    uint32_t	gateway;	\/* gateway address *\/$/;"	m	union:icmphdr::__anon67
gateway	libstar/xsock.h	/^	char		gateway[20];$/;"	m	struct:__anon166
generic	libstar/sflowlib.h	/^	SFLIf_counters  generic;$/;"	m	union:_SFLCounters_type
genserial	libstar/lock.c	/^void	genserial(char *result, char *passwd, char *mac, char *hwserial, char *swserial)$/;"	f
get	contract.c	/^int	hdac_contract::get(const char *type)$/;"	f	class:hdac_contract
get	json2.h	/^	json get(const int nth)	{ return operator [](nth); }$/;"	f	class:json
get	myjson/json.h	/^	json_t *get()$/;"	f	class:json
get	myjson/json.h	/^	json_t *get(const int nth)$/;"	f	class:json
get	myjson/json.h	/^	json_t *get(const string name)$/;"	f	class:json
get	myjson/json2.h	/^	json get(const int nth)	{ return operator [](nth); }$/;"	f	class:json
get16bits	libstar/fhash.c	51;"	d	file:
get16bits	libstar/fhash.c	54;"	d	file:
get16bits	libstar/fhash.c	58;"	d	file:
get16bits	libstar/hash.c	75;"	d	file:
get16bits	libstar/hash.c	78;"	d	file:
get16bits	libstar/hash.c	82;"	d	file:
get16bits	libstar/shash.c	54;"	d	file:
get16bits	libstar/shash.c	57;"	d	file:
get16bits	libstar/shash.c	61;"	d	file:
get16bits	libstar/vhash.c	67;"	d	file:
get16bits	libstar/vhash.c	70;"	d	file:
get16bits	libstar/vhash.c	74;"	d	file:
getAddress	libstar/sflowlib.c	/^uint getAddress(SFSample * sample, SFLAddress * address)$/;"	f
getData32	libstar/sflowlib.c	/^uint getData32(SFSample * sample)$/;"	f
getData32_nobswap	libstar/sflowlib.c	/^uint getData32_nobswap(SFSample * sample)$/;"	f
getString	libstar/sflowlib.c	/^uint getString(SFSample * sample, char *buf, int bufLen)$/;"	f
get_all_inf	libstar/xnms.h	/^	int		get_all_inf;		\/\/ 1이면 모든 인터페이스 정보 수집..(snmpwalk처럼)$/;"	m	struct:xnmsnode
get_homedir	libstar/xutil.c	/^char	*get_homedir(char *cmdpath)$/;"	f
get_limit	rpc.h	/^	hdac_send_limit_t *get_limit(const char *name)$/;"	f	class:hdac
get_max_prime	libstar/shash.c	/^int	get_max_prime(int num)$/;"	f
get_next_token	json11/json11.cpp	/^    char get_next_token() {$/;"	f	struct:json11::__anon15::final
get_node_model	libstar/xsnmptype.c	/^int	get_node_model(char *ldescr, char *orgvendor, char *model)$/;"	f
get_node_type	libstar/xsnmptype.c	/^int	get_node_type(char *ldescr, char *type)$/;"	f
get_node_vendor	libstar/xsnmptype.c	/^int	get_node_vendor(char *ldescr, char *vendor)$/;"	f
get_node_version	libstar/xsnmptype.c	/^int	get_node_version(char *ldescr, char *version)$/;"	f
get_private_oid_data	libstar/xsnmptrap.c	/^privoid_t	*get_private_oid_data(char *oidstr, char *datastr)$/;"	f
get_range	myjson/json.h	/^	json_t *get_range(int from, int nitem)$/;"	f	class:json
get_range_value	myjson/json.h	/^	string get_range_value(int from, int nitem)$/;"	f	class:json
get_shmem	libstar/shmem.c	/^void	*get_shmem(key_t key, uint size, int create)$/;"	f
get_value	myjson/json.h	/^	string get_value(const int nth)$/;"	f	class:json
get_value	myjson/json.h	/^	string get_value(const string name)$/;"	f	class:json
getaccount	rpc.h	/^	string getaccount(const char *addr)$/;"	f	class:hdac
getaccountaddress	rpc.h	/^	string getaccountaddress(const char *account)$/;"	f	class:hdac
getaddednodeinfo	rpc.h	/^	string getaddednodeinfo(const bool dns, const char *node = "")$/;"	f	class:hdac
getaddressbalances	rpc.h	/^	string getaddressbalances(const char *addr, const int minconf = 1, const bool includeLocked = false)$/;"	f	class:hdac
getaddresses	rpc.h	/^	string getaddresses(const bool verbose = false)$/;"	f	class:hdac
getaddressesbyaccount	rpc.h	/^	string getaddressesbyaccount(const char *account)$/;"	f	class:hdac
getaddresstx	rpc.h	/^	string getaddresstx(const char *addr, const char *txid, const bool verbose = false)$/;"	f	class:hdac
getassetbalances	rpc.h	/^	string getassetbalances(const char *account, const int minconf = 1, const bool includeWatchonly = false, const bool includeLocked = false)$/;"	f	class:hdac
getassettx	rpc.h	/^	string getassettx(const char *asset_id, const char *txid, const bool verbose = false)$/;"	f	class:hdac
getbalance	rpc.h	/^	string getbalance(const char *account = "", const int minconf = 1, const bool includeWatchonly = false)$/;"	f	class:hdac
getbestblockhash	rpc.h	/^	string getbestblockhash()$/;"	f	class:hdac
getblock	rpc.h	/^	string getblock(const uint32_t height, const int verbose = 1)$/;"	f	class:hdac
getblockbyhash	rpc.h	/^	string getblockbyhash(const char *hash, const int verbose = 1)$/;"	f	class:hdac
getblockchaininfo	rpc.h	/^	string getblockchaininfo()$/;"	f	class:hdac
getblockchainparams	rpc.h	/^	string getblockchainparams(const bool displaynames = true, const bool with_upgrades = true)$/;"	f	class:hdac
getblockcount	rpc.h	/^	string getblockcount()$/;"	f	class:hdac
getblockhash	rpc.h	/^	string getblockhash(const uint32_t index)$/;"	f	class:hdac
getblocktemplate	rpc.h	/^	string getblocktemplate(const char *jsonobj)$/;"	f	class:hdac
getblockwindowsize	rpc.h	/^	string getblockwindowsize()$/;"	f	class:hdac
getchaintips	rpc.h	/^	string getchaintips()$/;"	f	class:hdac
getconnectioncount	rpc.h	/^	string getconnectioncount()$/;"	f	class:hdac
getday	libstar/xtime.h	96;"	d
getdebugopt	libstar/xdebug.h	68;"	d
getdifficulty	rpc.h	/^	string getdifficulty()$/;"	f	class:hdac
getgenerate	rpc.h	/^	string getgenerate()$/;"	f	class:hdac
gethashespersec	rpc.h	/^	string gethashespersec()$/;"	f	class:hdac
gethhmmss	libstar/xtime.h	103;"	d
gethostaddr	libstar/xsock.c	/^uint	gethostaddr(char *hostname)$/;"	f
gethostmac	libstar/xsock.c	/^char	*gethostmac(char *buf, const char *ipaddr)$/;"	f
gethostnamebyaddr	libstar/xsock.c	/^char	*gethostnamebyaddr(uint addr, char *buf)$/;"	f
gethour	libstar/xtime.h	97;"	d
gethweekname	libstar/xtime.c	/^const char	*gethweekname(int wday)$/;"	f
getifinfo	libstar/xsock.c	/^xifinfo_t	*getifinfo()$/;"	f
getiflist	libstar/xnms.h	/^	int		getiflist[MAX_NODE_IF];	\/\/ 실제 정보를 수집하기 위한 I\/F 리스트 여기 기술된 I\/F에 대한 정보만 수집된다.$/;"	m	struct:xnmsnode
getinfo	rpc.h	/^	string getinfo()$/;"	f	class:hdac
getitem	libstar/xsock.c	/^static	char	*getitem(char *buf, const char *ptn)$/;"	f	file:
getlastindex	myjson/json2.c	/^int json::getlastindex(int fromidx)$/;"	f	class:json
getlogdata	libstar/xdebug.c	/^logdata_t	*getlogdata(char *logfile)$/;"	f
getmempoolinfo	rpc.h	/^	string getmempoolinfo()$/;"	f	class:hdac
getmin	libstar/xtime.h	98;"	d
getmininginfo	rpc.h	/^	string getmininginfo()$/;"	f	class:hdac
getmonth	libstar/xtime.h	93;"	d
getmonthname	libstar/xtime.c	/^const char	*getmonthname(int month, int len)$/;"	f
getmultibalances	rpc.h	/^	string getmultibalances(const char *addr = "", const char *assets = "*", const int minconf = 1, const bool includeLocked = false, const bool includeWatchonly = false)$/;"	f	class:hdac
getname	myjson/json.h	/^	string getname()$/;"	f	class:json
getnettotals	rpc.h	/^	string getnettotals()$/;"	f	class:hdac
getnetworkhashps	rpc.h	/^	string getnetworkhashps(const int blocks = 120, const int height = -1)$/;"	f	class:hdac
getnetworkinfo	rpc.h	/^	string getnetworkinfo()$/;"	f	class:hdac
getnewaddress	rpc.h	/^	string getnewaddress(const char *account = "")$/;"	f	class:hdac
getnextidx	libstar/xnms.h	/^	int		getnextidx;		\/\/ GETNEXT로 입수된 데이터의 수$/;"	m	struct:xnmsnode
getnode	myjson/json2.c	/^jsonnode json::getnode(const int idx)$/;"	f	class:json
getoption	libstar/xdebug.h	66;"	d
getoptionstr	libstar/xdebug.h	67;"	d
getoptionvalue	libstar/xdebug.c	/^char	*getoptionvalue(char *name, char *default_value)$/;"	f
getpeerinfo	rpc.h	/^	string getpeerinfo()$/;"	f	class:hdac
getrawchangeaddress	rpc.h	/^	string getrawchangeaddress()$/;"	f	class:hdac
getrawmempool	rpc.h	/^	string getrawmempool(const bool verbose = false)$/;"	f	class:hdac
getrawtx	rpc.h	/^	string getrawtx(const char *txid, const int verbose)$/;"	f	class:hdac
getreceivedbyaccount	rpc.h	/^	string getreceivedbyaccount(const char *account, const int minconf = 1)$/;"	f	class:hdac
getreceivedbyaddress	rpc.h	/^	string getreceivedbyaddress(const char *addr, const int minconf = 1)$/;"	f	class:hdac
getruntimeparams	rpc.h	/^	string getruntimeparams()$/;"	f	class:hdac
getsec	libstar/xtime.h	99;"	d
getsigname	libstar/xdebug.c	/^const char	*getsigname(int signo)$/;"	f
getstartindex	myjson/json2.c	/^int json::getstartindex(const int nth_item)$/;"	f	class:json
getstreamitem	rpc.h	/^	string getstreamitem(const char *stream_id, const char *txid, const bool verbose = false)$/;"	f	class:hdac
gettime	libstar/xsnmp.h	/^	time32		gettime;$/;"	m	struct:__anon159
gettimevalue	libstar/xtime.c	/^int	gettimevalue(time_t curtime, int type)$/;"	f
gettotalbalances	rpc.h	/^	string gettotalbalances(const int minconf = 1, const bool includeWatchonly = false, const bool includeLocked = false)$/;"	f	class:hdac
gettx	rpc.h	/^	string gettx(const char *txid, const bool includeWatchonly = false)$/;"	f	class:hdac
gettxout	rpc.h	/^	string gettxout(const char *txid, const uint32_t nvout, const bool includemempool = false)$/;"	f	class:hdac
gettxoutdata	rpc.h	/^	string gettxoutdata(const char *txid, const int vout, const long int count_bytes = INT_MAX, const int start_byte = 0)$/;"	f	class:hdac
gettxoutsetinfo	rpc.h	/^	string gettxoutsetinfo()$/;"	f	class:hdac
getunconfirmedbalance	rpc.h	/^	string getunconfirmedbalance()$/;"	f	class:hdac
getwalletinfo	rpc.h	/^	string getwalletinfo()$/;"	f	class:hdac
getwallettx	rpc.h	/^	string getwallettx(const char *txid, const bool includeWatchonly = false, const bool verbose = false)$/;"	f	class:hdac
getwday	libstar/xtime.h	95;"	d
getweekname	libstar/xtime.c	/^const char	*getweekname(int wday, int len)$/;"	f
getwinitem	libstar/xsock.c	/^static	char	*getwinitem(char *buf, char *ptn)$/;"	f	file:
getxprof	libstar/xtime.c	/^static	xprofclk_t	*getxprof(char *id)$/;"	f	file:
getyday	libstar/xtime.h	94;"	d
getyear	libstar/xtime.h	92;"	d
getyymmdd	libstar/xtime.h	102;"	d
getyyyymmdd	libstar/xtime.h	101;"	d
gotIPV4	libstar/sflowlib.h	/^	int             gotIPV4;$/;"	m	struct:_SFSample
gotIPV6	libstar/sflowlib.h	/^	int             gotIPV6;$/;"	m	struct:_SFSample
gotxtable	libstar/snmpdef.h	/^	int	gotxtable;		\/\/ XTable 정보 수집을 해서 계산한 경우는 1 $/;"	m	struct:__anon78
grant	rpc.h	/^	string grant(const char *addrs, const char *perms, const double native_amount = 0.0, const int startblock = 0, const int endblock = 4294967295, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
grant_contract	contract.c	/^int	hdac_admin::grant_contract(const char *stream, const char *sender, const char *handler)$/;"	f	class:hdac_admin
grant_contract	contract.c	/^int	hdac_admin::grant_contract(const hdac_map_t *map)$/;"	f	class:hdac_admin
grantfrom	rpc.h	/^	string grantfrom(const char *fromaddr, const char *toaddrs, const char *perms, const double native_amount = 0.0, const int startblock = 0, const int endblock = 4294967295, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
grantwithdata	rpc.h	/^	string grantwithdata(const char *addrs, const char *perms, const char *data, int datalen = 0, const double native_amount = 0.0, const int startblock = 0, const int endblock = 4294967295)$/;"	f	class:hdac
grantwithdatafrom	rpc.h	/^	string grantwithdatafrom(const char *fromaddr, const char *toaddrs, const char *perms, const char *data, int datalen = 0, const double native_amount = 0.0, const int startblock = 0, const int endblock = 4294967295)$/;"	f	class:hdac
grhealthurl	libstar/snmpdef.h	/^	char		grhealthurl[40];$/;"	m	struct:__anon95
grindex	libstar/snmpdef.h	/^	int		grindex;$/;"	m	struct:__anon95
grmetric	libstar/snmpdef.h	/^	char		grmetric[20];$/;"	m	struct:__anon95
grname	libstar/snmpdef.h	/^	char		grname[40];$/;"	m	struct:__anon95
group	libstar/snmpdef.h	/^	l4sess_group_t	group;			\/\/ 그룹 정보 $/;"	m	struct:__anon96
groupip	libstar/udp.h	/^	char	groupip[20];		\/\/ 멀티캐스팅 그룹 IP$/;"	m	struct:__anon104
groupname	hdaclib.h	/^	char	groupname[128];		\/\/ group name$/;"	m	struct:__anon6
groupname	hdaclib.h	/^	char	groupname[128];		\/\/ group name$/;"	m	struct:__anon7
gwcallback	libstar/gwcommon.c	/^static	void	gwcallback(struct xsocket *sock, int event, char *buf, int buflen)$/;"	f	file:
gwcallback_t	libstar/gw.h	/^typedef void	(*gwcallback_t) (xsock_t *sock, int event, char *buf, int buflen);$/;"	t
gwclientstart	libstar/gwcli.c	/^xsock_t	*gwclientstart(sockcallback_t cbfunc, uint remoteaddr, int remoteport)$/;"	f
gwclientstop	libstar/gwcli.c	/^void	gwclientstop()$/;"	f
gwevtype	libstar/gwcommon.c	/^char	*gwevtype(uint event)$/;"	f
gwgetheader	libstar/gwcommon.c	/^gwheader_t *gwgetheader(gwheader_t *gwhp, uint dsttype, uint *addrlist, int numaddr)$/;"	f
gwhash	libstar/gw.h	/^	hash_t	*gwhash;		\/\/ 이 Gateway에서 연결되는 gateway list..$/;"	m	struct:gwinfo
gwheader_t	libstar/gw.h	/^}	gwheader_t;$/;"	t	typeref:struct:__anon38
gwheadermax_t	libstar/gw.h	/^}	gwheadermax_t;$/;"	t	typeref:struct:__anon39
gwinfo	libstar/gw.h	/^typedef struct gwinfo {$/;"	s
gwinfo_t	libstar/gw.h	/^}	gwinfo_t;$/;"	t	typeref:struct:gwinfo
gwloadconfig	libstar/gwcommon.c	/^int	gwloadconfig(char *conffile, xgwrule_t *gwrulelist, int maxgwrule)$/;"	f
gwnotify	libstar/gwauto.c	/^int	gwnotify(xsock_t *sock, uint dsttype)$/;"	f
gwportclose	libstar/gwsvr.c	/^static	void	gwportclose(xgwrule_t *gwp)$/;"	f	file:
gwrecv	libstar/gwcommon.c	/^void	*gwrecv(xsock_t *sock, gwheadermax_t *rethp, int timeoutMS)$/;"	f
gwrule	libstar/gw.h	/^	xgwrule_t *gwrule;$/;"	m	struct:gwinfo
gwrule	libstar/gw.h	/^typedef struct gwrule {$/;"	s
gwsend	libstar/gwcommon.c	/^int	gwsend(xsock_t *sock, gwheader_t *hp, void *data, int datalen)$/;"	f
gwserverstart	libstar/gwsvr.c	/^int	gwserverstart(xgwrule_t *gwrule, int ngwrule)$/;"	f
gwserverstop	libstar/gwsvr.c	/^void	gwserverstop(int localport)$/;"	f
gwsetcallback	libstar/gwcommon.c	/^void	gwsetcallback(gwcallback_t callback)$/;"	f
gwsettype	libstar/gwcommon.c	/^void	gwsettype(int type)$/;"	f
gwstart	libstar/gwauto.c	/^int	gwstart(xgwrule_t *gwrulelist, int ngwrule)$/;"	f
gwstop	libstar/gwauto.c	/^void	gwstop()$/;"	f
gwtype	libstar/gw.h	/^	int	gwtype;			\/\/ GW_GATEWAY, GW_AGENT, GW_MANAGER... (모든 엔트리 동일)$/;"	m	struct:gwinfo
gwtype	libstar/gwcommon.c	/^const	char	*gwtype(uint type)$/;"	f
hThread	libstar/thrpool.h	/^	HANDLE		hThread;$/;"	m	struct:thrdata
hThread	libstar/thrpool.h	/^	int		hThread;	\/\/ 구조체 size 맞추기.$/;"	m	struct:thrdata
hWNASPI32	libstar/dvdlib.c	/^static HINSTANCE hWNASPI32;$/;"	v	file:
hWNASPI32	libstar/oddlibwin.c	/^static HINSTANCE hWNASPI32;$/;"	v	file:
handler	contract.h	/^	char	handler[HDAC_ADDR_LEN];		\/\/ contract handler, receive address$/;"	m	struct:__anon1
has_data	libstar/ocilib.h	/^	unsigned	has_data:1;	\/* statement has more data flag *\/ $/;"	m	struct:ocistmt
has_shape	json11/json11.cpp	/^bool Json::has_shape(const shape & types, string & err) const$/;"	f	class:json11::Json
hash_delete	libstar/hash.c	/^void	hash_delete(hashent_t *he)$/;"	f
hash_deleteall	libstar/hash.c	/^void	hash_deleteall(hash_t *ht)$/;"	f
hash_dump	libstar/hash.c	/^void	hash_dump(hash_t *ht)$/;"	f
hash_fast_func	libstar/hash.c	/^uint32	hash_fast_func(const char *data, size_t len)$/;"	f
hash_find	libstar/hash.c	/^hashent_t	*hash_find(hash_t *ht, void *key, int keylen)$/;"	f
hash_findloop	libstar/hash.c	/^hashent_t	*hash_findloop(hash_t *ht, hashloop_t *lp, void *key, int keylen)$/;"	f
hash_findnext	libstar/hash.c	/^hashent_t	*hash_findnext(hash_t *ht, hashloop_t *lp)$/;"	f
hash_findsub	libstar/hash.c	/^static hashent_t	*hash_findsub(register hash_t *ht, hashloop_t *lp, void *key, int keylen, uint hashval)$/;"	f	file:
hash_first	libstar/hash.c	/^hashent_t	*hash_first(hash_t *ht, hashloop_t *lp)$/;"	f
hash_free	libstar/hash.h	104;"	d
hash_func	libstar/hash.c	/^uint	hash_func(const void *key, size_t len)$/;"	f
hash_getdata	libstar/hash.c	/^void	*hash_getdata(register hashent_t *he, int *datalen)$/;"	f
hash_getdepth	libstar/hash.c	/^uint	hash_getdepth(register hash_t *ht)$/;"	f
hash_getkey	libstar/hash.c	/^void	*hash_getkey(register hashent_t *he, int *keylen)$/;"	f
hash_getsize	libstar/hash.c	/^int	hash_getsize(hash_t *ht)$/;"	f
hash_init	libstar/hash.h	100;"	d
hash_insert	libstar/hash.h	112;"	d
hash_lock	libstar/hash.h	107;"	d
hash_next	libstar/hash.c	/^hashent_t	*hash_next(register hash_t *ht, hashloop_t *lp)$/;"	f
hash_resize	libstar/hash.c	/^static	void	hash_resize(hash_t *ht, int newtablesize)$/;"	f	file:
hash_savedata	libstar/hash.c	/^void	hash_savedata(register hashent_t *he, void *val, int len)$/;"	f
hash_setdata	libstar/hash.c	/^void	hash_setdata(register hashent_t *he, void *val, int len)$/;"	f
hash_setsize	libstar/hash.c	/^int	hash_setsize(hash_t *ht, int newtablesize)$/;"	f
hash_t	libstar/hash.h	/^}	hash_t;$/;"	t	typeref:struct:__anon41
hash_unlock	libstar/hash.h	108;"	d
hash_update	libstar/hash.h	113;"	d
hashbig	libstar/xhash.c	/^uint32_t hashbig( const void *key, size_t length, uint32_t initval)$/;"	f
hashbig2	libstar/xhash.c	/^void	hashbig2($/;"	f
hashdata_t	libstar/xdebug.c	/^}	hashdata_t;$/;"	t	typeref:struct:__anon120	file:
hashed	hdaclib.h	/^	int	hashed[MAX_AUTH_DATA];$/;"	m	struct:__anon5
hashent_t	libstar/hash.h	/^}	hashent_t;$/;"	t	typeref:struct:hashentry
hashentry	libstar/hash.h	/^typedef struct hashentry {$/;"	s
hashf	libstar/hash.h	/^	uint		(*hashf)(const void *, size_t);$/;"	m	struct:__anon41
hashfp	libstar/fhash.h	/^	FILE		*hashfp;$/;"	m	struct:__anon35
hashlittle	libstar/xhash.c	/^uint32_t hashlittle( const void *key, size_t length, uint32_t initval)$/;"	f
hashlittle2	libstar/xhash.c	/^void hashlittle2( $/;"	f
hashloc	libstar/fhash.h	/^	char		hashloc[200];$/;"	m	struct:__anon35
hashloc	libstar/hash.h	/^	char		hashloc[128];$/;"	m	struct:__anon41
hashloc	libstar/shash.h	/^	char		hashloc[200];$/;"	m	struct:__anon71
hashloc	libstar/vhash.h	/^	char		hashloc[200];$/;"	m	struct:__anon105
hashloop_t	libstar/hash.h	/^}	hashloop_t;$/;"	t	typeref:struct:__anon42
hashmask	libstar/xhash.c	44;"	d	file:
hashname	libstar/fhash.h	/^	char		hashname[64];$/;"	m	struct:__anon35
hashname	libstar/hash.h	/^	char		hashname[40];$/;"	m	struct:__anon41
hashname	libstar/shash.h	/^	char		hashname[64];$/;"	m	struct:__anon71
hashname	libstar/vhash.h	/^	char		hashname[64];$/;"	m	struct:__anon105
hashsize	libstar/xdb.h	/^	int		hashsize;	\/\/ vhash 할당시 테이블 블록 크기 $/;"	m	struct:__anon118
hashsize	libstar/xhash.c	43;"	d	file:
hashval	libstar/hash.h	/^	uint    	hashval;	\/\/ 0 ~ 2^32$/;"	m	struct:hashentry
hashval	libstar/vhash.h	/^	uint    	hashval;	\/\/ 0 ~ 2^32$/;"	m	struct:vhashentry
hashword	libstar/xhash.c	/^uint32_t	hashword($/;"	f
hashword2	libstar/xhash.c	/^void	hashword2 ($/;"	f
hasthr	hvm.c	/^	int	hasthr;$/;"	m	struct:__anon11	file:
hdac	contract.h	/^	hdac_t		*hdac;$/;"	m	class:hdac_contract
hdac	contract.h	/^	hdac_t	*hdac;$/;"	m	class:hdac_admin
hdac	node.h	/^	hdac_t	*hdac;$/;"	m	class:hdac_node
hdac	node.h	/^	hdac_t	*hdac;$/;"	m	class:hdac_virtual_device
hdac	rpc.h	/^	hdac(const char *nodeip, const int port, const char *userid, const char *password)$/;"	f	class:hdac
hdac	rpc.h	/^class hdac {$/;"	c
hdac_addmultisigaddress	rpc_wallet.cpp	/^char	*hdac_addmultisigaddress(hdac_t *hdac, const int nrequired, const char *keys, const char *account)$/;"	f
hdac_addnode	rpc_net.cpp	/^char	*hdac_addnode(hdac_t *hdac, const char *node, const char *op)$/;"	f
hdac_admin	contract.h	/^	hdac_admin()$/;"	f	class:hdac_admin
hdac_admin	contract.h	/^class hdac_admin$/;"	c
hdac_appendrawexchange	rpc_xch.cpp	/^char	*hdac_appendrawexchange(hdac_t *hdac, const char *hex, const char *txid, const int vout, const char *ask_assets)$/;"	f
hdac_auth2_delete	auth.c	/^int	hdac_auth2_delete(hdac_t *hdac, const char *id)$/;"	f
hdac_auth2_reg	auth.c	/^int	hdac_auth2_reg(hdac_t *hdac, hdac_auth2_t *authi, const char *opt)$/;"	f
hdac_auth2_t	hdaclib.h	/^}	hdac_auth2_t;$/;"	t	typeref:struct:__anon5
hdac_auth2_test	auth.c	/^int	hdac_auth2_test(hdac_t *hdac, hdac_auth2_t *authi)$/;"	f
hdac_auth_data2_t	hdaclib.h	/^}	hdac_auth_data2_t;$/;"	t	typeref:struct:__anon4
hdac_auth_delete	auth.c	/^int	hdac_auth_delete(hdac_t *hdac, const char *id)$/;"	f
hdac_auth_init	auth.c	/^int	hdac_auth_init(hdac_t *hdac, const hdac_auth_txdata_t *txdata)$/;"	f
hdac_auth_reg	auth.c	/^int	hdac_auth_reg(hdac_t *hdac, hdac_auth2_t *authi, const char *opt)$/;"	f
hdac_auth_test	auth.c	/^int	hdac_auth_test(hdac_t *hdac, hdac_auth2_t *authi)$/;"	f
hdac_auth_txdata_t	hdaclib.h	/^}	hdac_auth_txdata_t;$/;"	t	typeref:struct:__anon3
hdac_backupwallet	rpc_wallet.cpp	/^char	*hdac_backupwallet(hdac_t *hdac, const char *dest)$/;"	f
hdac_callback	hdaclib.c	/^static	size_t	hdac_callback(void *retdata, size_t size, size_t count, void *userdata)$/;"	f	file:
hdac_cert_doc_decode	doc_cert.c	/^int	hdac_cert_doc_decode(hdac_cert_find_t *findi, char *retstr)$/;"	f
hdac_cert_doc_find	doc_cert.c	/^hdac_cert_find_t	*hdac_cert_doc_find(hdac_t *hdac, hdac_cert_find_t *findi)$/;"	f
hdac_cert_doc_reg	doc_cert.c	/^hdac_cert_t	*hdac_cert_doc_reg(hdac_t *hdac, hdac_cert_t *certi)$/;"	f
hdac_cert_find_t	hdaclib.h	/^}	hdac_cert_find_t;$/;"	t	typeref:struct:__anon7
hdac_cert_t	hdaclib.h	/^}	hdac_cert_t;$/;"	t	typeref:struct:__anon6
hdac_check_send_stat	hdaclib.c	/^int	hdac_check_send_stat(hdac_t *hdac, const char *name, const int count, const double amount, const char *fromaddr, const char *toaddr, const char *jsonstr)$/;"	f
hdac_check_send_stat_asset	hdaclib.c	/^int	hdac_check_send_stat_asset(hdac_t *hdac, const char *asset_qty, const char *fromaddr, const char *toaddr, const char *jsonstr)$/;"	f
hdac_clearmempool	rpc_ctl.cpp	/^char	*hdac_clearmempool(hdac_t *hdac)$/;"	f
hdac_close	hdaclib.c	/^void	hdac_close(hdac_t *hdac)$/;"	f
hdac_cmd	hdaclib.c	/^char	*hdac_cmd(hdac_t *hdac, const char *orgdata)$/;"	f
hdac_cmp_send_limit	hdaclib.c	/^int	hdac_cmp_send_limit(hdac_t *hdac, hdac_send_limit_t *cmplp)$/;"	f
hdac_combineunspent	rpc_wallet.cpp	/^char	*hdac_combineunspent(hdac_t *hdac, const char *addr, const int minconf, const int maxcombines, const int mininputs, const int maxinputs, const int maxtime)$/;"	f
hdac_completerawexchange	rpc_xch.cpp	/^char	*hdac_completerawexchange(hdac_t *hdac, const char *hex, const char *txid, const int vout, const char *ask_assets, const char *data, int datalen)$/;"	f
hdac_contract	contract.h	/^	hdac_contract()$/;"	f	class:hdac_contract
hdac_contract	contract.h	/^class hdac_contract$/;"	c
hdac_create	rpc_stream.cpp	/^char	*hdac_create(hdac_t *hdac, const char *entity_type, const char *entity_name, const bool open, const char *custom_fields)$/;"	f
hdac_createfrom	rpc_stream.cpp	/^char	*hdac_createfrom(hdac_t *hdac, const char *from_addr, const char *entity_type, const char *entity_name, const bool open, const char *custom_fields)$/;"	f
hdac_createkeypairs	rpc_util.cpp	/^char	*hdac_createkeypairs(hdac_t *hdac, const int count)$/;"	f
hdac_createmultisig	rpc_msig.cpp	/^char	*hdac_createmultisig(hdac_t *hdac, const int nrequired, const char *keys)$/;"	f
hdac_createrawexchange	rpc_xch.cpp	/^char	*hdac_createrawexchange(hdac_t *hdac, const char *txid, const int vout, const char *ask_assets)$/;"	f
hdac_createrawsendfrom	rpc_msig.cpp	/^char	*hdac_createrawsendfrom(hdac_t *hdac, const char *from_addr, const char *json_data, const char *data, const char *action)$/;"	f
hdac_decoderawexchange	rpc_xch.cpp	/^char	*hdac_decoderawexchange(hdac_t *hdac, const char *tx_hex, const bool verbose)$/;"	f
hdac_decoderawtx	rpc_xch.cpp	/^char	*hdac_decoderawtx(hdac_t *hdac, const char *tx_hex)$/;"	f
hdac_disablerawtx	rpc_xch.cpp	/^char	*hdac_disablerawtx(hdac_t *hdac, const char *tx_hex)$/;"	f
hdac_dumpprivkey	rpc_wallet.cpp	/^char	*hdac_dumpprivkey(hdac_t *hdac, const char *addr)$/;"	f
hdac_dumpwallet	rpc_wallet.cpp	/^char	*hdac_dumpwallet(hdac_t *hdac, const char *filename)$/;"	f
hdac_encryptwallet	rpc_wallet.cpp	/^char	*hdac_encryptwallet(hdac_t *hdac, const char *passphrase)$/;"	f
hdac_estimatefee	rpc_util.cpp	/^char	*hdac_estimatefee(hdac_t *hdac, const int nblocks)$/;"	f
hdac_estimatepriority	rpc_util.cpp	/^char	*hdac_estimatepriority(hdac_t *hdac, const int nblocks)$/;"	f
hdac_get_permission	contract.c	/^string	hdac_get_permission(hdac_t *hdac, const char *perm, const char *sender)$/;"	f
hdac_get_send_limit	hdaclib.c	/^hdac_send_limit_t	*hdac_get_send_limit(hdac_t *hdac, const char *name, int *retcount)$/;"	f
hdac_getaccount	rpc_wallet.cpp	/^char	*hdac_getaccount(hdac_t *hdac, const char *addr)$/;"	f
hdac_getaccountaddress	rpc_wallet.cpp	/^char	*hdac_getaccountaddress(hdac_t *hdac, const char *account)$/;"	f
hdac_getaddednodeinfo	rpc_net.cpp	/^char	*hdac_getaddednodeinfo(hdac_t *hdac, const bool dns, const char *node)$/;"	f
hdac_getaddressbalances	rpc_wallet.cpp	/^char	*hdac_getaddressbalances(hdac_t *hdac, const char *addr, const int minconf, const bool includeLocked)$/;"	f
hdac_getaddresses	rpc_wallet.cpp	/^char	*hdac_getaddresses(hdac_t *hdac, const bool verbose, const int type)$/;"	f
hdac_getaddressesbyaccount	rpc_wallet.cpp	/^char	*hdac_getaddressesbyaccount(hdac_t *hdac, const char *account)$/;"	f
hdac_getaddresstx	rpc_wallet.cpp	/^char	*hdac_getaddresstx(hdac_t *hdac, const char *addr, const char *txid, const bool verbose)$/;"	f
hdac_getassetbalances	rpc_wallet.cpp	/^char	*hdac_getassetbalances(hdac_t *hdac, const char *account, const int minconf, const bool includeWatchonly, const bool includeLocked)$/;"	f
hdac_getassettx	rpc_wallet.cpp	/^char	*hdac_getassettx(hdac_t *hdac, const char *asset_id, const char *txid, const bool verbose)$/;"	f
hdac_getbalance	rpc_wallet.cpp	/^char	*hdac_getbalance(hdac_t *hdac, const char *account, const int minconf, const bool includeWatchonly)$/;"	f
hdac_getbestblockhash	rpc_bc.cpp	/^char	*hdac_getbestblockhash(hdac_t *hdac)$/;"	f
hdac_getblock	rpc_bc.cpp	/^char	*hdac_getblock(hdac_t *hdac, const uint32_t height, const int verbose)$/;"	f
hdac_getblockbyhash	rpc_bc.cpp	/^char	*hdac_getblockbyhash(hdac_t *hdac, const char *hash, const int verbose)$/;"	f
hdac_getblockchaininfo	rpc_bc.cpp	/^char	*hdac_getblockchaininfo(hdac_t *hdac)$/;"	f
hdac_getblockchainparams	rpc_ctl.cpp	/^char	*hdac_getblockchainparams(hdac_t *hdac, const bool displaynames, const bool with_upgrades)$/;"	f
hdac_getblockcount	rpc_bc.cpp	/^char	*hdac_getblockcount(hdac_t *hdac)$/;"	f
hdac_getblockhash	rpc_bc.cpp	/^char	*hdac_getblockhash(hdac_t *hdac, const uint32_t index)$/;"	f
hdac_getblocktemplate	rpc_mine.cpp	/^char	*hdac_getblocktemplate(hdac_t *hdac, const char *jsonobj)$/;"	f
hdac_getblockwindowsize	rpc_mine.cpp	/^char	*hdac_getblockwindowsize(hdac_t *hdac)$/;"	f
hdac_getchaintips	rpc_bc.cpp	/^char	*hdac_getchaintips(hdac_t *hdac)$/;"	f
hdac_getconnectioncount	rpc_net.cpp	/^char	*hdac_getconnectioncount(hdac_t *hdac)$/;"	f
hdac_getdifficulty	rpc_bc.cpp	/^char	*hdac_getdifficulty(hdac_t *hdac)$/;"	f
hdac_geterror	hdaclib.c	/^char	*hdac_geterror()$/;"	f
hdac_getgenerate	rpc_mine.cpp	/^char	*hdac_getgenerate(hdac_t *hdac)$/;"	f
hdac_gethashespersec	rpc_mine.cpp	/^char	*hdac_gethashespersec(hdac_t *hdac)$/;"	f
hdac_getinfo	rpc_ctl.cpp	/^char	*hdac_getinfo(hdac_t *hdac)$/;"	f
hdac_getmempoolinfo	rpc_bc.cpp	/^char	*hdac_getmempoolinfo(hdac_t *hdac)$/;"	f
hdac_getmininginfo	rpc_mine.cpp	/^char	*hdac_getmininginfo(hdac_t *hdac)$/;"	f
hdac_getmultibalances	rpc_wallet.cpp	/^char	*hdac_getmultibalances(hdac_t *hdac, const char *addr, const char *assets, const int minconf, const bool includeLocked, const bool includeWatchonly)$/;"	f
hdac_getnettotals	rpc_net.cpp	/^char	*hdac_getnettotals(hdac_t *hdac)$/;"	f
hdac_getnetworkhashps	rpc_mine.cpp	/^char	*hdac_getnetworkhashps(hdac_t *hdac, const int blocks, const int height)$/;"	f
hdac_getnetworkinfo	rpc_net.cpp	/^char	*hdac_getnetworkinfo(hdac_t *hdac)$/;"	f
hdac_getnewaddress	rpc_wallet.cpp	/^char	*hdac_getnewaddress(hdac_t *hdac, const char *account)$/;"	f
hdac_getpeerinfo	rpc_net.cpp	/^char	*hdac_getpeerinfo(hdac_t *hdac)$/;"	f
hdac_getrawchangeaddress	rpc_xch.cpp	/^char	*hdac_getrawchangeaddress(hdac_t *hdac)$/;"	f
hdac_getrawmempool	rpc_bc.cpp	/^char	*hdac_getrawmempool(hdac_t *hdac, const bool verbose)$/;"	f
hdac_getrawtx	rpc_wallet.cpp	/^char	*hdac_getrawtx(hdac_t *hdac, const char *txid, const int verbose)$/;"	f
hdac_getreceivedbyaccount	rpc_wallet.cpp	/^char	*hdac_getreceivedbyaccount(hdac_t *hdac, const char *account, const int minconf)$/;"	f
hdac_getreceivedbyaddress	rpc_wallet.cpp	/^char	*hdac_getreceivedbyaddress(hdac_t *hdac, const char *addr, const int minconf)$/;"	f
hdac_getruntimeparams	rpc_ctl.cpp	/^char	*hdac_getruntimeparams(hdac_t *hdac)$/;"	f
hdac_getstreamitem	rpc_stream.cpp	/^char	*hdac_getstreamitem(hdac_t *hdac, const char *stream_id, const char *txid, const bool verbose)$/;"	f
hdac_gettotalbalances	rpc_wallet.cpp	/^char	*hdac_gettotalbalances(hdac_t *hdac, const int minconf, const bool includeWatchonly, const bool includeLocked)$/;"	f
hdac_gettx	rpc_wallet.cpp	/^char	*hdac_gettx(hdac_t *hdac, const char *txid, const bool includeWatchonly)$/;"	f
hdac_gettxout	rpc_bc.cpp	/^char	*hdac_gettxout(hdac_t *hdac, const char *txid, const uint32_t nvout, const bool includemempool)$/;"	f
hdac_gettxoutdata	rpc_wallet.cpp	/^char	*hdac_gettxoutdata(hdac_t *hdac, const char *txid, const int vout, const long int count_bytes, const int start_byte)$/;"	f
hdac_gettxoutsetinfo	rpc_bc.cpp	/^char	*hdac_gettxoutsetinfo(hdac_t *hdac)$/;"	f
hdac_getunconfirmedbalance	rpc_wallet.cpp	/^char	*hdac_getunconfirmedbalance(hdac_t *hdac)$/;"	f
hdac_getwalletinfo	rpc_wallet.cpp	/^char	*hdac_getwalletinfo(hdac_t *hdac)$/;"	f
hdac_getwallettx	rpc_wallet.cpp	/^char	*hdac_getwallettx(hdac_t *hdac, const char *txid, const bool includeWatchonly, const bool verbose)$/;"	f
hdac_grant	rpc_grant.cpp	/^char	*hdac_grant(hdac_t *hdac, const char *addrs, const char *perms, const double native_amount, const int startblock, const int endblock, const char *comment, const char *comment_to)$/;"	f
hdac_grantfrom	rpc_grant.cpp	/^char	*hdac_grantfrom(hdac_t *hdac, const char *fromaddr, const char *toaddrs, const char *perms, const double native_amount, const int startblock, const int endblock, const char *comment, const char *comment_to)$/;"	f
hdac_grantwithdata	rpc_grant.cpp	/^char	*hdac_grantwithdata(hdac_t *hdac, const char *addrs, const char *perms, const char *data, int datalen, const double native_amount, const int startblock, const int endblock)$/;"	f
hdac_grantwithdatafrom	rpc_grant.cpp	/^char	*hdac_grantwithdatafrom(hdac_t *hdac, const char *fromaddr, const char *toaddrs, const char *perms, const char *data, int datalen, const double native_amount, const int startblock, const int endblock)$/;"	f
hdac_importaddress	rpc_wallet.cpp	/^char	*hdac_importaddress(hdac_t *hdac, const char *addrs, const char *label, const bool rescan)$/;"	f
hdac_importprivkey	rpc_wallet.cpp	/^char	*hdac_importprivkey(hdac_t *hdac, const char *privkeys, const char *label, const bool rescan)$/;"	f
hdac_importwallet	rpc_wallet.cpp	/^char	*hdac_importwallet(hdac_t *hdac, const char *filename)$/;"	f
hdac_in_t	node.h	/^} hdac_in_t;$/;"	t	typeref:struct:__anon14
hdac_issue	rpc_wallet.cpp	/^char	*hdac_issue(hdac_t *hdac, const char *addr, const char *asset_params, const double quantity, const double smallest_unit, const double native_amount, const char *custom_fields)$/;"	f
hdac_issuefrom	rpc_wallet.cpp	/^char	*hdac_issuefrom(hdac_t *hdac, const char *fromaddr, const char *toaddr, const char *asset_params, const double quantity, const double smallest_unit, const double native_amount, const char *custom_fields)$/;"	f
hdac_issuemore	rpc_wallet.cpp	/^char	*hdac_issuemore(hdac_t *hdac, const char *addr, const char *asset_id, const double quantity, const double native_amount, const char *custom_fields)$/;"	f
hdac_issuemorefrom	rpc_wallet.cpp	/^char	*hdac_issuemorefrom(hdac_t *hdac, const char *fromaddr, const char *toaddr, const char *asset_id, const double quantity, const double native_amount, const char *custom_fields)$/;"	f
hdac_keypoolrefill	rpc_wallet.cpp	/^char	*hdac_keypoolrefill(hdac_t *hdac, const int newsize)$/;"	f
hdac_listaccounts	rpc_wallet.cpp	/^char	*hdac_listaccounts(hdac_t *hdac, const int minconf, const bool includeWatchonly)$/;"	f
hdac_listaddresses	rpc_wallet.cpp	/^char	*hdac_listaddresses(hdac_t *hdac, const char *addrs, const bool verbose, const long int count, const int start)$/;"	f
hdac_listaddressgroupings	rpc_wallet.cpp	/^char	*hdac_listaddressgroupings(hdac_t *hdac)$/;"	f
hdac_listaddresstxs	rpc_wallet.cpp	/^char	*hdac_listaddresstxs(hdac_t *hdac, const char *addr, const int count, const int skip, const bool verbose)$/;"	f
hdac_listassets	rpc_bc.cpp	/^char	*hdac_listassets(hdac_t *hdac, const char *asset_id, const bool verbose, const long int count, const int start)$/;"	f
hdac_listassettxs	rpc_wallet.cpp	/^char	*hdac_listassettxs(hdac_t *hdac, const char *asset_id, const bool verbose, const int count, const int start, const bool local_ordering)$/;"	f
hdac_listblocks	rpc_bc.cpp	/^char	*hdac_listblocks(hdac_t *hdac, const char *block_set_id, const bool verbose)$/;"	f
hdac_listlockunspent	rpc_wallet.cpp	/^char	*hdac_listlockunspent(hdac_t *hdac)$/;"	f
hdac_listpermissions	rpc_bc.cpp	/^char	*hdac_listpermissions(hdac_t *hdac, const char *perm, const char *addr, const bool verbose)$/;"	f
hdac_listreceivedbyaccount	rpc_wallet.cpp	/^char	*hdac_listreceivedbyaccount(hdac_t *hdac, const int minconf, const bool includeempty, const bool includeWatchonly)$/;"	f
hdac_listreceivedbyaddress	rpc_wallet.cpp	/^char	*hdac_listreceivedbyaddress(hdac_t *hdac, const int minconf, const bool includeempty, const bool includeWatchonly)$/;"	f
hdac_listsinceblock	rpc_wallet.cpp	/^char	*hdac_listsinceblock(hdac_t *hdac, const char *blockhash, const int target_confirms, const bool includeWatchonly)$/;"	f
hdac_liststreamblockitems	rpc_stream.cpp	/^char	*hdac_liststreamblockitems(hdac_t *hdac, const char *stream_id, const char *block_set_id, const bool verbose, const long int count, const int start)$/;"	f
hdac_liststreamitems	rpc_stream.cpp	/^char	*hdac_liststreamitems(hdac_t *hdac, const char *stream_id, const bool verbose, const long int count, const int start, const bool local_ordering)$/;"	f
hdac_liststreamkeyitems	rpc_stream.cpp	/^char	*hdac_liststreamkeyitems(hdac_t *hdac, const char *stream_id, const char *stream_key, const bool verbose, const long int count, const int start, const bool local_ordering)$/;"	f
hdac_liststreamkeys	rpc_stream.cpp	/^char	*hdac_liststreamkeys(hdac_t *hdac, const char *stream_id, const char *stream_key, const bool verbose, const long int count, const int start, const bool local_ordering)$/;"	f
hdac_liststreampublisheritems	rpc_stream.cpp	/^char	*hdac_liststreampublisheritems(hdac_t *hdac, const char *stream_id, const char *addr, const bool verbose, const int count, const int start, const bool local_ordering)$/;"	f
hdac_liststreampublishers	rpc_stream.cpp	/^char	*hdac_liststreampublishers(hdac_t *hdac, const char *stream_id, const char *addrs, const bool verbose, const int count, const int start, const bool local_ordering)$/;"	f
hdac_liststreams	rpc_bc.cpp	/^char	*hdac_liststreams(hdac_t *hdac, const char *stream_id, const bool verbose, const long int count, const int start)$/;"	f
hdac_listtxs	rpc_wallet.cpp	/^char	*hdac_listtxs(hdac_t *hdac, const char *account, const int count, const int from, const bool includeWatchonly)$/;"	f
hdac_listunspent	rpc_wallet.cpp	/^char	*hdac_listunspent(hdac_t *hdac, const int minconf, const int maxconf, const char *addrs)$/;"	f
hdac_listwallettxs	rpc_wallet.cpp	/^char	*hdac_listwallettxs(hdac_t *hdac, const int count, const int skip, const bool includeWatchonly, const bool verbose)$/;"	f
hdac_load_all_send_limit	hdaclib.c	/^int	hdac_load_all_send_limit(hdac_t *hdac)$/;"	f
hdac_lockunspent	rpc_wallet.cpp	/^char	*hdac_lockunspent(hdac_t *hdac, const bool unlock, const char *transaction)$/;"	f
hdac_map_add	contract.c	/^int	hdac_map_add(hdac_t *hdac, const char *stream, const char *sender, const char *handler)$/;"	f
hdac_map_grant	contract.c	/^int	hdac_map_grant(hdac_t *hdac, const char *addr, const char *perm)$/;"	f
hdac_map_remove	contract.c	/^int	hdac_map_remove(hdac_t *hdac, const char *stream, const char *sender)$/;"	f
hdac_map_t	contract.h	/^} hdac_map_t;$/;"	t	typeref:struct:__anon1
hdac_map_validate	contract.c	/^int	hdac_map_validate(hdac_t *hdac, const char *stream, const char *sender)$/;"	f
hdac_move	rpc_wallet.cpp	/^char	*hdac_move(hdac_t *hdac, const char *fromaccount, const char *toaccount, const double amount, const int minconf, const char *comment)$/;"	f
hdac_multisig	multisig.c	/^int	hdac_multisig(hdac_t *hdac, multisig_t *msig)$/;"	f
hdac_multisig2	multisig.c	/^int	hdac_multisig2(hdac_t *hdac, multisig_t *msig)$/;"	f
hdac_name_get	name_map.c	/^char	*hdac_name_get(hdac_t *hdac, const char *key, char *outbuf, size_t outbuflen)$/;"	f
hdac_name_get_file	name_map.c	/^char	*hdac_name_get_file(const char *name, char *outbuf, size_t outbuflen)$/;"	f
hdac_name_set	name_map.c	/^int	hdac_name_set(hdac_t *hdac, const char *addr, const char *name)$/;"	f
hdac_name_set_file	name_map.c	/^int	hdac_name_set_file(const char *addr, const char *name)$/;"	f
hdac_name_unset	name_map.c	/^int	hdac_name_unset(hdac_t *hdac, const char *addr, const char *name)$/;"	f
hdac_name_unset_file	name_map.c	/^int	hdac_name_unset_file(const char *addr, const char *name)$/;"	f
hdac_node	node.h	/^	hdac_node()$/;"	f	class:hdac_node
hdac_node	node.h	/^class hdac_node$/;"	c
hdac_open	hdaclib.c	/^hdac_t	*hdac_open(const char *nodeip, const int port, const char *userid, const char *password)$/;"	f
hdac_parse_limit	hdaclib.c	/^static	hdac_send_limit_t	*hdac_parse_limit(json& list, int *retcount)$/;"	f	file:
hdac_pause_task	rpc_ctl.cpp	/^char	*hdac_pause_task(hdac_t *hdac, const char *tasks)$/;"	f
hdac_preparelockunspent	rpc_wallet.cpp	/^char	*hdac_preparelockunspent(hdac_t *hdac, const char *asset_qty, const bool lock)$/;"	f
hdac_preparelockunspentfrom	rpc_wallet.cpp	/^char	*hdac_preparelockunspentfrom(hdac_t *hdac, const char *fromaddr, const char *asset_qty, const bool lock)$/;"	f
hdac_publish	rpc_stream.cpp	/^char	*hdac_publish(hdac_t *hdac, const char *stream_id, const char *item_key, const char *data, int datalen)$/;"	f
hdac_publish_contract	contract.c	/^int	hdac_publish_contract(hdac_t *hdac, hdac_map_t *map, const char *contract)$/;"	f
hdac_publishfrom	rpc_stream.cpp	/^char	*hdac_publishfrom(hdac_t *hdac, const char *fromaddr, const char *stream_id, const char *item_key, const char *data, int datalen)$/;"	f
hdac_receipt	hdaclib.c	/^char	*hdac_receipt(hdac_t *hdac, const char *txid)$/;"	f
hdac_receive_contract	contract.c	/^string	hdac_receive_contract(hdac_t *hdac, hdac_map_t *map)$/;"	f
hdac_resendwallettxs	rpc_wallet.cpp	/^char	*hdac_resendwallettxs(hdac_t *hdac)$/;"	f
hdac_resume_task	rpc_ctl.cpp	/^char	*hdac_resume_task(hdac_t *hdac, const char *tasks)$/;"	f
hdac_revoke	rpc_grant.cpp	/^char	*hdac_revoke(hdac_t *hdac, const char *addrs, const char *perms, const double native_amount, const char *comment, const char *comment_to)$/;"	f
hdac_revokefrom	rpc_grant.cpp	/^char	*hdac_revokefrom(hdac_t *hdac, const char *fromaddr, const char *toaddrs, const char *perms, const double native_amount, const char *comment, const char *comment_to)$/;"	f
hdac_send	rpc_wallet.cpp	/^char	*hdac_send(hdac_t *hdac, const char *addr, const double amount, const char *comment, const char *comment_to)$/;"	f
hdac_send_asset	rpc_wallet.cpp	/^char	*hdac_send_asset(hdac_t *hdac, const char *addr, const char *asset_qty, const char *comment, const char *comment_to)$/;"	f
hdac_send_contract	contract.c	/^int	hdac_send_contract(hdac_t *hdac, hdac_map_t *map)$/;"	f
hdac_send_limit_t	hdaclib.h	/^}	hdac_send_limit_t;$/;"	t	typeref:struct:__anon8
hdac_sendasset	rpc_wallet.cpp	/^char	*hdac_sendasset(hdac_t *hdac, const char *addr, const char *asset_id, const double asset_qty, const double native_amount, const char *comment, const char *comment_to)$/;"	f
hdac_sendassetfrom	rpc_wallet.cpp	/^char	*hdac_sendassetfrom(hdac_t *hdac, const char *fromaddr, const char *toaddr, const char *asset_id, const double asset_qty, const double native_amount, const char *comment, const char *comment_to)$/;"	f
hdac_sendfrom	rpc_wallet.cpp	/^char	*hdac_sendfrom(hdac_t *hdac, const char *fromaddr, const char *toaddr, const double amount, const char *comment, const char *comment_to)$/;"	f
hdac_sendfrom_asset	rpc_wallet.cpp	/^char	*hdac_sendfrom_asset(hdac_t *hdac, const char *fromaddr, const char *toaddr, const char *asset_qty, const char *comment, const char *comment_to)$/;"	f
hdac_sendfromaccount	rpc_wallet.cpp	/^char	*hdac_sendfromaccount(hdac_t *hdac, const char *fromaccount, const char *toaddr, const double amount, const int minconf, const char *comment, const char *comment_to)$/;"	f
hdac_sendmany	rpc_wallet.cpp	/^char	*hdac_sendmany(hdac_t *hdac, const char *fromaccount, const char *addr_amounts, const int minconf, const char *comment)$/;"	f
hdac_sendrawtx	rpc_msig.cpp	/^char	*hdac_sendrawtx(hdac_t *hdac, const char *tx_hex, bool allowhighfees)$/;"	f
hdac_sendwithdata	rpc_wallet.cpp	/^char	*hdac_sendwithdata(hdac_t *hdac, const char *addr, const double amount, const char *data, int datalen)$/;"	f
hdac_sendwithdata_asset	rpc_wallet.cpp	/^char	*hdac_sendwithdata_asset(hdac_t *hdac, const char *addr, const char *asset_qty, const char *data, int datalen)$/;"	f
hdac_sendwithdatafrom	rpc_wallet.cpp	/^char	*hdac_sendwithdatafrom(hdac_t *hdac, const char *fromaddr, const char *toaddr, const double amount, const char *data, int datalen)$/;"	f
hdac_sendwithdatafrom_asset	rpc_wallet.cpp	/^char	*hdac_sendwithdatafrom_asset(hdac_t *hdac, const char *fromaddr, const char *toaddr, const char *asset_qty, const char *data, int datalen)$/;"	f
hdac_set_send_limit	hdaclib.c	/^int	hdac_set_send_limit(hdac_t *hdac, const hdac_send_limit_t *savelp)$/;"	f
hdac_setaccount	rpc_wallet.cpp	/^char	*hdac_setaccount(hdac_t *hdac, const char *addr, const char *account)$/;"	f
hdac_seterror	hdaclib.c	/^void	hdac_seterror(int errcode, char *errmsg)$/;"	f
hdac_setlastblock	rpc_ctl.cpp	/^char	*hdac_setlastblock(hdac_t *hdac, const int height)$/;"	f
hdac_setlastblockbyhash	rpc_ctl.cpp	/^char	*hdac_setlastblockbyhash(hdac_t *hdac, const char *hash)$/;"	f
hdac_setruntimeparam	rpc_ctl.cpp	/^char	*hdac_setruntimeparam(hdac_t *hdac, const char *param_name, const char *param_value)$/;"	f
hdac_settxfee	rpc_wallet.cpp	/^char	*hdac_settxfee(hdac_t *hdac, const double amount)$/;"	f
hdac_signmessage	rpc_wallet.cpp	/^char	*hdac_signmessage(hdac_t *hdac, const char *addr_or_privkey, const char *message)$/;"	f
hdac_signrawtx	rpc_msig.cpp	/^char	*hdac_signrawtx(hdac_t *hdac, const char *tx_hex, const char *prevtxs, const char *privatekeys, const char *sighashtype)$/;"	f
hdac_subscribe	rpc_stream.cpp	/^char	*hdac_subscribe(hdac_t *hdac, const char *entity_ids, const bool rescan)$/;"	f
hdac_t	hdaclib.h	/^}	hdac_t;$/;"	t	typeref:struct:__anon9
hdac_unsubscribe	rpc_stream.cpp	/^char	*hdac_unsubscribe(hdac_t *hdac, const char *json_id)$/;"	f
hdac_validateaddress	rpc_util.cpp	/^char	*hdac_validateaddress(hdac_t *hdac, const char *addr)$/;"	f
hdac_verifymessage	rpc_util.cpp	/^char	*hdac_verifymessage(hdac_t *hdac, const char *addr, const char *signature, const char *message)$/;"	f
hdac_virtual_device	node.h	/^	hdac_virtual_device()$/;"	f	class:hdac_virtual_device
hdac_virtual_device	node.h	/^class hdac_virtual_device$/;"	c
hdac_walletpassphrase	rpc_wallet.cpp	/^char	*hdac_walletpassphrase(hdac_t *hdac, const char *passphrase, const int timeout_sec)$/;"	f
hdacp	rpc.h	/^	hdac_t	*hdacp;$/;"	m	class:hdac
hdrlen	libstar/gw.h	/^	uint	hdrlen;			\/\/ 헤더 블록의 크기 $/;"	m	struct:__anon38
hdrlen	libstar/gw.h	/^	uint	hdrlen;			\/\/ 헤더 블록의 크기 $/;"	m	struct:__anon39
head	libstar/xlist.h	/^	xlistnode_t	*head;		\/\/ 맨 처음 노드 포인터$/;"	m	struct:xlist
header	libstar/netbios.c	/^	nbname_response_header_t *header;$/;"	m	struct:__anon50	file:
header	libstar/sflowlib.h	/^	SFLSampled_header header;$/;"	m	union:_SFLFlow_type
header	libstar/sflowlib.h	/^	uchar          *header;$/;"	m	struct:_SFSample
header	libstar/xicmp.h	/^	IcmpHeader	header;			\/\/ ICMP header$/;"	m	struct:__anon136
header	libstar/xicmp.h	/^	IcmpHeader	header;$/;"	m	struct:__anon135
headerLen	libstar/sflowlib.h	/^	int             headerLen;$/;"	m	struct:_SFSample
headerProtocol	libstar/sflowlib.h	/^	uint            headerProtocol;$/;"	m	struct:_SFSample
header_bytes	libstar/sflowlib.h	/^	uint8          *header_bytes;	\/\/ Header bytes $/;"	m	struct:_SFLSampled_header
header_len	libstar/snoop.h	/^	uint_t	(*header_len)(char *);$/;"	m	struct:__anon98
header_length	libstar/sflowlib.h	/^	uint            header_length;	\/\/ length of sampled header bytes to follow$/;"	m	struct:_SFLSampled_header
header_protocol	libstar/sflowlib.h	/^	uint            header_protocol;	\/\/ (enum SFLHeader_protocol) $/;"	m	struct:_SFLSampled_header
heventSRB	libstar/dvdlib.c	/^	HANDLE	heventSRB;$/;"	m	struct:__anon28	file:
heventSRB	libstar/oddlibwin.c	/^	HANDLE          heventSRB;$/;"	m	struct:__anon65	file:
hex2bin	lib/libhash.c	/^void	*hex2bin(void *binbuf, const char *hexbuf, const size_t hexbuflen)$/;"	f
hexstr2bin	libstar/xdb.c	/^char	*hexstr2bin(void *data, int size)$/;"	f
hi	lib/md5.h	/^    uint32_t     hi;$/;"	m	struct:__anon16
hiclock	libstar/xicmp.h	/^	double		hiclock;$/;"	m	struct:__anon133
hide	libstar/xnms.h	/^	char		hide[20][10];$/;"	m	struct:__anon145
hideerror	libstar/xdb.h	/^	int		hideerror;	\/\/ 에러 메시지 숨기기 $/;"	m	struct:__anon118
hitime	libstar/snmpdef.h	/^	double		hitime;			\/\/ Gathering time (I\/F별로 다름) - hi resolution time (micro-sec)$/;"	m	struct:__anon77
hitime	libstar/snmpdef.h	/^	double	hitime;			\/\/ Gathering time (I\/F별로 다름) - hi resolution time (micro-sec)$/;"	m	struct:__anon78
hops	libstar/xicmp.h	/^	int		hops;			\/\/ 살아있는 라우터 구간$/;"	m	struct:__anon136
host	libstar/sflowlib.h	/^	SFLString       host;	\/* The host field from the HTTP header *\/$/;"	m	struct:_SFLExtended_url
host	libstar/sflowlib.h	/^	char            host[SA_MAX_EXTENDED_HOST_LEN + 1];$/;"	m	struct:_SFSample
host_len	libstar/sflowlib.h	/^	uint            host_len;$/;"	m	struct:_SFSample
hostaddr	libstar/gw.h	/^	uint	hostaddr;		\/\/ Host address$/;"	m	struct:gwinfo
hostname	libstar/snmpdef.h	/^	char	hostname[64];$/;"	m	struct:__anon76
hostname	libstar/xicmp.h	/^	char		hostname[32];		\/\/ host name 또는 IP address$/;"	m	struct:__anon136
hostname	libstar/xsnmp.h	/^	char		hostname[32];$/;"	m	struct:__anon158
hostname	libstar/xsock.h	/^	char		hostname[100];$/;"	m	struct:__anon166
hour	libstar/xtime.c	/^	uchar    hour, min, sec;	\/\/ 0..23시간  0..59분  0..59초 $/;"	m	struct:__anon169	file:
hourcount	libstar/xnms.h	/^	int		hourcount, curnumifhour, oldnumifhour;$/;"	m	struct:xnmsnode
hourterm	libstar/xnms.h	/^	int		hourterm;		\/\/ 1시간 주기 통계 $/;"	m	struct:xnmsnode
ht	libstar/hash.h	/^	hash_t		*ht;		\/\/ so we don't have to pass the table for all of those data$/;"	m	struct:hashentry
htptr	libstar/vhash.h	/^	vhash_t		*htptr;		\/\/ so we don't have to pass the table for all of those data manipulation calls... $/;"	m	struct:vhashentry
http_get	libstar/http.c	/^_ALLOC	char	*http_get(char *url_org, char *page, int port, int timeout_sec, int flag)$/;"	f
http_get_response	libstar/http.c	/^_ALLOC	char	*http_get_response(char *url_org, char *page, int port, int timeout_sec, int flag,$/;"	f
http_post	libstar/http.c	/^_ALLOC	char	*http_post(char *url_org, char *page, char *msg, int port, int timeout_sec, float *dnsMS, float *rttMS, float *xferMS, float *respMS)$/;"	f
httpinfo_t	libstar/http.c	/^}	httpinfo_t;$/;"	t	typeref:struct:__anon43	file:
hwterm	libstar/xnms.h	/^	int		hwterm;			\/\/ H\/W 정보 수집 주기$/;"	m	struct:xnmsnode
hwver	libstar/xnms.h	/^	char		hwver[20];		\/\/ .18	\/\/ H\/W version$/;"	m	struct:__anon148
i	json11/json11.cpp	/^    size_t i;$/;"	m	struct:json11::__anon15::final	file:
i	lib/rc4.h	/^    uint32_t     i;$/;"	m	struct:__anon18
iSigAlarmFlagS	libstar/xssl.c	/^static int      iSigAlarmFlagS = FALSE;$/;"	v	file:
icmp_header_code	libstar/xicmp.c	/^const	char	*icmp_header_code(int type, int code)$/;"	f
icmp_header_type	libstar/xicmp.c	/^const char	*icmp_header_type(int type)$/;"	f
icmphdr	libstar/sflowlib.h	/^struct icmphdr$/;"	s
id	hdaclib.h	/^	char	id[100];$/;"	m	struct:__anon5
id	libstar/ocilib.h	/^	int		id; $/;"	m	struct:__anon62
id	libstar/ocilib.h	/^	int		id; $/;"	m	struct:ocistmt
id	libstar/sflowlib.h	/^      uint16_t	id;$/;"	m	struct:icmphdr::__anon67::__anon68
id	libstar/sflowlib.h	/^    uint16_t id;$/;"	m	struct:iphdr
id	libstar/smslib.c	/^	char	id[10];			\/\/ 사용자아이디$/;"	m	struct:__anon74	file:
id	libstar/thrpool.h	/^	int		id;		\/\/ Thread ID (0..maxthread-1)$/;"	m	struct:thrdata
id	libstar/xicmp.h	/^	uint		id;$/;"	m	struct:__anon133
id	libstar/xtime.c	/^	char	id[30];$/;"	m	struct:__anon171	file:
idea_crypt	libstar/idea.c	/^int	idea_crypt(void *buf, int len, void *outbuf, char *passwd, int decoding)$/;"	f
idea_crypt_hex	libstar/idea.c	/^char	*idea_crypt_hex(char *passwd, char *newbuf, int decode)$/;"	f
idea_crypt_overwrite	libstar/idea.c	/^int	idea_crypt_overwrite(void *buf, int len, char *passwd, int decoding)$/;"	f
ifDirection	libstar/sflowlib.h	/^	uint            ifDirection;	\/* Derived from MAU MIB (RFC 2668)$/;"	m	struct:_SFLIf_counters
ifInBroadcastPkts	libstar/sflowlib.h	/^	uint            ifInBroadcastPkts;$/;"	m	struct:_SFLIf_counters
ifInDiscards	libstar/sflowlib.h	/^	uint            ifInDiscards;$/;"	m	struct:_SFLIf_counters
ifInErrors	libstar/sflowlib.h	/^	uint            ifInErrors;$/;"	m	struct:_SFLIf_counters
ifInMulticastPkts	libstar/sflowlib.h	/^	uint            ifInMulticastPkts;$/;"	m	struct:_SFLIf_counters
ifInOctets	libstar/sflowlib.h	/^	uint64          ifInOctets;$/;"	m	struct:_SFLIf_counters
ifInUcastPkts	libstar/sflowlib.h	/^	uint            ifInUcastPkts;$/;"	m	struct:_SFLIf_counters
ifInUnknownProtos	libstar/sflowlib.h	/^	uint            ifInUnknownProtos;$/;"	m	struct:_SFLIf_counters
ifIndex	libstar/sflowlib.h	/^	uint            ifIndex;$/;"	m	struct:_SFLIf_counters
ifOutBroadcastPkts	libstar/sflowlib.h	/^	uint            ifOutBroadcastPkts;$/;"	m	struct:_SFLIf_counters
ifOutDiscards	libstar/sflowlib.h	/^	uint            ifOutDiscards;$/;"	m	struct:_SFLIf_counters
ifOutErrors	libstar/sflowlib.h	/^	uint            ifOutErrors;$/;"	m	struct:_SFLIf_counters
ifOutMulticastPkts	libstar/sflowlib.h	/^	uint            ifOutMulticastPkts;$/;"	m	struct:_SFLIf_counters
ifOutOctets	libstar/sflowlib.h	/^	uint64          ifOutOctets;$/;"	m	struct:_SFLIf_counters
ifOutUcastPkts	libstar/sflowlib.h	/^	uint            ifOutUcastPkts;$/;"	m	struct:_SFLIf_counters
ifPromiscuousMode	libstar/sflowlib.h	/^	uint            ifPromiscuousMode;$/;"	m	struct:_SFLIf_counters
ifSpeed	libstar/sflowlib.h	/^	uint64          ifSpeed;$/;"	m	struct:_SFLIf_counters
ifStatus	libstar/sflowlib.h	/^	uint            ifStatus;	\/* bit field with the following bits assigned:$/;"	m	struct:_SFLIf_counters
ifType	libstar/sflowlib.h	/^	uint            ifType;$/;"	m	struct:_SFLIf_counters
ifalias	libstar/snmpdef.h	/^	char		ifalias[256];$/;"	m	struct:__anon77
ifalias	libstar/snmpdef.h	/^	char	ifalias[156];		\/\/ ifalias: 라우터에서 직접 정의한 I\/F 명칭 "LGE::SITE:SITE_NAME" (1.3.6.1.4.1.9.2.2.1.1.28.#)$/;"	m	struct:__anon78
ifchanged	libstar/snmpdef.h	/^	int	ifchanged;		\/\/ I\/F 내용 변경됨.$/;"	m	struct:__anon78
ifchanged	libstar/xnms.h	/^	int		ifchanged;		\/\/ 1이면 I\/F의 내용에 변화가 생긴 것임.. (NMS_MODE_FAST에서는 Description을 다시 읽음)$/;"	m	struct:xnmsnode
ifcollision	libstar/snmpdef.h	/^	float	ifcollision;		\/\/ output collision$/;"	m	struct:__anon78
ifcrc	libstar/snmpdef.h	/^	float	ifcrc;			\/\/ input CRC error$/;"	m	struct:__anon78
ifdescr	libstar/snmpdef.h	/^	char	ifdescr[100];		\/\/ ifdescr: 1.3.6.1.2.1.2.2.1.2.# (고정된 명칭)$/;"	m	struct:__anon78
ifdescr	libstar/xsock.h	/^	char		ifdescr[256];$/;"	m	struct:__anon166
ifdnsprefix	libstar/xsock.h	/^	char		ifdnsprefix[100];$/;"	m	struct:__anon166
ifindex	libstar/snmpdef.h	/^	int		ifindex;$/;"	m	struct:__anon77
ifindex	libstar/snmpdef.h	/^	int	ifindex;$/;"	m	struct:__anon78
ifindex	libstar/snmpdef.h	/^	int	ifindex;$/;"	m	struct:__anon79
ifindex	libstar/snmpdef.h	/^	int	ifindex;$/;"	m	struct:__anon80
ifindex	libstar/snmpdef.h	/^	int	ifindex;$/;"	m	struct:__anon82
ifindex	libstar/xsnmp.h	/^	int	ifindex;$/;"	m	struct:__anon161
ifindex	libstar/xsnmpif.c	/^	int	ifindex;$/;"	m	struct:__anon164	file:
ifindex	libstar/xsock.h	/^	int		ifindex;$/;"	m	struct:__anon166
ifip	libstar/snmpdef.h	/^	char	ifip[20];		\/\/ 인터페이스의 IP$/;"	m	struct:__anon78
iflist	libstar/xsnmp.h	/^	snmpif_t	*iflist;$/;"	m	struct:__anon159
ifname	libstar/snmpdef.h	/^	char		ifname[100];		\/\/ FE0\/1$/;"	m	struct:__anon77
iframe_receive_errors	libstar/netbios.c	/^	ushort		iframe_receive_errors;$/;"	m	struct:__anon49	file:
iframe_transmit_errors	libstar/netbios.c	/^	ushort		iframe_transmit_errors;$/;"	m	struct:__anon49	file:
ifstatus_t	libstar/xnms.h	/^}	ifstatus_t;$/;"	t	typeref:struct:__anon150
ifstatushash	libstar/xnms.h	/^	vhash_t		*ifstatushash;			\/\/ 최종 포트 상태 정보 ifstatus_t$/;"	m	struct:__anon149
ifstatusrt	libstar/xnms.h	/^	snmpif_t	*ifstatusrt;			\/\/ 현재 입수한 실시간 포트 상태 정보 $/;"	m	struct:xnmsnode
igrp_delay	libstar/snmpdef.h	/^	float	igrp_delay;		\/\/ CISCO IGRP Delay (microseconds)$/;"	m	struct:__anon78
igrp_load	libstar/snmpdef.h	/^	float	igrp_load;		\/\/ CISCO IGRP Load $/;"	m	struct:__anon78
igrp_relib	libstar/snmpdef.h	/^	float	igrp_relib;		\/\/ CISCO IGRP Reliability (0~255)$/;"	m	struct:__anon78
ihl	libstar/sflowlib.h	/^    uint8_t ihl:4;$/;"	m	struct:iphdr
ilock	libstar/hash.h	/^	xlock_t		ilock;		\/\/ 외부용$/;"	m	struct:__anon41
ilock	libstar/shash.h	/^	xlock_t		ilock;$/;"	m	struct:__anon71
ilock	libstar/vhash.h	/^	xlock_t		ilock;			\/\/ 내부용 lock $/;"	m	struct:__anon105
importaddress	rpc.h	/^	string importaddress(const char *addrs, const char *label = "", const bool rescan = true)$/;"	f	class:hdac
importprivkey	rpc.h	/^	string importprivkey(const char *privkeys, const char *label = "", const bool rescan = true)$/;"	f	class:hdac
importwallet	rpc.h	/^	string importwallet(const char *filename)$/;"	f	class:hdac
inAddrErrors	libstar/snmpdef.h	/^	uint	inAddrErrors;$/;"	m	struct:__anon81
inAddrMaskReplys	libstar/snmpdef.h	/^	uint	inAddrMaskReplys;	\/\/ 수신된 ICMP 주소 마스크 응답 메시지의 개수 $/;"	m	struct:__anon83
inAddrMasks	libstar/snmpdef.h	/^	uint	inAddrMasks;		\/\/ 수신된 ICMP 주소 마스크 요청 메시지의 개수 $/;"	m	struct:__anon83
inBandwidthPer	libstar/snmpdef.h	/^	float	inBandwidthPer;$/;"	m	struct:__anon78
inBroadcastPkts	libstar/snmpdef.h	/^	double		inBroadcastPkts;$/;"	m	struct:__anon77
inBytesPerSec	libstar/snmpdef.h	/^	float		inBytesPerSec;			\/\/ 초당 나간 바이트 수 $/;"	m	struct:__anon77
inBytesPerSec	libstar/snmpdef.h	/^	float	inBytesPerSec;		\/\/ 초당 나간 바이트 수 $/;"	m	struct:__anon78
inDatagrams	libstar/snmpdef.h	/^	uint		inDatagrams;	\/\/ UDP 사용자들에게 전달되는 UDP 데이터그램의 총 개수 $/;"	m	struct:__anon86
inDelivers	libstar/snmpdef.h	/^	uint	inDelivers;$/;"	m	struct:__anon81
inDestUnreachs	libstar/snmpdef.h	/^	uint	inDestUnreachs;		\/\/ 수신된 ICMP 목적지 도달 불가능한 메시지의 개수 $/;"	m	struct:__anon83
inDiscards	libstar/snmpdef.h	/^	uint	inDiscards;$/;"	m	struct:__anon78
inDiscards	libstar/snmpdef.h	/^	uint	inDiscards;$/;"	m	struct:__anon81
inEchoReplys	libstar/snmpdef.h	/^	uint	inEchoReplys;		\/\/ 수신된 ICMP 에코우(요청)에 대한 응답 메시지의 개수 $/;"	m	struct:__anon83
inEchos	libstar/snmpdef.h	/^	uint	inEchos;		\/\/ 수신된 ICMP 에코우(요청,요구) 메시지의 개수 $/;"	m	struct:__anon83
inErrors	libstar/snmpdef.h	/^	uint		inErrors;	\/\/ 목적지 포트에서 응용 프로그램의 문제 이외의 이유로 $/;"	m	struct:__anon86
inErrors	libstar/snmpdef.h	/^	uint	inErrors;		\/\/ ICMP 정의 오류(불량 ICMP 검사합, 길이 불량 등)를 가지고 $/;"	m	struct:__anon83
inErrors	libstar/snmpdef.h	/^	uint	inErrors;		\/\/ 오류로 수신된 세그먼트의 총 개수 $/;"	m	struct:__anon84
inErrors	libstar/snmpdef.h	/^	uint	inErrors;$/;"	m	struct:__anon78
inHdrErrors	libstar/snmpdef.h	/^	uint	inHdrErrors;$/;"	m	struct:__anon81
inMsgs	libstar/snmpdef.h	/^	uint	inMsgs;			\/\/ 엔티티가 수신한 ICMP 메시지의 총 개수 $/;"	m	struct:__anon83
inMulticastPkts	libstar/snmpdef.h	/^	double		inMulticastPkts;$/;"	m	struct:__anon77
inNUcastPkts	libstar/snmpdef.h	/^	uint	inNUcastPkts;		\/\/ broadcast$/;"	m	struct:__anon78
inOctets	libstar/snmpdef.h	/^	double		inOctets;$/;"	m	struct:__anon77
inOctets	libstar/snmpdef.h	/^	uint	inOctets;$/;"	m	struct:__anon78
inParamProbs	libstar/snmpdef.h	/^	uint	inParamProbs;		\/\/ 수신된 ICMP 매개 변수 문제 메시지의 개수 $/;"	m	struct:__anon83
inPkts	libstar/snmpdef.h	/^	double		inPkts;$/;"	m	struct:__anon77
inReceives	libstar/snmpdef.h	/^	uint	inReceives;$/;"	m	struct:__anon81
inRedirects	libstar/snmpdef.h	/^	uint	inRedirects;		\/\/ 수신된 ICMP 경로 전환 메시지의 개수 $/;"	m	struct:__anon83
inSegs	libstar/snmpdef.h	/^	uint	inSegs;			\/\/ 오류로 수신된 것을 포함하여 수신된 세그먼트의 총 개수 $/;"	m	struct:__anon84
inSrcQuenchs	libstar/snmpdef.h	/^	uint	inSrcQuenchs;		\/\/ 수신된 ICMP 발신지 억제 메시지의 개수 $/;"	m	struct:__anon83
inTimeExceeds	libstar/snmpdef.h	/^	uint	inTimeExceeds;		\/\/ 수신된 ICMP 시간 초과 메시지의 개수 $/;"	m	struct:__anon83
inTimestampReplys	libstar/snmpdef.h	/^	uint	inTimestampReplys;	\/\/ 수신된 ICMP Timestamp 응답 메시지의 개수 $/;"	m	struct:__anon83
inTimestamps	libstar/snmpdef.h	/^	uint	inTimestamps;		\/\/ 수신된 ICMP Timestamp(요청) 메시지의 개수 $/;"	m	struct:__anon83
inUcastPkts	libstar/snmpdef.h	/^	double		inUcastPkts;$/;"	m	struct:__anon77
inUcastPkts	libstar/snmpdef.h	/^	uint	inUcastPkts;$/;"	m	struct:__anon78
inUnitDiscards	libstar/snmpdef.h	/^	int	inUnitDiscards;$/;"	m	struct:__anon78
inUnitErrors	libstar/snmpdef.h	/^	int	inUnitErrors;$/;"	m	struct:__anon78
inUnitKBytes	libstar/snmpdef.h	/^	float		inUnitKBytes;		\/\/ 단위 시간당 들어온 바이트 수 $/;"	m	struct:__anon77
inUnitKBytes	libstar/snmpdef.h	/^	float	inUnitKBytes;		\/\/ 단위 시간당 들어온 바이트 수 $/;"	m	struct:__anon78
inUnitMcastPkts	libstar/snmpdef.h	/^	float	inUnitMcastPkts;	\/\/ 단위 시간당 나간 Multicast Pkts$/;"	m	struct:__anon78
inUnitPkts	libstar/snmpdef.h	/^	float		inUnitPkts;		\/\/ 단위 시간당 들어온 바이트 수 $/;"	m	struct:__anon77
inUnitPkts	libstar/snmpdef.h	/^	float	inUnitPkts;		\/\/ 단위 시간당 들어온 바이트 수 $/;"	m	struct:__anon78
inUnknownProtos	libstar/snmpdef.h	/^	uint	inUnknownProtos;$/;"	m	struct:__anon78
inUnknownProtos	libstar/snmpdef.h	/^	uint	inUnknownProtos;$/;"	m	struct:__anon81
in_encap	libstar/xflowlib.h	/^	int		in_encap;$/;"	m	struct:__anon129
in_encaps	libstar/nflowlib.h	/^	uint8		in_encaps;	\/\/ size in bytes of the input encapsulation$/;"	m	struct:__anon57
in_priority	libstar/sflowlib.h	/^	uint            in_priority;$/;"	m	struct:_SFSample
in_range	json11/json11.cpp	/^static inline bool in_range(long x, long lower, long upper)$/;"	f	namespace:json11
in_stack	libstar/sflowlib.h	/^	SFLLabelStack   in_stack;$/;"	m	struct:_SFLExtended_mpls
in_vlan	libstar/sflowlib.h	/^	uint            in_vlan;$/;"	m	struct:_SFSample
include	libstar/xnms.h	/^	char		*include;$/;"	m	struct:__anon151
incr	libstar/xsnmptype.c	/^	int		incr;$/;"	m	struct:__anon165	file:
indicator	libstar/ocilib.h	/^	sb2		indicator;	\/* *\/   $/;"	m	struct:__anon61
inf_cache_sec	libstar/xnms.h	/^	int		inf_cache_sec;		\/\/ SNMP Interface caching timeout seconds (0=자동)$/;"	m	struct:xnmsnode
info	libstar/ssmtplib.h	/^	ssmtp_info_t	info[100];$/;"	m	struct:__anon103
info	libstar/xlock.c	/^	uint		info;$/;"	m	struct:__anon139	file:
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index (always 0)$/;"	m	struct:__anon59
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index$/;"	m	struct:__anon53
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index$/;"	m	struct:__anon55
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index$/;"	m	struct:__anon57
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index$/;"	m	struct:struct_export_v8_1
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index$/;"	m	struct:struct_export_v8_3
inifidx	libstar/nflowlib.h	/^	uint16		inifidx;	\/\/ input interface index$/;"	m	struct:struct_export_v8_5
inifidx	libstar/sflowlib.h	/^	uint            inifidx;$/;"	m	struct:_SFSample
inifidx	libstar/xflowlib.h	/^	int		inifidx;$/;"	m	struct:__anon129
inifidx_format	libstar/sflowlib.h	/^	uint            inifidx_format;$/;"	m	struct:_SFSample
init	hvm.c	/^hdac_t	*init(char *exepath)$/;"	f
init	test.c	/^void	init(hdac_t *hdac)$/;"	f
init_entry	libstar/gwauto.c	/^static	int	init_entry(xgwrule_t *gwp)$/;"	f	file:
initok	libstar/xlock.h	/^	int		initok;	$/;"	m	struct:__anon141
initok	libstar/xlock.h	/^	int		initok;$/;"	m	struct:__anon140
inittimer	libstar/xtime.c	/^void	inittimer()$/;"	f
inmcastpps	libstar/snmpdef.h	/^	float	inmcastpps;		\/\/ Multicast in PPS$/;"	m	struct:__anon78
inoctets64	libstar/snmpdef.h	/^	uint64	inoctets64;		\/\/ 64비트 처리용 $/;"	m	struct:__anon78
inpkts64	libstar/snmpdef.h	/^	uint64	inpkts64;		\/\/ 64비트 처리용 $/;"	m	struct:__anon78
inpps	libstar/snmpdef.h	/^	float		inpps;			\/\/ 초당 수신된 packet 수 $/;"	m	struct:__anon77
inpps	libstar/snmpdef.h	/^	float	inpps;			\/\/ 초당 수신된 packet 수 $/;"	m	struct:__anon78
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface *\/$/;"	m	struct:struct_export_v8_10
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface *\/$/;"	m	struct:struct_export_v8_11
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface *\/$/;"	m	struct:struct_export_v8_13
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface *\/$/;"	m	struct:struct_export_v8_14
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface index *\/$/;"	m	struct:struct_export_v8_7
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface index *\/$/;"	m	struct:struct_export_v8_8
input	libstar/nflowlib.h	/^	uint16       input;	\/* input interface index *\/$/;"	m	struct:struct_export_v8_9
input	libstar/sflowlib.h	/^	uint            input;	\/* SNMP ifIndex of input interface.$/;"	m	struct:_SFLFlow_sample
input	libstar/sflowlib.h	/^	uint            input;	\/* SNMP ifIndex of input interface.$/;"	m	struct:_SFLFlow_sample_expanded
input	libstar/xnms.h	/^	char		input[20][40];$/;"	m	struct:__anon145
inputFormat	libstar/sflowlib.h	/^	uint            inputFormat;	\/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
insert	myjson/json2.c	/^json& json::insert(const int nth, const string name, const double value)$/;"	f	class:json
insert	myjson/json2.c	/^json& json::insert(const int nth, const string name, const long value)$/;"	f	class:json
insert	myjson/json2.c	/^json& json::insert(const int nth, const string name, const string value)$/;"	f	class:json
insert	myjson/json2.c	/^json& json::insert(const int nth, json sub)$/;"	f	class:json
insert_common	myjson/json2.c	/^json& json::insert_common(const int nth, const string name, const string value, jsontype type)$/;"	f	class:json
instlenp	libstar/array.h	/^	int		*instlenp;		\/\/ 해당 인스턴스 크기 (maxsize * uint) -1이면 빈 공간임$/;"	m	struct:__anon27
instp	libstar/array.h	/^	char		*instp;			\/\/ 데이터 저장 공간 (maxsize * instsize)$/;"	m	struct:__anon27
instp	libstar/xindex.h	/^	char	*instp;			\/\/ 데이터 저장 공간 (maxsize * instsize)$/;"	m	struct:__anon137
instsize	libstar/array.h	/^	int		instsize;		\/\/ 데이터 블록 유닛 크기$/;"	m	struct:__anon27
instsize	libstar/fhash.h	/^	int		instsize;		\/\/ 데이터 크기 $/;"	m	struct:__anon35
instsize	libstar/hash.h	/^	int		instsize;	\/\/ hashent_t의 var[] 중에서 instance 부분의 크기 (hash table당 크기는 고정)$/;"	m	struct:__anon41
instsize	libstar/shash.h	/^	int		instsize;		\/\/ 데이터 크기 $/;"	m	struct:__anon71
instsize	libstar/vhash.h	/^	int		instsize;		\/\/ node의 instance size$/;"	m	struct:__anon105
instsize	libstar/xindex.h	/^	int		instsize;		\/\/ 데이터 블록 유닛 크기$/;"	m	struct:__anon137
instsize	libstar/xlist.h	/^	int		instsize;$/;"	m	struct:xlist
instvec	libstar/vhash.h	/^	char		*instvec[MAX_VHASH_TABLE];	\/\/ 최대 100개 테이블이 생성되게...$/;"	m	struct:__anon105
int16_t	libstar/type.h	/^typedef short			int16_t;$/;"	t
int64str	libstar/xstr.c	/^char	*int64str(longlong_t ll, char *buf)$/;"	f
int8_t	libstar/type.h	/^typedef char			int8_t;$/;"	t
int_value	json11/json11.cpp	/^int                       JsonValue::int_value()                 const { return 0; }$/;"	f	class:json11::JsonValue
int_value	json11/json11.cpp	/^int Json::int_value()                             const { return m_ptr->int_value();    }$/;"	f	class:json11::Json
interface_t	libstar/snoop.h	/^}	interface_t;$/;"	t	typeref:struct:__anon98
internalPriority	libstar/sflowlib.h	/^	uint            internalPriority;$/;"	m	struct:_SFSample
interpreter	libstar/snoop.h	/^	uint_t 	(*interpreter)(int, char *, int, int);$/;"	m	struct:__anon98
inv	libstar/idea.c	/^static uint16 inv(uint16 x)$/;"	f	file:
iosver	libstar/snmpdef.h	/^	char	iosver[32];$/;"	m	struct:__anon76
ip	libstar/xdb.h	/^	char		ip[32];$/;"	m	struct:__anon118
ip	libstar/xpcap.h	/^	struct ip	*ip;			\/\/ IP protocol$/;"	m	struct:__anon153	typeref:struct:__anon153::ip
ip_fragmentOffset	libstar/sflowlib.h	/^	uint            ip_fragmentOffset;$/;"	m	struct:_SFSample
ip_range	libstar/xping.c	/^int	ip_range(char *ip, char *ip1, char *ip2)$/;"	f
ip_v4	libstar/sflowlib.h	/^	struct in_addr  ip_v4;$/;"	m	union:_SFLAddress_value	typeref:struct:_SFLAddress_value::in_addr
ip_v6	libstar/sflowlib.h	/^	struct in6_addr ip_v6;$/;"	m	union:_SFLAddress_value	typeref:struct:_SFLAddress_value::in6_addr
ipaddr	libstar/snmpdef.h	/^	char	ipaddr[20];	\/\/ ip addr for this physical addr	{ ipNetToMediaEntry 3 } RW $/;"	m	struct:__anon79
ipaddr	libstar/snmpdef.h	/^	char	ipaddr[20];$/;"	m	struct:__anon80
ipaddr	libstar/xnms.h	/^	char		ipaddr[32];		\/\/ "211.47.158.0"$/;"	m	struct:xnmsnode
ipaddr	libstar/xpcap.h	/^	char		*ipaddr;		\/\/ 디바이스 IP$/;"	m	struct:__anon154
ipaddr	libstar/xsnmp.h	/^	char	ipaddr[20];		\/\/ 해당 엔트리의 주소$/;"	m	struct:__anon161
ipaddr	libstar/xsnmp.h	/^	char	ipaddr[20];$/;"	m	struct:__anon160
ipaddr	libstar/xsock.h	/^	char		ipaddr[20];$/;"	m	struct:__anon166
ipaddr6	libstar/xsock.h	/^	char		ipaddr6[64];$/;"	m	struct:__anon166
ipc_client_init	libstar/xsock.h	110;"	d
ipc_server_init	libstar/xsock.h	109;"	d
ipdst	libstar/sflowlib.h	/^	SFLAddress      ipdst;$/;"	m	struct:_SFSample
iphash	libstar/gw.h	/^	hash_t	*iphash;		\/\/ IP routing을 위한 hash. C-class 또는 IP 지정 가능$/;"	m	struct:gwinfo
iphash	libstar/xicmp.h	/^	vhash_t		*iphash;		\/\/ IP가 들어있는 hash table - multi ping용 $/;"	m	struct:__anon136
iphdr	libstar/sflowlib.h	/^struct iphdr$/;"	s
iphdrlen	libstar/xpcap.h	/^	int		iphdrlen;		\/\/ IP 헤더 기이 $/;"	m	struct:__anon153
iplen	libstar/xpcap.h	/^	int		iplen;			\/\/ 헤더를 제외한 IP 블록의 크기 $/;"	m	struct:__anon153
iprouting	libstar/xsock.h	/^	int		iprouting;$/;"	m	struct:__anon166
ipsrc	libstar/sflowlib.h	/^	SFLAddress      ipsrc;$/;"	m	struct:_SFSample
ipv4	libstar/sflowlib.h	/^	SFLSampled_ipv4 ipv4;$/;"	m	union:_SFLFlow_type
ipv4addr	libstar/type.h	/^typedef uint		ipv4addr;$/;"	t
ipv6	libstar/sflowlib.h	/^	SFLSampled_ipv6 ipv6;$/;"	m	union:_SFLFlow_type
is_array	json11/json11.hpp	/^    bool is_array()  const { return type() == ARRAY; }$/;"	f	class:json11::final
is_attached	libstar/ocilib.h	/^	unsigned	is_attached:1;	\/* hels to determine if we should detach from the server when closing\/freeing the connection *\/$/;"	m	struct:ociconn
is_bool	json11/json11.hpp	/^    bool is_bool()   const { return type() == BOOL; }$/;"	f	class:json11::final
is_broken	libstar/netbios.c	/^	int		is_broken;$/;"	m	struct:__anon50	file:
is_copy_assignable	json11/test.cpp	/^CHECK_TRAIT(is_copy_assignable<Json>);$/;"	v
is_copy_constructible	json11/test.cpp	/^CHECK_TRAIT(is_copy_constructible<Json>);$/;"	v
is_cursor	libstar/ocilib.h	/^	ub2		is_cursor;	\/* column contains a cursor *\/$/;"	m	struct:__anon61
is_descr	libstar/ocilib.h	/^	ub2		is_descr;	\/* column contains a descriptor *\/$/;"	m	struct:__anon61
is_nothrow_default_constructible	json11/test.cpp	/^CHECK_TRAIT(is_nothrow_default_constructible<Json>);$/;"	v
is_nothrow_destructible	json11/test.cpp	/^CHECK_TRAIT(is_nothrow_destructible<Json>);$/;"	v
is_nothrow_move_assignable	json11/test.cpp	/^CHECK_TRAIT(is_nothrow_move_assignable<Json>);$/;"	v
is_nothrow_move_constructible	json11/test.cpp	/^CHECK_TRAIT(is_nothrow_move_constructible<Json>);$/;"	v
is_null	json11/json11.hpp	/^    bool is_null()   const { return type() == NUL; }$/;"	f	class:json11::final
is_number	json11/json11.hpp	/^    bool is_number() const { return type() == NUMBER; }$/;"	f	class:json11::final
is_object	json11/json11.hpp	/^    bool is_object() const { return type() == OBJECT; }$/;"	f	class:json11::final
is_open	libstar/ocilib.h	/^	unsigned	is_open;	\/* hels to determine if the connection is dead or not *\/$/;"	m	struct:ociconn
is_persistent	libstar/ocilib.h	/^	unsigned	is_persistent:1;	\/* self-descriptive *\/$/;"	m	struct:ociconn
is_string	json11/json11.hpp	/^    bool is_string() const { return type() == STRING; }$/;"	f	class:json11::final
isarray	myjson/json2.c	/^bool json::isarray(const string token)$/;"	f	class:json
isconstant	myjson/json.c	/^int	isconstant(const char *data)$/;"	f
isconstant	myjson/json.h	/^	int isconstant(const char *data)$/;"	f	class:json
isconstant	myjson/json2.c	/^int	isconstant(const char *data)$/;"	f
isfrag	libstar/xpcap.h	/^	int		isfrag;			\/\/ Fragmentation이면 1$/;"	m	struct:__anon153
ishostorder	libstar/xflowlib.h	/^	int		ishostorder;$/;"	m	struct:__anon129
isipaddr	libstar/xstr.c	/^int	isipaddr(char *pName)$/;"	f
isjsonobj	myjson/json2.c	/^bool json::isjsonobj(const string token)$/;"	f	class:json
islocal	libstar/snmpdef.h	/^	int	islocal;		\/\/ 로컬 포트이면 1$/;"	m	struct:__anon92
isnumber	myjson/json2.c	/^bool json::isnumber(const string token)$/;"	f	class:json
isnumstr	myjson/json.c	/^int	isnumstr(const char *data)$/;"	f
isnumstr	myjson/json.h	/^	int isnumstr(const char *data)$/;"	f	class:json
isnumstr	myjson/json2.c	/^int	isnumstr(const char *data)$/;"	f
ispublic	hdaclib.h	/^	bool	ispublic;		\/\/ true if public data$/;"	m	struct:__anon6
issnmpup	libstar/xnms.c	/^static	int	issnmpup(xnmsnode_t *xn)$/;"	f	file:
isstatic	libstar/array.h	/^	int		isstatic;		\/\/ 어레이 내용 고정이면 1 (add시 빈자리에 추가 delete시 내용만 clear)$/;"	m	struct:__anon27
isstring	libstar/array.h	/^	int		isstring;		\/\/ 문자열 배열이면 1$/;"	m	struct:__anon27
issue	rpc.h	/^	string issue(const char *addr, const char *asset_params, const double quantity, const double smallest_unit = 1, const double native_amount = 0, const char *custom_fields = "")$/;"	f	class:hdac
issue_token	contract.c	/^int	hdac_admin::issue_token(const char *addr, const char *tokenname, const double amount, const double unit)$/;"	f	class:hdac_admin
issuefrom	rpc.h	/^	string issuefrom(const char *fromaddr, const char *toaddr, const char *asset_params, const double quantity, const double smallest_unit = 1, const double native_amount = 0, const char *custom_fields = "")$/;"	f	class:hdac
issuemore	rpc.h	/^	string issuemore(const char *addr, const char *asset_id, const double quantity, const double native_amount = 0, const char *custom_fields = "")$/;"	f	class:hdac
issuemorefrom	rpc.h	/^	string issuemorefrom(const char *fromaddr, const char *toaddr, const char *asset_id, const double quantity, const double native_amount = 0, const char *custom_fields = "")$/;"	f	class:hdac
istacacs	libstar/xtn.h	/^	int		istacacs;	\/\/ TACACS 모드면 1 $/;"	m	struct:xtn
istap	libstar/xpcap.h	/^	int		istap;			\/\/ TAB인 경우 1$/;"	m	struct:__anon154
istcp	libstar/snmpdef.h	/^	int	istcp;			\/\/ TCP == 1$/;"	m	struct:__anon92
isvirtual	libstar/snmpdef.h	/^	uint		isvirtual;		\/\/ Virtual Server 정보면 1 $/;"	m	struct:__anon96
iswin	libstar/xapp.h	/^	int		iswin;		\/\/ 윈도우면 1 (\\r\\n)$/;"	m	struct:__anon113
items	myjson/json.h	/^	int items()$/;"	f	class:json
itimer	libstar/proflib.c	/^	struct itimerval itimer;$/;"	m	struct:wrapper_s	typeref:struct:wrapper_s::itimerval	file:
itv	libstar/loglib.h	/^	int		itv;		\/\/ 파일 읽는 주기 $/;"	m	struct:__anon45
itvsec	libstar/snmpdef.h	/^	int		itvsec;$/;"	m	struct:__anon96
itvsec	libstar/snmpdef.h	/^	int	itvsec;$/;"	m	struct:__anon78
itvsec	libstar/xnms.h	/^	int		itvsec;			\/\/ 스캐닝 주기..$/;"	m	struct:__anon145
j	lib/rc4.h	/^    uint32_t     j;$/;"	m	struct:__anon18
js_tx	libstar/snmpdef.h	/^	float		js_tx;			\/\/ Total number of javascripts sent to geniune clients. $/;"	m	struct:__anon96
js_tx_sum	libstar/snmpdef.h	/^	uint64		js_tx_sum;		\/\/ Total number of javascripts sent to geniune clients. Counter64(70 - cntr64)$/;"	m	struct:__anon96
json	json2.h	/^	json()		{ clear(); }$/;"	f	class:json
json	json2.h	/^class json {$/;"	c
json	myjson/json.h	/^	json()	{ list = NULL; memset(&jstat, 0, sizeof(jstat)); }$/;"	f	class:json
json	myjson/json.h	/^	json(class json &jsdata) { json(); list = json_copy(jsdata.list, 999999); }$/;"	f	class:json
json	myjson/json.h	/^	json(json_t *newlist) { json(); list = newlist; }$/;"	f	class:json
json	myjson/json.h	/^	json(string jsonstr) { json(); list = parse(jsonstr.c_str()); }$/;"	f	class:json
json	myjson/json.h	/^class json {$/;"	c
json	myjson/json2.h	/^	json()		{ clear(); }$/;"	f	class:json
json	myjson/json2.h	/^class json {$/;"	c
json11	json11/json11.cpp	/^namespace json11 {$/;"	n	file:
json11	json11/json11.hpp	/^namespace json11 {$/;"	n
json_add_tail	myjson/json.c	/^json_t	*json_add_tail(json_t *node, json_t *sub)$/;"	f
json_copy	myjson/json.c	/^json_t	*json_copy(const json_t *src, int ncopy, int opt)$/;"	f
json_dump	myjson/json.c	/^int	json_dump(const json_t *list, FILE *outfp, int nspc, int opt)$/;"	f
json_file_test	myjson/test.c	/^void	json_file_test()$/;"	f
json_find	myjson/json.c	/^json_t	*json_find(const json_t *list, const char *name, int opt)$/;"	f
json_find_at	myjson/json.c	/^char	*json_find_at(const char *jsonstr, const char *name, const int nth, char *outbuf, size_t outbuflen)$/;"	f
json_find_sub	myjson/json.c	/^static	json_t	*json_find_sub(const json_t *list, const char *name, json_t *allnode, int opt)$/;"	f	file:
json_find_value	myjson/json.c	/^char	*json_find_value(const json_t *list, const char *name, char *outbuf, size_t outbuflen, int opt)$/;"	f
json_free	myjson/json.c	/^void	json_free(json_t *list)$/;"	f
json_get	myjson/json.c	/^json_t	*json_get(const json_t *list, int nth)$/;"	f
json_get_name	myjson/json.c	/^json_t	*json_get_name(const json_t *list, const char *name)$/;"	f
json_get_name_value	myjson/json.c	/^char	*json_get_name_value(const json_t *list, const char *name, char *outbuf, int outbuflen)$/;"	f
json_get_range	myjson/json.c	/^json_t	*json_get_range(const json_t *list, int from, int nitem)$/;"	f
json_get_range_value	myjson/json.c	/^char	*json_get_range_value(const json_t *list, int from, int nitem, char *outbuf, int outbuflen)$/;"	f
json_get_value	myjson/json.c	/^char	*json_get_value(const json_t *list, int nth, char *outbuf, int outbuflen)$/;"	f
json_items	myjson/json.c	/^int	json_items(const json_t *list, const int depth)$/;"	f
json_length	myjson/json.c	/^int	json_length(const json_t *list)$/;"	f
json_make_list	myjson/json.c	/^static	json_t	*json_make_list(char mark, int depth)$/;"	f	file:
json_parse	myjson/json.c	/^json_t	*json_parse(const char *jsonstr)$/;"	f
json_parse_find	myjson/json.c	/^json_t	*json_parse_find(const char *jsonstr, const char *name, int opt)$/;"	f
json_parse_find_value	myjson/json.c	/^char	*json_parse_find_value(const char *jsonstr, const char *name, char *outbuf, size_t outbuflen, int opt)$/;"	f
json_parse_get_name_value	myjson/json.c	/^char	*json_parse_get_name_value(const char *jsonstr, const char *name, char *outbuf, int outbuflen)$/;"	f
json_parse_get_range_value	myjson/json.c	/^char	*json_parse_get_range_value(const char *jsonstr, int from, int nitem, char *outbuf, int outbuflen)$/;"	f
json_parse_get_value	myjson/json.c	/^char	*json_parse_get_value(const char *jsonstr, int nth, char *outbuf, int outbuflen)$/;"	f
json_parse_print	myjson/json.c	/^int	json_parse_print(const char *jsonstr, FILE *outfp, int nspc)$/;"	f
json_print	myjson/json.c	/^int	json_print(const json_t *list, FILE *outfp, int nspc, int opt)$/;"	f
json_rpc_error	myjson/json.c	/^bool	json_rpc_error(const char *jsonstr)$/;"	f
json_rpc_error	myjson/json2.c	/^bool	json_rpc_error(const char *jsonstr)$/;"	f
json_serialize	myjson/json.c	/^char	*json_serialize(const json_t *list)$/;"	f
json_serialize2	myjson/json.c	/^static	char	*json_serialize2(const json_t *list, char *outbuf)$/;"	f	file:
json_size	myjson/json.c	/^int	json_size(const json_t *list, int depth)$/;"	f
json_split_token	myjson/json.c	/^static	int	json_split_token(const char *jsonstr)$/;"	f	file:
json_stat	myjson/json.c	/^jsonstat_t	*json_stat(const json_t *list, jsonstat_t *stp)$/;"	f
json_strip_string	myjson/json.c	/^char	*json_strip_string(char *str)$/;"	f
json_t	myjson/json.h	/^}	json_t;$/;"	t	typeref:struct:jsonnode
json_to_value	myjson/json.c	/^char	*json_to_value(json_t *values, char *outbuf, int outbuflen)$/;"	f
json_token_stat	myjson/json.c	/^static	int	json_token_stat(const char *jsonstr, int *ntoken, int *buflen)$/;"	f	file:
json_type	myjson/json.c	/^const	char	*json_type(int type)$/;"	f
jsonnode	json2.h	/^	jsonnode()	{ type = JSON_NONE; name = ""; value = ""; valuetype = JSON_NONE; depth = 0; }$/;"	f	class:jsonnode
jsonnode	json2.h	/^class jsonnode {$/;"	c
jsonnode	myjson/json.h	/^typedef struct jsonnode {$/;"	s
jsonnode	myjson/json2.h	/^	jsonnode()	{ type = JSON_NONE; name = ""; value = ""; valuetype = JSON_NONE; depth = 0; }$/;"	f	class:jsonnode
jsonnode	myjson/json2.h	/^class jsonnode {$/;"	c
jsonstat	json2.h	/^}	jsonstat;$/;"	t	typeref:struct:__anon13
jsonstat	myjson/json2.h	/^}	jsonstat;$/;"	t	typeref:struct:__anon183
jsonstat_t	myjson/json.h	/^}	jsonstat_t;$/;"	t	typeref:struct:__anon186
jsonstr	hdaclib.h	/^	char	*jsonstr;		\/\/ json result (allocated)$/;"	m	struct:__anon7
jsontype	json2.h	/^}	jsontype;$/;"	t	typeref:enum:__anon12
jsontype	myjson/json2.h	/^}	jsontype;$/;"	t	typeref:enum:__anon182
jstat	myjson/json.h	/^	jsonstat_t jstat;$/;"	m	class:json
kbytes	libstar/snmpdef.h	/^	float		kbytes;			\/\/ 전송량 $/;"	m	struct:__anon96
key	contract.h	/^	char	key[256];			\/\/ contract key$/;"	m	struct:__anon1
key	libstar/vhash.h	/^	ulong		key[1];		\/\/ key를 저장하기 위한 공간.$/;"	m	struct:vhashentry
key_t	libstar/shmem.h	/^typedef uint	key_t;$/;"	t
keyalloc	libstar/vhash.h	/^	uchar		keyalloc;	\/\/ 1 이면 지정된 키 길이보다 큰 경우라서 별도 메모리 할당된 것임.. key[0]에는 할당 메모리 포인터가 들어감..$/;"	m	struct:vhashentry
keylen	libstar/fhash.h	/^	int		keylen;			\/\/ 키 길이 $/;"	m	struct:__anon35
keylen	libstar/hash.h	/^	int    		keylen;		\/\/ key 영역의 길이 (align 되지 않은 크기임)$/;"	m	struct:hashentry
keylen	libstar/shash.h	/^	int		keylen;			\/\/ 키 길이 $/;"	m	struct:__anon71
keylen	libstar/vhash.h	/^	uint    	keylen;		\/\/ key 영역의 길이 (align 되지 않은 크기임)$/;"	m	struct:vhashentry
keyname	hdaclib.h	/^	char	keyname[128];		\/\/ document searching key$/;"	m	struct:__anon6
keyname	hdaclib.h	/^	char	keyname[128];		\/\/ document searching key$/;"	m	struct:__anon7
keyp	libstar/xindex.h	/^	uint	*keyp;			\/\/ 키 저장 공간 (N번째가 instp[n]과 대응)$/;"	m	struct:__anon137
keypoolrefill	rpc.h	/^	string keypoolrefill(const int newsize = 100)$/;"	f	class:hdac
killapp	libstar/xutil.c	/^int	killapp(int pid, int waitMS)$/;"	f
l	lib/sha1.c	/^    uint32_t    l [16];$/;"	m	union:__anon19	file:
l1printf	libstar/xdebug.h	135;"	d
l2printf	libstar/xdebug.h	134;"	d
l3printf	libstar/xdebug.h	133;"	d
l4printf	libstar/xdebug.h	132;"	d
l4sess_group_t	libstar/snmpdef.h	/^}	l4sess_group_t;$/;"	t	typeref:struct:__anon95
l4sess_t	libstar/snmpdef.h	/^}	l4sess_t;$/;"	t	typeref:struct:__anon96
l4type	libstar/snmpdef.h	/^	int		l4type;			\/\/ L4_ALTEON,L4_NETSCALER,L4_CISCO_ACE,L4_BIGIP$/;"	m	struct:__anon96
l5printf	libstar/xdebug.h	131;"	d
l_clihash	libstar/gwcli.c	/^hash_t	*l_clihash = NULL;$/;"	v
l_gwinfo	libstar/gwauto.c	/^gwinfo_t l_gwinfo = {0};$/;"	v
l_svrhash	libstar/gwsvr.c	/^hash_t	*l_svrhash = NULL;$/;"	v
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ and of last packet of flow$/;"	m	struct:__anon53
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ and of last packet of flow$/;"	m	struct:__anon55
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ and of last packet of flow$/;"	m	struct:__anon57
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ and of last packet of flow$/;"	m	struct:__anon59
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ sysUptime at end of flow$/;"	m	struct:struct_export_v8_1
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ sysUptime at end of flow$/;"	m	struct:struct_export_v8_2
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ sysUptime at end of flow$/;"	m	struct:struct_export_v8_3
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ sysUptime at end of flow$/;"	m	struct:struct_export_v8_4
last	libstar/nflowlib.h	/^	uint32		last;		\/\/ sysUptime at end of flow$/;"	m	struct:struct_export_v8_5
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_10
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_11
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_12
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_13
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_14
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_6
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_7
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_8
last	libstar/nflowlib.h	/^	uint32       last;	\/* and of last packet of flow *\/$/;"	m	struct:struct_export_v8_9
last_clk	libstar/xdebug.h	/^	double		last_clk;$/;"	m	struct:__anon122
last_query	libstar/ocilib.h	/^	char		*last_query;	\/* last query issued. also used to determine if this is a statement or a refcursor recieved from Oracle *\/$/;"	m	struct:ocistmt
last_routing_time	libstar/xnms.h	/^	time32		last_routing_time;	\/\/ 마지막 수집 시간 $/;"	m	struct:xnmsnode
lastcalcday	libstar/xnms.h	/^	time32		lastcalcday;		\/\/ 1 일 통계 마지막 계산 시간$/;"	m	struct:xnmsnode
lastcalchour	libstar/xnms.h	/^	time32		lastcalchour;		\/\/ 1시간 통계 마지막 게산 시간$/;"	m	struct:xnmsnode
lastcfgscantime	libstar/xnms.h	/^	time32		lastcfgscantime;	\/\/ 마지막 장비 스캔 시각 $/;"	m	struct:xnmsnode
lastchange	libstar/snmpdef.h	/^	uint	lastchange;$/;"	m	struct:__anon78
lastchecktime	libstar/loglib.h	/^	time32		lastchecktime;	\/\/ 마지막 체크 시간$/;"	m	struct:__anon45
lastcmd	libstar/xtn.h	/^	char		*lastcmd;	\/\/ 마지막 보낸 명령어 ($END_LOGIN, exit 도 별도로 callback 호출됨)$/;"	m	struct:xtn
lastexectime	libstar/xdb.h	/^	time32		lastexectime;	\/\/ xdb_exec() 최종 실행 시각 (종료시 0)$/;"	m	struct:__anon118
lastfailoidtime	libstar/xnms.h	/^	time32		lastfailoidtime;	\/\/ 매일 새벽에 OID 업데이트$/;"	m	struct:xnmsnode
lastfragtime	libstar/xpcap.h	/^	time32		lastfragtime;		\/\/ 마지막 fragmentation 처리한 시각 $/;"	m	struct:__anon153
lastlocktime	libstar/xlock.c	/^	time32		lastlocktime;$/;"	m	struct:__anon139	file:
lastmsg	libstar/xapp.h	/^	char		lastmsg[100];$/;"	m	struct:__anon113
lastoktime	libstar/xdb.h	/^	time32		lastoktime;	\/\/ 최종적으로 성공한 SQL 실행시간 $/;"	m	struct:__anon118
lastpingresponseMS	libstar/xnms.h	/^	float		lastpingresponseMS;	\/\/ SNMP 응답시간 - 최종 (일시적으로 SNMP 응답 없으면 이걸 사용..)$/;"	m	struct:xnmsnode
lastpingsendtime	libstar/xnms.h	/^	time32		lastpingsendtime;	\/\/ Master로 PING_FAIL 보낸 최종 시각 $/;"	m	struct:xnmsnode
lastpingtime	libstar/xnms.h	/^	time32		lastpingtime;		\/\/ 최종 PING 시각$/;"	m	struct:xnmsnode
lastportchecktime	libstar/xnms.h	/^	time32		lastportchecktime;		\/\/ 포트 장애 체크 시각 $/;"	m	struct:xnmsnode
lastprompt	libstar/xtn.h	/^	char		lastprompt[100];	\/\/ 마지막 본 알려지지 않은 prompt. 추후 동일 prompt가 오면 skip...$/;"	m	struct:xtn
lastrecvtime	libstar/udp.h	/^	time32	lastrecvtime;		\/\/ 최근 수신 시각$/;"	m	struct:__anon104
lastrecvtime	libstar/xsock.h	/^	time32		lastrecvtime;$/;"	m	struct:xsocket
lastscantime	libstar/xnms.h	/^	time32		lastscantime;		\/\/ 주기적으로 장비의 모든 정보 스캐닝 후 DB 업데이트 $/;"	m	struct:xnmsnode
lastscantime	libstar/xping.h	/^	time32		lastscantime;		\/\/ 마지막 scan 시각$/;"	m	struct:xping
lastselecttime	libstar/xdb.h	/^	time32		lastselecttime;	\/\/ xdb_selectdb() 최종 실행 시각 (종료시 0)$/;"	m	struct:__anon118
lastsendclock	libstar/xicmp.h	/^	double		*lastsendclock;		\/\/ 마지막 패킷 보낸 시각..$/;"	m	struct:__anon136
lastsendtime	libstar/xsock.h	/^	time32		lastsendtime;$/;"	m	struct:xsocket
lastsnmphwtime	libstar/xnms.h	/^	time32		lastsnmphwtime;		\/\/ 최종 H\/W 정보 수집 시각$/;"	m	struct:xnmsnode
lastsnmpsendtime	libstar/xnms.h	/^	time32		lastsnmpsendtime;	\/\/ 최종 SNMP 상태 보낸 시각 $/;"	m	struct:xnmsnode
lastsnmptime	libstar/xnms.h	/^	time32		lastsnmptime;		\/\/ 최종 I\/F 정보 수집 시각$/;"	m	struct:xnmsnode
lasttime	contract.h	/^	time_t	lasttime;$/;"	m	struct:__anon1
lasttxid	contract.h	/^	char	lasttxid[HDAC_TX_LEN];$/;"	m	struct:__anon1
lastunlocktime	libstar/xlock.c	/^	time32		lastunlocktime;$/;"	m	struct:__anon139	file:
layer	libstar/snmpdef.h	/^	char	layer[20];		\/\/ "2 3 7"$/;"	m	struct:__anon76
len	libstar/nflowlib.h	/^	uint16       len;	\/* total length of the described flowset *\/$/;"	m	struct:template_cache_entry
len	libstar/nflowlib.h	/^	uint16       len;$/;"	m	struct:otpl_field
len	libstar/nflowlib.h	/^	uint16       len;$/;"	m	struct:template_field_v9
len	libstar/re.h	/^	int		len;$/;"	m	struct:__anon66
len	libstar/sflowlib.h	/^	uint            len;$/;"	m	struct:_SFLString
len	libstar/smslib.c	/^	char	len[4];			\/\/ 메시지 길이$/;"	m	struct:__anon75	file:
len	libstar/smslib.c	/^	char	len[4];			\/\/ 메시지의 크기(전송데이터의 크기, '144 ')$/;"	m	struct:__anon74	file:
length	json2.h	/^	int	length;$/;"	m	struct:__anon13
length	lib/sha256.h	/^    uint64_t    length;$/;"	m	struct:__anon22
length	lib/sha512.h	/^    uint64_t    length;$/;"	m	struct:__anon24
length	libstar/http.c	/^	int	length;		\/\/ xxxx $/;"	m	struct:__anon43	file:
length	libstar/sflowlib.h	/^	uint            length;	\/* The length of the IP packet excluding lower layer encapsulations *\/$/;"	m	struct:_SFLSampled_ipv6
length	libstar/sflowlib.h	/^	uint            length;	\/* number of AS numbers in set\/sequence *\/$/;"	m	struct:_SFLExtended_as_path_segment
length	libstar/sflowlib.h	/^	uint            length;	\/\/ The length of the IP packet excluding lower layer encapsulations $/;"	m	struct:_SFLSampled_ipv4
length	libstar/sflowlib.h	/^	uint            length;$/;"	m	struct:_SFLCounters_sample_element
length	libstar/sflowlib.h	/^	uint            length;$/;"	m	struct:_SFLFlow_sample_element
length	myjson/json.h	/^	int	length;$/;"	m	struct:__anon186
length	myjson/json.h	/^	int length()$/;"	f	class:json
length	myjson/json2.h	/^	int	length;$/;"	m	struct:__anon183
lengthCheck	libstar/sflowlib.c	/^static	int lengthCheck(SFSample * sample, uchar * start, int len)$/;"	f	file:
letter	libstar/dvdlib.c	/^	char		letter;$/;"	m	struct:__anon28	file:
letter	libstar/oddlibwin.c	/^	char            letter;$/;"	m	struct:__anon65	file:
license	libstar/lock.h	/^	char		license[32];		\/\/ 제공된 라이센스 번호 $/;"	m	struct:__anon44
limit	libstar/xdebug.c	/^	int		limit;$/;"	m	struct:__anon120	file:
limits	hdaclib.h	/^	hdac_send_limit_t	*limits;$/;"	m	struct:__anon9
line	json2.h	/^	int	line;		\/\/ line number $/;"	m	class:tokeninfo
line	libstar/xdebug.h	/^	int	line;$/;"	m	struct:__anon124
line	myjson/json2.h	/^	int	line;		\/\/ line number $/;"	m	class:tokeninfo
lineno	libstar/fhash.h	/^	int		lineno;$/;"	m	struct:__anon35
lineno	libstar/vhash.h	/^	int		lineno;$/;"	m	struct:__anon105
lineno	libstar/xdebug.c	/^	int		lineno;$/;"	m	struct:__anon120	file:
lineno	libstar/xdebug.c	/^	uint	lineno;$/;"	m	struct:__anon121	file:
lineno	libstar/xlock.h	/^	int		lineno;		\/\/ line number of lock request file $/;"	m	struct:__anon141
lineno	libstar/xssl.h	/^	int		lineno;$/;"	m	struct:__anon167
lineno	libstar/xtime.c	/^	int		lineno;$/;"	m	struct:__anon170	file:
lineno	libstar/xtime.h	/^	int		lineno;$/;"	m	struct:__anon173
linepos	json2.h	/^	int	linepos;	\/\/ position in a line$/;"	m	class:tokeninfo
linepos	myjson/json2.h	/^	int	linepos;	\/\/ position in a line$/;"	m	class:tokeninfo
list	myjson/json.h	/^	json_t *list;$/;"	m	class:json
listaccounts	rpc.h	/^	string listaccounts(const int minconf = 1, const bool includeWatchonly = false)$/;"	f	class:hdac
listaddresses	rpc.h	/^	string listaddresses(const char *addrs = "*", const bool verbose = false, const long int count = INT_MAX, const int start = 0)$/;"	f	class:hdac
listaddressgroupings	rpc.h	/^	string listaddressgroupings()$/;"	f	class:hdac
listaddresstxs	rpc.h	/^	string listaddresstxs(const char *addr, const int count = 10, const int skip = 0, const bool verbose = false)$/;"	f	class:hdac
listassets	rpc.h	/^	string listassets(const char *asset_id, const bool verbose = false, const long int count = INT_MAX, const int start = 0)$/;"	f	class:hdac
listassettxs	rpc.h	/^	string listassettxs(const char *asset_id, const bool verbose = false, const int count = 10, const int start = 0, const bool local_ordering = false)$/;"	f	class:hdac
listblocks	rpc.h	/^	string listblocks(const char *block_set_id, const bool verbose = false)$/;"	f	class:hdac
listenfd	libstar/xssl.h	/^	int		listenfd;$/;"	m	struct:__anon167
listloc	libstar/xlist.h	/^	char		listloc[128];	\/\/ 호출 위치 $/;"	m	struct:xlist
listlockunspent	rpc.h	/^	string listlockunspent()$/;"	f	class:hdac
listpermissions	rpc.h	/^	string listpermissions(const char *perm = "", const char *addr = "*", const bool verbose = false)$/;"	f	class:hdac
listreceivedbyaccount	rpc.h	/^	string listreceivedbyaccount(const int minconf = 1, const bool includeempty = false, const bool includeWatchonly = false)$/;"	f	class:hdac
listreceivedbyaddress	rpc.h	/^	string listreceivedbyaddress(const int minconf = 1, const bool includeempty = false, const bool includeWatchonly = false)$/;"	f	class:hdac
listsinceblock	rpc.h	/^	string listsinceblock(const char *blockhash = "", const int target_confirms = 1, const bool includeWatchonly = false)$/;"	f	class:hdac
listsize	json2.h	/^	size_t listsize()	{ return m_list.size(); }$/;"	f	class:json
listsize	myjson/json2.h	/^	size_t listsize()	{ return m_list.size(); }$/;"	f	class:json
liststreamblockitems	rpc.h	/^	string liststreamblockitems(const char *stream_id, const char *block_set_id, const bool verbose = false, const long int count = INT_MAX, const int start = 0)$/;"	f	class:hdac
liststreamitems	rpc.h	/^	string liststreamitems(const char *stream_id, const bool verbose = false, const long int count = INT_MAX, const int start = 0, const bool local_ordering = false)$/;"	f	class:hdac
liststreamkeyitems	rpc.h	/^	string liststreamkeyitems(const char *stream_id, const char *stream_key, const bool verbose = false, const long int count = 10, const int start = 0, const bool local_ordering = false)$/;"	f	class:hdac
liststreamkeys	rpc.h	/^	string liststreamkeys(const char *stream_id, const char *stream_key = "*", const bool verbose = false, const long int count = INT_MAX, const int start = 0, const bool local_ordering = false)$/;"	f	class:hdac
liststreampublisheritems	rpc.h	/^	string liststreampublisheritems(const char *stream_id, const char *addr, const bool verbose = false, const int count = 10, const int start = 0, const bool local_ordering = false)$/;"	f	class:hdac
liststreampublishers	rpc.h	/^	string liststreampublishers(const char *stream_id, const char *addrs = "*", const bool verbose = false, const long int count = INT_MAX, const int start = 0, const bool local_ordering = false)$/;"	f	class:hdac
liststreams	rpc.h	/^	string liststreams(const char *stream_id = "*", const bool verbose = false, const long int count = INT_MAX, const int start = 0)$/;"	f	class:hdac
listtxs	rpc.h	/^	string listtxs(const char *account, const int count = 10, const int from = 0, const bool includeWatchonly = false)$/;"	f	class:hdac
listunspent	rpc.h	/^	string listunspent(const int minconf = 1, const int maxconf = 9999999, const char *addrs = "")$/;"	f	class:hdac
listwallettxs	rpc.h	/^	string listwallettxs(const int count = 10, const int skip = 0, const bool includeWatchonly = false, const bool verbose = false)$/;"	f	class:hdac
lo	lib/md5.h	/^    uint32_t     lo;$/;"	m	struct:__anon16
load_address	hvm.c	/^int	load_address(hdac_t *hdac)$/;"	f
load_config	contract.c	/^int	hdac_admin::load_config(const char *cfgfile)$/;"	f	class:hdac_admin
load_entnum	libstar/xsnmptype.c	/^void	load_entnum()$/;"	f
load_nms_oid	libstar/xsnmptype.c	/^int	load_nms_oid()$/;"	f
load_nms_oid_map	libstar/xsnmptype.c	/^int	load_nms_oid_map()$/;"	f
loadsize	libstar/dvdlib.h	/^	uint		loadsize;		\/\/ 레코딩 시작할 때 크기 (DVD 교체시 recsize와 동일)$/;"	m	struct:__anon32
lob_current_position	libstar/ocilib.h	/^	int		lob_current_position;	\/* LOB internal pointer *\/ $/;"	m	struct:__anon62
lob_size	libstar/ocilib.h	/^	int		lob_size;	\/* cached LOB size. -1 = Lob wasn't initialized yet *\/$/;"	m	struct:__anon62
localAddr	libstar/snmpdef.h	/^	char		localAddr[16];$/;"	m	struct:__anon85
localAddr	libstar/snmpdef.h	/^	char	localAddr[16];$/;"	m	struct:__anon87
localPort	libstar/snmpdef.h	/^	int		localPort;$/;"	m	struct:__anon85
localPort	libstar/snmpdef.h	/^	int	localPort;$/;"	m	struct:__anon87
local_opened	contract.h	/^	bool	local_opened;$/;"	m	class:hdac_admin
local_opened	node.h	/^	bool	local_opened;$/;"	m	class:hdac_node
local_opened	node.h	/^	bool	local_opened;$/;"	m	class:hdac_virtual_device
localaddr	libstar/udp.h	/^	int	localaddr;		\/\/ Local 주소 $/;"	m	struct:__anon104
localaddr	libstar/xsock.h	/^	uint		localaddr;	\/\/ local 포트 번호 $/;"	m	struct:xsocket
localmac	libstar/xsock.h	/^	char		localmac[20];$/;"	m	struct:xsocket
localport	libstar/gw.h	/^	uint	localport;		\/\/ 접속 허용 포트 $/;"	m	struct:gwrule
localport	libstar/gw.h	/^	uint	localport;$/;"	m	struct:__anon40
localport	libstar/udp.h	/^	int	localport;		\/\/ Local 포트 $/;"	m	struct:__anon104
localport	libstar/xsock.h	/^	int		localport;	\/\/ local 포트 번호 $/;"	m	struct:xsocket
localpref	libstar/sflowlib.h	/^	uint            localpref;	\/* LocalPref associated with this route *\/$/;"	m	struct:_SFLExtended_gateway
localpref	libstar/sflowlib.h	/^	uint            localpref;$/;"	m	struct:_SFSample
location	libstar/snmpdef.h	/^	char	location[34];		\/\/ 120330 - contact를 serial로 변경 $/;"	m	struct:__anon76
lock	libstar/array.h	/^	xlock_t		lock;$/;"	m	struct:__anon27
lock	libstar/fhash.h	/^	xlock_t		lock;$/;"	m	struct:__anon35
lock	libstar/proflib.c	/^	pthread_mutex_t lock;$/;"	m	struct:wrapper_s	file:
lock	libstar/worm.h	/^	xlock_t		lock;			\/\/ socket 보내고 받을 때 한번에 하나씩만..$/;"	m	struct:__anon109
lock	libstar/xdb.h	/^	xlock_t		lock;$/;"	m	struct:__anon118
lock	libstar/xindex.h	/^	xlock_t		lock;$/;"	m	struct:__anon137
lock	libstar/xlist.h	/^	xlock_t		lock;		\/\/ 멀티쓰레드용 락$/;"	m	struct:xlist
lock	libstar/xnms.h	/^	xlock_t		lock;$/;"	m	struct:__anon149
lock	libstar/xqueue.h	/^	xlock_t	lock;$/;"	m	struct:__anon156
lock	libstar/xtn.h	/^	xlock_t		lock;$/;"	m	struct:xtn
lockcheck	libstar/lock.c	/^int	lockcheck(starserial_t *lockp, char *passwd, int *expireday, int display, uint masteraddr)$/;"	f
lockcount	libstar/xlock.c	/^	int		lockcount;		\/\/ 이 곳에서 lock이 몇번 걸려있는지... $/;"	m	struct:__anon139	file:
lockdata_t	libstar/xlock.c	/^}	lockdata_t;$/;"	t	typeref:struct:__anon139	file:
lockfile	libstar/xlock.c	/^	char		lockfile[40];$/;"	m	struct:__anon139	file:
lockline	libstar/xlock.c	/^	int		lockline;$/;"	m	struct:__anon139	file:
lockptr	libstar/xlock.c	/^	xlock_t		*lockptr;		\/\/ 나중에 비교용으로...$/;"	m	struct:__anon139	file:
lockunspent	rpc.h	/^	string lockunspent(const bool unlock, const char *tx)$/;"	f	class:hdac
log_agent_alive	libstar/loglib.c	/^int	log_agent_alive(logparam_t *param)$/;"	f
log_agent_process	libstar/loglib.c	/^int	log_agent_process(logparam_t *param, logpathdata_t *lpdp, char *path)$/;"	f
log_agent_recursive_scan	libstar/loglib.c	/^int	log_agent_recursive_scan(logparam_t *param, logpathdata_t *lpdp, char *logdir, re_t *repath, re_t *refile)$/;"	f
log_agent_run	libstar/loglib.c	/^int	log_agent_run(logparam_t *param)$/;"	f
log_agent_scan	libstar/loglib.c	/^int	log_agent_scan(logparam_t *param, logpathdata_t *lpdp, char *logdir, re_t *repath)$/;"	f
log_agent_send	libstar/loglib.c	/^int	log_agent_send(int sockfd, char *type, char *path, long pos, char *databuf)$/;"	f
log_master_run	libstar/loglib.c	/^int	log_master_run(logparam_t *param)$/;"	f
log_master_save_file	libstar/loglib.c	/^int	log_master_save_file(logparam_t *param, char *ipaddr, char *type, char *path, char *pos, char *rec)$/;"	f
logdata_t	libstar/xdebug.h	/^} logdata_t;$/;"	t	typeref:struct:__anon126
logfixname	libstar/xdebug.c	/^char	*logfixname(char *logfile, time_t tm)$/;"	f
logparam	libstar/loglib.h	/^typedef struct logparam {$/;"	s
logparam_t	libstar/loglib.h	/^}	logparam_t;$/;"	t	typeref:struct:logparam
logpath	libstar/loglib.h	/^	char		logpath[256];	\/\/ 폴더 패스명 $/;"	m	struct:__anon45
logpathdata_t	libstar/loglib.h	/^}	logpathdata_t;$/;"	t	typeref:struct:__anon45
logpathlist	libstar/loglib.h	/^	logpathdata_t	*logpathlist[MAX_EVLOG];$/;"	m	struct:logparam
logposfile	libstar/loglib.h	/^	char		logposfile[200];$/;"	m	struct:logparam
logprintf	libstar/xdebug.h	322;"	d
logprintf	libstar/xdebug.h	324;"	d
logsavefile	libstar/loglib.h	/^	char		logsavefile[200];$/;"	m	struct:logparam
logsavepath	libstar/loglib.h	/^	char		logsavepath[200];$/;"	m	struct:logparam
longlong_t	libstar/type.h	/^typedef LONGLONG		longlong_t;$/;"	t
longlong_t	libstar/type.h	/^typedef long long		longlong_t;$/;"	t
loopcheck	libstar/xdebug.h	288;"	d
loopcurentry	libstar/vhash.h	/^	int             loopcurentry;		\/\/ vhash_first() \/ vhash_next()$/;"	m	struct:__anon106
loopcurtable	libstar/vhash.h	/^	int		loopcurtable;		\/\/ vhash_first() \/ vhash_next()$/;"	m	struct:__anon106
low16	libstar/idea.c	24;"	d	file:
lprintf	libstar/xdebug.h	136;"	d
lseek64	libstar/io64.h	30;"	d
lstk	libstar/sflowlib.h	/^	SFLLabelStack   lstk;$/;"	m	struct:_SFSample
m_buf1	libstar/xsnmp.h	/^	char		m_buf1[256], m_buf2[256];$/;"	m	class:CXSnmp
m_buf2	libstar/xsnmp.h	/^	char		m_buf1[256], m_buf2[256];$/;"	m	class:CXSnmp
m_count	json2.h	/^	int m_count[JSON_MAX_NEST];$/;"	m	class:json
m_count	myjson/json2.h	/^	int m_count[JSON_MAX_NEST];$/;"	m	class:json
m_ht	libstar/hash.h	/^	hash_t	*m_ht;$/;"	m	class:CHash
m_list	json2.h	/^	vector<jsonnode> m_list;$/;"	m	class:json
m_list	myjson/json2.h	/^	vector<jsonnode> m_list;$/;"	m	class:json
m_ptr	json11/json11.hpp	/^    std::shared_ptr<JsonValue> m_ptr;$/;"	m	class:json11::final
m_srcstr	json2.h	/^	string	m_srcstr;		\/\/ source json string$/;"	m	class:json
m_srcstr	myjson/json2.h	/^	string	m_srcstr;		\/\/ source json string$/;"	m	class:json
m_tokenlist	json2.h	/^	vector<tokeninfo> m_tokenlist;	\/\/ token list$/;"	m	class:json
m_tokenlist	myjson/json2.h	/^	vector<tokeninfo> m_tokenlist;	\/\/ token list$/;"	m	class:json
m_value	json11/json11.cpp	/^    const T m_value;$/;"	m	class:json11::Value	file:
m_xl	libstar/xlist.h	/^	xlist_t	*m_xl;$/;"	m	class:CXList
m_xloop	libstar/xlist.h	/^	xlistloop_t m_xloop;$/;"	m	class:CXList
m_xnms	libstar/xnms.h	/^	xnms_t		*m_xnms;$/;"	m	class:CXNms
m_xs	libstar/xsnmp.h	/^	xsnmp_t		*m_xs;$/;"	m	class:CXSnmp
mac	libstar/xsock.h	/^	char		mac[20];$/;"	m	struct:__anon166
mac2str	libstar/xstr.c	/^char    *mac2str(uchar *mac, char *macstr)$/;"	f
mac_hdr_fixed_size	libstar/snoop.h	/^	uint_t	mac_hdr_fixed_size;$/;"	m	struct:__anon98
mac_type	libstar/snoop.h	/^	uint_t	mac_type;$/;"	m	struct:__anon98
maconly	libstar/lock.h	/^	int		maconly;		\/\/ MAC 만으로 비교함 - spr은 expire나 license 번호 없음 $/;"	m	struct:__anon44
main	ctadmin.c	/^int	main(int ac, char *av[])$/;"	f
main	ctexec.c	/^int	main(int ac, char *av[])$/;"	f
main	ctsend.c	/^int	main(int ac, char *av[])$/;"	f
main	dumphdac.c	/^int	main()$/;"	f
main	hvm.c	/^int	main(int ac, char *av[])$/;"	f
main	json11/test.cpp	/^int main(int argc, char **argv) {$/;"	f
main	json11/xx.cpp	/^int main()$/;"	f
main	lib/test_base58.c	/^int	main(int ac, char **av)$/;"	f
main	lib/test_hashlib.c	/^int	main(void)$/;"	f
main	lib/test_md5.c	/^int	main(int ac, char **av)$/;"	f
main	lib/test_rc4.c	/^int	main(int ac, char **av)$/;"	f
main	lib/test_sha1.c	/^int	main(int ac, char **av)$/;"	f
main	lib/test_sha256.c	/^int	main(int ac, char **av)$/;"	f
main	lib/test_sha512.c	/^int	main(int ac, char **av)$/;"	f
main	libstar/xhash.c	/^int main()$/;"	f
main	myjson/test.c	/^int	main(int ac, char *av[])$/;"	f
main	myjson/test2.c	/^int	main(int ac, char *av[])$/;"	f
main	test.c	/^int	main()$/;"	f
majoralarm	libstar/xnms.h	/^	char		majoralarm[10];		\/\/ .12$/;"	m	struct:__anon147
makekey	libstar/idea.c	/^static	void makekey(word16 * key, char *passwd)$/;"	f	file:
maketime	libstar/xtime.c	/^time_t	maketime(int year, int mon, int day, int hour, int min, int sec)$/;"	f
manual_speed	libstar/snmpdef.h	/^	int		manual_speed;		\/\/ 수동 설정된 speed면 1$/;"	m	struct:__anon77
manual_speed	libstar/snmpdef.h	/^	int	manual_speed;		\/\/ 수동 설정된 speed면 1$/;"	m	struct:__anon78
map	contract.h	/^	hdac_map_t	map;$/;"	m	class:hdac_contract
mark	libstar/worm.h	/^	char		mark[8];$/;"	m	struct:__anon108
mark	libstar/xpcap.h	/^	uint		mark;			\/\/ 정상적인 패킷 헤더인지 구분. 0x61201394$/;"	m	struct:__anon152
marked_tos	libstar/nflowlib.h	/^	uint8        marked_tos;	\/* tos of pkts that exceeded the contract *\/$/;"	m	struct:struct_export_v8_6
marked_tos	libstar/nflowlib.h	/^	uint8        marked_tos;	\/* tos of pkts that exceeded the contract *\/$/;"	m	struct:struct_export_v8_7
marked_tos	libstar/nflowlib.h	/^	uint8        marked_tos;	\/* tos of pkts that exceeded the contract *\/$/;"	m	struct:struct_export_v8_8
mask	libstar/dvdlib.h	/^	uint		mask;$/;"	m	struct:__anon31
mask	libstar/gw.h	/^	uint	mask;			\/\/ GW_UNIQ_MASK$/;"	m	struct:__anon38
mask	libstar/gw.h	/^	uint	mask;			\/\/ GW_UNIQ_MASK$/;"	m	struct:__anon39
mask	libstar/oddlib.h	/^	uint		mask;$/;"	m	struct:__anon64
mask2	libstar/dvdlib.h	/^	uint		mask2;$/;"	m	struct:__anon31
mask2	libstar/oddlib.h	/^	uint		mask2;$/;"	m	struct:__anon64
masterip	libstar/loglib.h	/^	char		masterip[20];$/;"	m	struct:logparam
masterport	libstar/loglib.h	/^	int		masterport;$/;"	m	struct:logparam
match	libstar/re.h	/^	regmatch_t	match;$/;"	m	struct:__anon66
matched	hdaclib.h	/^	int	matched;$/;"	m	struct:__anon4
max	libstar/xutil.h	29;"	d
maxConn	libstar/snmpdef.h	/^	int	maxConn;		\/\/ 엔티티가 지원할 수 있는 TCP 접속의 총 갯수에 관한 제한. $/;"	m	struct:__anon84
max_amount	hdaclib.h	/^	double	max_amount;$/;"	m	struct:__anon8
max_conn64	libstar/snmpdef.h	/^	uint64		max_conn64;		\/\/ 누적 세션 중 최대값 $/;"	m	struct:__anon96
max_datagram	libstar/netbios.c	/^	ushort		max_datagram;$/;"	m	struct:__anon49	file:
max_depth	json11/json11.cpp	/^static const int max_depth = 200;$/;"	m	namespace:json11	file:
max_ncbs	libstar/netbios.c	/^	ushort		max_ncbs;$/;"	m	struct:__anon49	file:
max_req_per_conn	libstar/snmpdef.h	/^	int		max_req_per_conn;	\/\/ The maximum requests per connection allowed on this service. Integer32(2 - int, int32)$/;"	m	struct:__anon96
max_send	hdaclib.h	/^	int	max_send;$/;"	m	struct:__anon8
max_sessions	libstar/netbios.c	/^	ushort		max_sessions;$/;"	m	struct:__anon49	file:
maxagent	libstar/lock.h	/^	uint		maxagent;		\/\/ 최대 agent 수 (1..99999)$/;"	m	struct:__anon44
maxclients	libstar/gw.h	/^	uint	maxclients;		\/\/ 포트당 접속 최대 허용 수 $/;"	m	struct:gwrule
maxcpu	libstar/lock.h	/^	uint		maxcpu;			\/\/ CPU$/;"	m	struct:__anon44
maxflow	libstar/lock.h	/^	uint		maxflow;		\/\/ NetFlow용 (1..99999)$/;"	m	struct:__anon44
maxhops	libstar/xicmp.h	/^	int		maxhops;$/;"	m	struct:__anon136
maxiflistday	libstar/xnms.h	/^	snmpif_t	*curiflistday, *oldiflistday, *miniflistday, *maxiflistday, *avgiflistday;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
maxiflisthour	libstar/xnms.h	/^	snmpif_t	*curiflisthour, *oldiflisthour, *miniflisthour, *maxiflisthour, *avgiflisthour;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
maxkeylen	libstar/vhash.h	/^	int		maxkeylen;		\/\/ key 최대 크기...$/;"	m	struct:__anon105
maxnode	libstar/lock.h	/^	uint		maxnode;		\/\/ 최대 NMS Node 수 $/;"	m	struct:__anon44
maxnodes	libstar/hash.h	/^	int		maxnodes;	\/\/ 하나의 엔트리에 연결된 노드의 수 $/;"	m	struct:__anon41
maxnodes	libstar/xnms.h	/^	int		maxnodes;			\/\/ 최대 관리 가능 노드수 $/;"	m	struct:__anon149
maxpkt	libstar/xpcap.h	/^	int		maxpkt;			\/\/ 지정된 패킷 수만큼 받고 종료할 경우...$/;"	m	struct:__anon154
maxport	libstar/lock.h	/^	uint		maxport;		\/\/ NMS에서 최대 관리할 포트수 (1..999999)$/;"	m	struct:__anon44
maxrep	libstar/xsnmp.h	/^	int		maxrep;		\/\/ default 10$/;"	m	struct:__anon158
maxretry	libstar/xping.h	/^	int		maxretry;		\/\/ 최대 Ping 반복 회수 (최대 회수동안 Ping 반복해서 실패시 XPING_FAIL)$/;"	m	struct:xping
maxrow	libstar/xdb.h	/^	int		maxrow;		\/\/ SQL로 읽을 수 있는 row 수 $/;"	m	struct:__anon119
maxscan	libstar/xping.h	/^	int		maxscan;		\/\/ 최대 Scan 회수$/;"	m	struct:xping
maxsize	libstar/array.h	/^	int		maxsize;		\/\/ 전체 데이터 저장 가능 array 크기$/;"	m	struct:__anon27
maxsize	libstar/xindex.h	/^	int		maxsize;		\/\/ 전체 인덱스 크기$/;"	m	struct:__anon137
maxtablesize	libstar/vhash.h	/^	int		maxtablesize;		\/\/ table[] 개수 지정..$/;"	m	struct:__anon105
maxthread	libstar/thrpool.h	/^	int		maxthread;$/;"	m	struct:thrpool
md5	lib/libhash.c	/^char	*md5(char *outhash, const char *str, const size_t len)$/;"	f
md5_INCLUDED	libstar/md5.h	51;"	d
md5_append	libstar/md5.c	/^md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)$/;"	f
md5_buf	libstar/md5.c	/^char	*md5_buf(char *buf, int bufsz, char *md5buf)$/;"	f
md5_byte_t	libstar/md5.h	/^typedef unsigned char md5_byte_t; \/* 8-bit byte *\/$/;"	t
md5_file	libstar/md5.c	/^char	*md5_file(char *filename, char *md5buf)$/;"	f
md5_finish	libstar/md5.c	/^md5_finish(md5_state_t *pms, md5_byte_t digest[16])$/;"	f
md5_init	libstar/md5.c	/^md5_init(md5_state_t *pms)$/;"	f
md5_process	libstar/md5.c	/^md5_process(md5_state_t *pms, const md5_byte_t *data \/*[64]*\/)$/;"	f	file:
md5_state_s	libstar/md5.h	/^typedef struct md5_state_s {$/;"	s
md5_state_t	libstar/md5.h	/^} md5_state_t;$/;"	t	typeref:struct:md5_state_s
md5_word_t	libstar/md5.h	/^typedef unsigned int md5_word_t; \/* 32-bit word *\/$/;"	t
meanSkipCount	libstar/sflowlib.h	/^	uint            meanSkipCount;$/;"	m	struct:_SFSample
message	hdaclib.h	/^	char	message[256];$/;"	m	struct:__anon9
message	libstar/ssmtplib.h	/^	char		*message;		\/\/ 보낼 메시지 text$/;"	m	struct:__anon103
metric	libstar/xsock.h	/^	int		metric;$/;"	m	struct:__anon166
metric1	libstar/snmpdef.h	/^	int	metric1;		\/\/ primary route metric 		{ipRouteEntry 3 } RW $/;"	m	struct:__anon82
metric2	libstar/snmpdef.h	/^	int	metric2;		\/\/ alternate route metric 		{ipRouteEntry 4 } RW $/;"	m	struct:__anon82
metric3	libstar/snmpdef.h	/^	int	metric3;		\/\/ alternate route metric 		{ipRouteEntry 5 } RW $/;"	m	struct:__anon82
metric4	libstar/snmpdef.h	/^	int	metric4;		\/\/ alternate route metric 		{ipRouteEntry 6 } RW $/;"	m	struct:__anon82
metric5	libstar/snmpdef.h	/^	int	metric5;		\/\/ alternate route metric 		{ipRouteEntry 12} RW $/;"	m	struct:__anon82
mime	libstar/ssmtplib.h	/^	char		*mime;			\/\/ MIME message $/;"	m	struct:__anon103
min	libstar/xtime.c	/^	uchar    hour, min, sec;	\/\/ 0..23시간  0..59분  0..59초 $/;"	m	struct:__anon169	file:
min	libstar/xutil.h	32;"	d
miniflistday	libstar/xnms.h	/^	snmpif_t	*curiflistday, *oldiflistday, *miniflistday, *maxiflistday, *avgiflistday;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
miniflisthour	libstar/xnms.h	/^	snmpif_t	*curiflisthour, *oldiflisthour, *miniflisthour, *maxiflisthour, *avgiflisthour;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
minoralarm	libstar/xnms.h	/^	char		minoralarm[10];		\/\/ .11$/;"	m	struct:__anon147
mirror_all	libstar/xflowlib.h	/^	int		mirror_all;	\/\/ 전체 미러링 $/;"	m	struct:xflow
mirroraddr	libstar/xflowlib.h	/^	uint		mirroraddr;	\/\/ 미러링을 위한 IP$/;"	m	struct:xflow
mirrorfp	libstar/xflowlib.h	/^	udp_t		*mirrorfp;	\/\/ 패킷을 보낼 UDP socket.$/;"	m	struct:xflow
mirrorport	libstar/xflowlib.h	/^	int		mirrorport;	\/\/ 미러링 포트 (port-1)$/;"	m	struct:xflow
mix	libstar/xhash.c	92;"	d	file:
modaction	libstar/xnms.h	/^	char		modaction[10];		\/\/ .12	\/\/ 1=other 3=enable 4=disable SET: 2=reset 3=enable 4=disable $/;"	m	struct:__anon148
mode	libstar/worm.h	/^	char		mode[10];$/;"	m	struct:__anon109
mode	libstar/worm.h	/^	char		mode[8];		\/\/ rw: "r" "w" "a" "a+" 가능$/;"	m	struct:__anon110
model	libstar/snmpdef.h	/^	char	model[32];		\/\/ "2925"$/;"	m	struct:__anon76
model	libstar/xnms.h	/^	char		model[20];		\/\/ .16$/;"	m	struct:__anon147
model	libstar/xnms.h	/^	char		model[20];		\/\/ .17$/;"	m	struct:__anon148
modeldata_t	libstar/xsnmptype.c	/^}	modeldata_t;$/;"	t	typeref:struct:__anon165	file:
modindex	libstar/xnms.h	/^	int		modindex;		\/\/ 1.3.6.1.4.1.9.5.1.3.1.1.%d$/;"	m	struct:__anon148
modname	libstar/xnms.h	/^	char		modname[40];		\/\/ .13$/;"	m	struct:__anon148
modstatus	libstar/xnms.h	/^	char		modstatus[20];		\/\/ .10	\/\/ 1=other 2=ok 3=minorFault 4=MajorFault$/;"	m	struct:__anon148
modtypename	libstar/xnms.h	/^	char		modtypename[40];	\/\/ .2$/;"	m	struct:__anon148
module	libstar/lock.h	/^	char		module[16];		\/\/ S=SMS N=NMS F=NetFlow L=Log X=Linux C=Console$/;"	m	struct:__anon44
moduleinfo	libstar/snmpdef.h	/^	char	moduleinfo[20];		\/\/ Module\/Port 번호 정보 (CISCO)	\/\/ 나중에 저장시 descr에 이 내용이 없으면 descr의 끝에 붙여야 함...$/;"	m	struct:__anon78
moduleip	libstar/xnms.h	/^	char		moduleip[20];		\/\/ .22$/;"	m	struct:__anon148
mon	libstar/xtime.c	/^	uchar    mon, day;		\/\/ 1..12월  1..31일 $/;"	m	struct:__anon169	file:
monitor_running	libstar/gw.h	/^	uint	monitor_running;	\/\/ Client로부터 오는 packet을 감시하는 thread 동작중이면 1$/;"	m	struct:gwinfo
monstr	libstar/syslog.c	/^static	const char	*monstr[] = {$/;"	v	file:
morefrag	libstar/xpcap.h	/^	int		morefrag;		\/\/ 추가 fragmentation이 있는 경우 $/;"	m	struct:__anon153
move	rpc.h	/^	string move(const char *fromaccount, const char *toaccount, const double amount, const int minconf = 1, const char *comment = "")$/;"	f	class:hdac
mpls	libstar/sflowlib.h	/^	SFLExtended_mpls mpls;$/;"	m	union:_SFLFlow_type
mplsFTNDescr	libstar/sflowlib.h	/^	SFLString       mplsFTNDescr;$/;"	m	struct:_SFLExtended_mpls_FTN
mplsFTNMask	libstar/sflowlib.h	/^	uint            mplsFTNMask;$/;"	m	struct:_SFLExtended_mpls_FTN
mplsFecAddrPrefixLength	libstar/sflowlib.h	/^	uint            mplsFecAddrPrefixLength;$/;"	m	struct:_SFLExtended_mpls_LDP_FEC
mplsLabelStack	libstar/sflowlib.c	/^static	void	mplsLabelStack(SFSample * sample, const char *fieldName)$/;"	f	file:
mpls_ftn	libstar/sflowlib.h	/^	SFLExtended_mpls_FTN mpls_ftn;$/;"	m	union:_SFLFlow_type
mpls_handler	libstar/sflowlib.c	/^uint16 mpls_handler(uchar *bp, uint16 *caplen, uint16 *nl)$/;"	f
mpls_ldp_fec	libstar/sflowlib.h	/^	SFLExtended_mpls_LDP_FEC mpls_ldp_fec;$/;"	m	union:_SFLFlow_type
mpls_nextHop	libstar/sflowlib.h	/^	SFLAddress      mpls_nextHop;$/;"	m	struct:_SFSample
mpls_tunnel	libstar/sflowlib.h	/^	SFLExtended_mpls_tunnel mpls_tunnel;$/;"	m	union:_SFLFlow_type
mpls_vc	libstar/sflowlib.h	/^	SFLExtended_mpls_vc mpls_vc;$/;"	m	union:_SFLFlow_type
msdbp	libstar/xdb.h	/^	CMssql		*msdbp;		\/\/ MS-SQL DB - Windows$/;"	m	struct:__anon118
msg	libstar/smslib.c	/^	char	msg[80];		\/\/ 메시지내용$/;"	m	struct:__anon74	file:
msgid	libstar/smslib.c	/^	char	msgid[10];		\/\/ 메시지 저장코드$/;"	m	struct:__anon75	file:
msgtype	libstar/smslib.c	/^	char	msgtype[2];		\/\/ 메시지 타입$/;"	m	struct:__anon75	file:
msgtype	libstar/smslib.c	/^	char	msgtype[2];		\/\/ 메시지의 타입('01')$/;"	m	struct:__anon74	file:
msigaddr	hdaclib.h	/^	char	msigaddr[HDAC_MAX_MULTISIG][HDAC_ADDR_LEN];	\/\/ IN$/;"	m	struct:__anon10
mtime	libstar/dvdlib.h	/^	time32		mtime;			\/\/ 최종 수정된 시각 $/;"	m	struct:__anon32
mtime	libstar/loglib.h	/^	time32		mtime;		\/\/ 마지막 파일 수정 시간 $/;"	m	struct:__anon45
mtu	libstar/sflowlib.h	/^      uint16_t	mtu;$/;"	m	struct:icmphdr::__anon67::__anon69
mtu	libstar/snmpdef.h	/^	int	mtu;			\/\/ Maximum packet size $/;"	m	struct:__anon78
mtu	libstar/xsock.h	/^	int		mtu;$/;"	m	struct:__anon166
mtu_size	libstar/snoop.h	/^	uint_t	mtu_size;$/;"	m	struct:__anon98
mtx	libstar/xlock.h	/^	pthread_mutex_t	mtx;		\/\/ 이 두가지는 맨 앞에 둘 것. 초기화 때문 $/;"	m	struct:__anon140
mtx	libstar/xlock.h	/^	pthread_mutex_t mtx;		\/\/ 이 두가지는 맨 앞에 둘 것. 초기화 때문 $/;"	m	struct:__anon141
mul	libstar/idea.c	/^static	uint16 mul(uint16 a, uint16 b)$/;"	f	file:
multicast	libstar/xsock.h	/^	int		multicast;$/;"	m	struct:__anon166
multicastPkts	libstar/sflowlib.h	/^	uint            multicastPkts;$/;"	m	struct:_SFLVlan_counters
multisig_t	hdaclib.h	/^} multisig_t;$/;"	t	typeref:struct:__anon10
mutex_lock	libstar/thrpool.h	/^	pthread_mutex_t	mutex_lock;		\/\/ xlock_t on Windows$/;"	m	struct:thrpool
my_as	libstar/sflowlib.h	/^	uint            my_as;$/;"	m	struct:_SFSample
my_dblsha256	lib/base58.c	/^static	bool	my_dblsha256(void *hash, const void *data, size_t datasz)$/;"	f	file:
myaddr	hdaclib.h	/^	char	myaddr[HDAC_ADDR_LEN];		\/\/ IN my address, has privkey$/;"	m	struct:__anon10
mydb	libstar/xdb.h	/^	MYSQL		mydb;		\/\/ MySQL DB - Linux & UNIX$/;"	m	struct:__anon118
mydbp	libstar/xdb.h	/^	CDBManager	*mydbp;		\/\/ MySQL DB - Windows$/;"	m	struct:__anon118
myres	libstar/xdb.h	/^	MYSQL_RES	*myres;$/;"	m	struct:__anon119
naddr	libstar/xicmp.h	/^	int		naddr;			\/\/ Multi-ping시 파라미터 전달용...$/;"	m	struct:__anon136
name	hdaclib.h	/^	char	name[128];$/;"	m	struct:__anon8
name	hdaclib.h	/^	char	name[20];$/;"	m	struct:__anon4
name	json2.h	/^	string	name;$/;"	m	class:jsonnode
name	json2.h	/^	string	name;$/;"	m	class:tokeninfo
name	libstar/ocilib.h	/^	char		*name;		\/* column name *\/ $/;"	m	struct:__anon61
name	libstar/xtime.h	/^	char		name[40];$/;"	m	struct:__anon173
name	libstar/xtn.c	/^	const char *name;$/;"	m	struct:terminal_st	file:
name	myjson/json2.h	/^	string	name;$/;"	m	class:jsonnode
name	myjson/json2.h	/^	string	name;$/;"	m	class:tokeninfo
name_get	rpc.h	/^	string name_get(const char *name)$/;"	f	class:hdac
name_len	libstar/ocilib.h	/^	ub4		name_len;	\/* column name length *\/$/;"	m	struct:__anon61
name_service_count	libstar/netbios.c	/^	ushort		name_service_count;$/;"	m	struct:__anon47	file:
name_service_count	libstar/netbios.c	/^	ushort		name_service_count;$/;"	m	struct:__anon48	file:
name_set	rpc.h	/^	int name_set(const char *addr, const char *name)$/;"	f	class:hdac
name_unset	rpc.h	/^	int name_unset(const char *addr, const char *name)$/;"	f	class:hdac
names	libstar/netbios.c	/^	nbname_t	*names;$/;"	m	struct:__anon50	file:
narray	json2.h	/^	int	narray;$/;"	m	struct:__anon13
narray	myjson/json.h	/^	int	narray;$/;"	m	struct:__anon186
narray	myjson/json2.h	/^	int	narray;$/;"	m	struct:__anon183
nat	libstar/sflowlib.h	/^	SFLExtended_nat nat;$/;"	m	union:_SFLFlow_type
nat_dst	libstar/sflowlib.h	/^	SFLAddress      nat_dst;$/;"	m	struct:_SFSample
nat_src	libstar/sflowlib.h	/^	SFLAddress      nat_src;$/;"	m	struct:_SFSample
nb_get16	libstar/netbios.c	/^static	ushort	nb_get16(void *data)$/;"	f	file:
nb_get32	libstar/netbios.c	/^static	uint	nb_get32(void *data)$/;"	f	file:
nb_gethostname	libstar/netbios.c	/^static	void	nb_gethostname(nb_host_info_t *hostinfo, char *groupname, char *hostname, char *mac)$/;"	f	file:
nb_host_info_t	libstar/netbios.c	/^}	nb_host_info_t;$/;"	t	typeref:struct:__anon50	file:
nb_name	libstar/netbios.c	/^	char		nb_name[16];$/;"	m	struct:__anon51	file:
nb_namemangle	libstar/netbios.c	/^static	int	nb_namemangle(const char *In, char *Out, char name_type)$/;"	f	file:
nb_parseresponse	libstar/netbios.c	/^static	nb_host_info_t *nb_parseresponse(char *buff, int buffsize)$/;"	f	file:
nb_sendquery	libstar/netbios.c	/^static	int	nb_sendquery(int sock, uint hostaddr, uint tid_base)$/;"	f	file:
nb_service_t	libstar/netbios.c	/^}	nb_service_t;$/;"	t	typeref:struct:__anon51	file:
nbackup	libstar/xdebug.h	/^	int		nbackup;		\/\/ default=1$/;"	m	struct:__anon126
nbname_request_t	libstar/netbios.c	/^}	nbname_request_t;$/;"	t	typeref:struct:__anon47	file:
nbname_response_footer_t	libstar/netbios.c	/^}	nbname_response_footer_t;$/;"	t	typeref:struct:__anon49	file:
nbname_response_header_t	libstar/netbios.c	/^}	nbname_response_header_t;$/;"	t	typeref:struct:__anon48	file:
nbname_t	libstar/netbios.c	/^}	nbname_t;$/;"	t	typeref:struct:__anon46	file:
nbytes	libstar/xpcap.h	/^	uint		nbytes;			\/\/ 현재까지 받은 바이트수 $/;"	m	struct:__anon154
ncbs	libstar/netbios.c	/^	ushort		ncbs;$/;"	m	struct:__anon49	file:
ncolumns	libstar/ocilib.h	/^	int		ncolumns;	\/* number of columns in the result *\/$/;"	m	struct:ocistmt
needs_commit	libstar/ocilib.h	/^	unsigned	needs_commit:1;	\/* helps to determine if we should rollback this connection on close\/shutdown *\/$/;"	m	struct:ociconn
nerror	libstar/xsock.h	/^	int		nerror;		\/\/ 연속 에러 횟수 $/;"	m	struct:xsocket
netbios_query	libstar/netbios.c	/^int	netbios_query(uint hostaddr, char *fullname, char *hostname, char *mac, int timeoutMS)$/;"	f
netdescr	libstar/xpcap.h	/^	pcap_t		*netdescr;$/;"	m	struct:__anon154
netflow_parse	libstar/nflowlib.c	/^int	netflow_parse(xflow_t *xfp, xflow_packet_t *pktp)$/;"	f
netmask	libstar/snmpdef.h	/^	char	netmask[20];		\/\/ Mask address				{ipRouteEntry 11} RW $/;"	m	struct:__anon82
netmask	libstar/snmpdef.h	/^	char	netmask[20];$/;"	m	struct:__anon78
netmask	libstar/snmpdef.h	/^	char	netmask[20];$/;"	m	struct:__anon80
netmask	libstar/xpcap.h	/^	char		*netmask;		\/\/ 디바이스 NetMask$/;"	m	struct:__anon154
netsnmp_ds_get_int	libstar/xsnmp.h	63;"	d
netsnmp_tdomain_transport	libstar/xsnmptrap.c	42;"	d	file:
netsnmp_transport	libstar/xsnmptrap.c	41;"	d	file:
netsnmp_transport_free	libstar/xsnmptrap.c	43;"	d	file:
newtty	libstar/xstr.c	/^static	struct termio newtty = {0};$/;"	v	typeref:struct:termio	file:
next	libstar/hash.h	/^	struct hashentry *prev, *next;$/;"	m	struct:hashentry	typeref:struct:hashentry::
next	libstar/nflowlib.h	/^	struct template_cache_entry *next;$/;"	m	struct:template_cache_entry	typeref:struct:template_cache_entry::template_cache_entry
next	libstar/xlist.h	/^	struct xlistnode *next;		\/\/ 다음 리스트 포인트$/;"	m	struct:xlistnode	typeref:struct:xlistnode::xlistnode
next	myjson/json.h	/^	struct jsonnode *next;$/;"	m	struct:jsonnode	typeref:struct:jsonnode::jsonnode
nextHop	libstar/sflowlib.h	/^	SFLAddress      nextHop;	\/* Address of the next hop *\/$/;"	m	struct:_SFLExtended_mpls
nextHop	libstar/sflowlib.h	/^	SFLAddress      nextHop;$/;"	m	struct:_SFSample
nexthop	libstar/nflowlib.h	/^	ipv4addr	nexthop;	\/\/ next hop router's IP address (always 0)$/;"	m	struct:__anon59
nexthop	libstar/nflowlib.h	/^	ipv4addr	nexthop;	\/\/ next hop router's IP address$/;"	m	struct:__anon53
nexthop	libstar/nflowlib.h	/^	ipv4addr	nexthop;	\/\/ next hop router's IP address$/;"	m	struct:__anon55
nexthop	libstar/nflowlib.h	/^	ipv4addr	nexthop;	\/\/ next hop router's IP address$/;"	m	struct:__anon57
nexthop	libstar/sflowlib.h	/^	SFLAddress      nexthop;	\/* Address of the border router that should$/;"	m	struct:_SFLExtended_gateway
nexthop	libstar/sflowlib.h	/^	SFLAddress      nexthop;	\/* IP address of next hop router *\/$/;"	m	struct:_SFLExtended_router
nexthop	libstar/snmpdef.h	/^	char	nexthop[20];		\/\/ ip addr of next hop on this route	{ipRouteEntry 7 } RW $/;"	m	struct:__anon82
nexthop	libstar/xflowlib.h	/^	ipv4addr	nexthop;	\/\/ next hop router's IP address$/;"	m	struct:__anon129
nfalse	json2.h	/^	int	nfalse;$/;"	m	struct:__anon13
nfalse	myjson/json.h	/^	int	nfalse;$/;"	m	struct:__anon186
nfalse	myjson/json2.h	/^	int	nfalse;$/;"	m	struct:__anon183
nfv1_data_t	libstar/nflowlib.h	/^}	nfv1_data_t;$/;"	t	typeref:struct:__anon53
nfv1_header_t	libstar/nflowlib.h	/^}	nfv1_header_t;$/;"	t	typeref:struct:__anon52
nfv1_to_common	libstar/xflowconv.c	/^int	nfv1_to_common(ipv4addr exportaddr, register nfv1_header_t *hdr, register nfv1_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv5_data_t	libstar/nflowlib.h	/^}	nfv5_data_t;$/;"	t	typeref:struct:__anon55
nfv5_header_t	libstar/nflowlib.h	/^}	nfv5_header_t;$/;"	t	typeref:struct:__anon54
nfv5_to_common	libstar/xflowconv.c	/^int	nfv5_to_common(ipv4addr exportaddr, register nfv5_header_t *hdr, register nfv5_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv6_data_t	libstar/nflowlib.h	/^}	nfv6_data_t;$/;"	t	typeref:struct:__anon57
nfv6_header_t	libstar/nflowlib.h	/^}	nfv6_header_t;$/;"	t	typeref:struct:__anon56
nfv6_to_common	libstar/xflowconv.c	/^int	nfv6_to_common(ipv4addr exportaddr, register nfv6_header_t *hdr, register nfv6_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv7_data_t	libstar/nflowlib.h	/^}	nfv7_data_t;$/;"	t	typeref:struct:__anon59
nfv7_header_t	libstar/nflowlib.h	/^}	nfv7_header_t;$/;"	t	typeref:struct:__anon58
nfv7_to_common	libstar/xflowconv.c	/^int	nfv7_to_common(ipv4addr exportaddr, register nfv7_header_t *hdr, register nfv7_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv8_as_to_common	libstar/xflowconv.c	/^int	nfv8_as_to_common(ipv4addr exportaddr, register nfv8_header_t *hdr, register nfv8_asv2_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv8_asv2_data_t	libstar/nflowlib.h	/^}	nfv8_asv2_data_t;$/;"	t	typeref:struct:struct_export_v8_1
nfv8_dstnet_to_common	libstar/xflowconv.c	/^int	nfv8_dstnet_to_common(ipv4addr exportaddr, register nfv8_header_t *hdr, register nfv8_dstnetv2_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv8_dstnetv2_data_t	libstar/nflowlib.h	/^}	nfv8_dstnetv2_data_t;$/;"	t	typeref:struct:struct_export_v8_4
nfv8_header_t	libstar/nflowlib.h	/^}	nfv8_header_t;$/;"	t	typeref:struct:__anon60
nfv8_netmatrix_to_common	libstar/xflowconv.c	/^int	nfv8_netmatrix_to_common(ipv4addr exportaddr, register nfv8_header_t *hdr, register nfv8_netmatrixv2_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv8_netmatrixv2_data_t	libstar/nflowlib.h	/^}	nfv8_netmatrixv2_data_t;$/;"	t	typeref:struct:struct_export_v8_5
nfv8_protoport_to_common	libstar/xflowconv.c	/^int	nfv8_protoport_to_common(ipv4addr exportaddr, register nfv8_header_t *hdr, register nfv8_protoportv2_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv8_protoportv2_data_t	libstar/nflowlib.h	/^}	nfv8_protoportv2_data_t;$/;"	t	typeref:struct:struct_export_v8_2
nfv8_srcnet_to_common	libstar/xflowconv.c	/^int	nfv8_srcnet_to_common(ipv4addr exportaddr, register nfv8_header_t *hdr, register nfv8_srcnetv2_data_t *entry, register xflow_rawdata_t *common)$/;"	f
nfv8_srcnetv2_data_t	libstar/nflowlib.h	/^}	nfv8_srcnetv2_data_t;$/;"	t	typeref:struct:struct_export_v8_3
ngetiflist	libstar/xnms.h	/^	int		ngetiflist;$/;"	m	struct:xnmsnode
ngwrule	libstar/gw.h	/^	int	ngwrule;$/;"	m	struct:gwinfo
niflist	libstar/xsnmp.h	/^	int		niflist;$/;"	m	struct:__anon159
nifstatusrt	libstar/xnms.h	/^	int		nifstatusrt;$/;"	m	struct:xnmsnode
nlimit	hdaclib.h	/^	int	nlimit;$/;"	m	struct:__anon9
nmschassis_t	libstar/xnms.h	/^}	nmschassis_t;$/;"	t	typeref:struct:__anon147
nmschassiscom_t	libstar/xnms.h	/^}	nmschassiscom_t;$/;"	t	typeref:struct:__anon146
nmsmode	libstar/snmpdef.h	/^	int	nmsmode;		\/\/ NMS MODE에 따라 기능이 달라짐 $/;"	m	struct:__anon78
nmsmode	libstar/xnms.h	/^	int		nmsmode;			\/\/ 0=Normal, 1=XNMS mode (LG)$/;"	m	struct:__anon149
nmsmode	libstar/xnms.h	/^	int		nmsmode;		\/\/ NMS_MODE_xx$/;"	m	struct:xnmsnode
nmsmodule_t	libstar/xnms.h	/^}	nmsmodule_t;$/;"	t	typeref:struct:__anon148
nnode	libstar/hash.h	/^	int		nnode;		\/\/ 해쉬 엔트리에 연결된 노드의 갯수$/;"	m	struct:hashentry
nnull	json2.h	/^	int	nnull;$/;"	m	struct:__anon13
nnull	myjson/json.h	/^	int	nnull;$/;"	m	struct:__anon186
nnull	myjson/json2.h	/^	int	nnull;$/;"	m	struct:__anon183
nnumber	json2.h	/^	int	nnumber;$/;"	m	struct:__anon13
nnumber	myjson/json.h	/^	int	nnumber;$/;"	m	struct:__anon186
nnumber	myjson/json2.h	/^	int	nnumber;$/;"	m	struct:__anon183
noPorts	libstar/snmpdef.h	/^	uint		noPorts;	\/\/ 목적지 포트에 응용 프로그램이 없는 경우. 수신된 UDP 데이터 그램의 총 개수 $/;"	m	struct:__anon86
no_receive_buffer	libstar/netbios.c	/^	ushort		no_receive_buffer;$/;"	m	struct:__anon49	file:
no_transmit_buffers	libstar/netbios.c	/^	ushort		no_transmit_buffers;$/;"	m	struct:__anon49	file:
nobject	json2.h	/^	int	nobject;$/;"	m	struct:__anon13
nobject	myjson/json.h	/^	int	nobject;$/;"	m	struct:__anon186
nobject	myjson/json2.h	/^	int	nobject;$/;"	m	struct:__anon183
nodehash	libstar/xnms.h	/^	vhash_t		*nodehash;			\/\/ 현재 사용중인 엔트리에 대한 해쉬 테이블$/;"	m	struct:__anon149
nodeid	libstar/snmpdef.h	/^	int		nodeid;$/;"	m	struct:__anon85
nodeid	libstar/snmpdef.h	/^	int		nodeid;$/;"	m	struct:__anon86
nodeid	libstar/snmpdef.h	/^	int		nodeid;$/;"	m	struct:__anon96
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon76
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon78
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon79
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon80
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon81
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon82
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon83
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon84
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon87
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon91
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon92
nodeid	libstar/snmpdef.h	/^	int	nodeid;$/;"	m	struct:__anon93
nodeid	libstar/xnms.h	/^	int		nodeid;$/;"	m	struct:__anon147
nodeid	libstar/xnms.h	/^	int		nodeid;$/;"	m	struct:__anon148
nodeid	libstar/xsnmp.h	/^	int	nodeid;$/;"	m	struct:__anon161
nodeip	hdaclib.h	/^	char	nodeip[64];	\/\/ RPC IP$/;"	m	struct:__anon9
nodeip	libstar/snmpdef.h	/^	char		nodeip[20];		\/\/ Node IP$/;"	m	struct:__anon96
nodeip	libstar/snmpdef.h	/^	char	nodeip[20];			\/\/ Node IP$/;"	m	struct:__anon97
nodeip	libstar/snmpdef.h	/^	char	nodeip[20];		\/\/ 공인 IP address $/;"	m	struct:__anon78
nodeip	libstar/snmpdef.h	/^	char	nodeip[20];		\/\/ 이 노드의 대표 IP$/;"	m	struct:__anon76
nodeip	libstar/xnms.h	/^	char		nodeip[20];		\/\/ 검색된 장비의 IP$/;"	m	struct:__anon147
nodeip	libstar/xnms.h	/^	char		nodeip[20];		\/\/ 검색된 장비의 IP$/;"	m	struct:__anon148
nodeip	libstar/xnms.h	/^	char		nodeip[20];$/;"	m	struct:__anon145
nodeip	libstar/xsnmp.h	/^	char	nodeip[20];		\/\/ 검색된 장비의 IP$/;"	m	struct:__anon161
nodeip	libstar/xsnmp.h	/^	char	nodeip[20];		\/\/ 장비 SNMP 주소$/;"	m	struct:__anon160
nodetype	libstar/xsock.h	/^	char		nodetype[100];$/;"	m	struct:__anon166
noexcept	json11/json11.hpp	/^    Json() noexcept;                \/\/ NUL$/;"	m	class:json11::final
noexcept	json11/json11.hpp	/^    Json(std::nullptr_t) noexcept;  \/\/ NUL$/;"	m	class:json11::final
noexcept	json11/json11.hpp	62;"	d
nonrep	libstar/xsnmp.h	/^	int		nonrep;		\/\/ default 0$/;"	m	struct:__anon158
noreply	libstar/xtn.c	/^inline void noreply(SOCKET server, _verb verb,_option option)$/;"	f
npacket	libstar/xpcap.h	/^	uint		npacket;		\/\/ 현재까지 받은 패킷수 $/;"	m	struct:__anon154
npair	json2.h	/^	int	npair;$/;"	m	struct:__anon13
npair	myjson/json.h	/^	int	npair;$/;"	m	struct:__anon186
npair	myjson/json2.h	/^	int	npair;$/;"	m	struct:__anon183
nportchecklist	libstar/xnms.h	/^	int		nportchecklist;$/;"	m	struct:xnmsnode
nrecv	libstar/udp.h	/^	uint	nrecv;			\/\/ 누적된 수신 회수 $/;"	m	struct:__anon104
nresult	libstar/xsnmp.h	/^	int		nresult;$/;"	m	struct:__anon158
nsend	libstar/udp.h	/^	uint	nsend;			\/\/ 누적된 송신 회수 $/;"	m	struct:__anon104
nsig	hdaclib.h	/^	int	nsig;				\/\/ IN$/;"	m	struct:__anon10
nsnmpres	libstar/xnms.h	/^	int		nsnmpres;$/;"	m	struct:xnmsnode
nstring	json2.h	/^	int	nstring;$/;"	m	struct:__anon13
nstring	myjson/json.h	/^	int	nstring;$/;"	m	struct:__anon186
nstring	myjson/json2.h	/^	int	nstring;$/;"	m	struct:__anon183
nthsleep	libstar/xicmp.h	/^	int		nthsleep;		\/\/ 몇번째 패킷마다 쉴지..$/;"	m	struct:__anon136
ntrue	json2.h	/^	int	ntrue;$/;"	m	struct:__anon13
ntrue	myjson/json.h	/^	int	ntrue;$/;"	m	struct:__anon186
ntrue	myjson/json2.h	/^	int	ntrue;$/;"	m	struct:__anon183
null	json11/json11.cpp	/^    const std::shared_ptr<JsonValue> null = make_shared<JsonNull>();$/;"	m	struct:json11::Statics	file:
num	hdaclib.h	/^	int	num;		\/\/ nitem$/;"	m	struct:__anon5
num	libstar/nflowlib.h	/^	uint16       num;	\/* number of fields described into template *\/$/;"	m	struct:template_cache_entry
num	libstar/nflowlib.h	/^	uint16       num;$/;"	m	struct:template_cache
num	libstar/nflowlib.h	/^	uint16       num;$/;"	m	struct:template_hdr_v9
num	libstar/snmpdef.h	/^	int	num[IDX_MAXDATA];	\/\/ 아래 데이타 블럭의 데이타 갯수 $/;"	m	struct:__anon93
num_cfg_scan_threads	libstar/xnms.h	/^	int		num_cfg_scan_threads;		\/\/ Telnet 스캔 thread.$/;"	m	struct:__anon149
num_elements	libstar/sflowlib.h	/^	uint            num_elements;$/;"	m	struct:_SFLCounters_sample
num_elements	libstar/sflowlib.h	/^	uint            num_elements;$/;"	m	struct:_SFLCounters_sample_expanded
num_elements	libstar/sflowlib.h	/^	uint            num_elements;$/;"	m	struct:_SFLFlow_sample
num_elements	libstar/sflowlib.h	/^	uint            num_elements;$/;"	m	struct:_SFLFlow_sample_expanded
num_extended	libstar/sflowlib.h	/^	uint            num_extended;$/;"	m	struct:_SFSample
num_port_event_threads	libstar/xnms.h	/^	int		num_port_event_threads;		\/\/ 포트 장애 감시용 threads$/;"	m	struct:__anon149
num_processes	libstar/sflowlib.h	/^	uint            num_processes;$/;"	m	struct:_SFLExtended_process
num_records	libstar/sflowlib.h	/^	uint            num_records;	\/* Number of tag-len-val flow\/counter records to follow *\/$/;"	m	struct:_SFLSample_datagram_hdr
num_slow_snmp_threads	libstar/xnms.h	/^	int		num_slow_snmp_threads;		\/\/ SNMP 응답시간 늦은 장비 처리용...$/;"	m	struct:__anon149
num_snmp_threads	libstar/xnms.h	/^	int		num_snmp_threads;		\/\/ SNMP thread의 수$/;"	m	struct:__anon149
numaccepted	libstar/gw.h	/^	uint	numaccepted;		\/\/ 연결된 모든 client 수 $/;"	m	struct:gwinfo
numaccepted	libstar/gw.h	/^	uint	numaccepted;		\/\/ 현재 이 포트로 연결된 client 수 $/;"	m	struct:gwrule
number_of_names	libstar/netbios.c	/^	uchar		number_of_names;$/;"	m	struct:__anon48	file:
number_value	json11/json11.cpp	/^double                    JsonValue::number_value()              const { return 0; }$/;"	f	class:json11::JsonValue
number_value	json11/json11.cpp	/^double Json::number_value()                       const { return m_ptr->number_value(); }$/;"	f	class:json11::Json
numcol	libstar/xdb.h	/^	int		numcol;		\/\/ 해당 SQL의 column 수 $/;"	m	struct:__anon119
numcom	libstar/xnms.h	/^	int		numcom;$/;"	m	struct:__anon147
numdstaddr	libstar/gw.h	/^	int	numdstaddr;		\/\/ 도착지 주소의 수. 0이면 broadcast.$/;"	m	struct:__anon38
numdstaddr	libstar/gw.h	/^	int	numdstaddr;		\/\/ 도착지 주소의 수. 0이면 broadcast.$/;"	m	struct:__anon39
numfield	libstar/xdb.h	/^	int		numfield;		\/\/ field 개수 $/;"	m	struct:__anon116
numfield	libstar/xdb.h	/^	int		numfield;	\/\/ field 개수 $/;"	m	struct:__anon117
numif	libstar/snmpdef.h	/^	int		numif;$/;"	m	struct:__anon77
numif	libstar/snmpdef.h	/^	int	numif;			\/\/ number of I\/F includes local loopback $/;"	m	struct:__anon78
numif	libstar/snmpdef.h	/^	int	numif;$/;"	m	struct:__anon76
numif	libstar/xnms.h	/^	int		numif;$/;"	m	struct:xnmsnode
numif	libstar/xsnmp.h	/^	int		numif;			\/\/ 전체 I\/F 개수$/;"	m	struct:__anon158
numinfo	libstar/ssmtplib.h	/^	int		numinfo;$/;"	m	struct:__anon103
numitem	libstar/array.h	/^	int		numitem;		\/\/ 데이터 개수$/;"	m	struct:__anon27
numitem	libstar/fhash.h	/^	uint		numitem;		\/\/ 등록된 엔트리 수 $/;"	m	struct:__anon35
numitem	libstar/hash.h	/^	uint   		numitem;	\/\/ number of items in the table $/;"	m	struct:__anon41
numitem	libstar/shash.h	/^	uint		numitem;		\/\/ 등록된 엔트리 수 $/;"	m	struct:__anon71
numitem	libstar/vhash.h	/^	uint   		numitem;		\/\/ number of items in the table $/;"	m	struct:__anon105
numitem	libstar/xindex.h	/^	int		numitem;		\/\/ 데이터 개수$/;"	m	struct:__anon137
numoids	libstar/xsnmp.h	/^	int		numoids;		\/\/ 수집된 private OID 정보의 수 $/;"	m	struct:__anon158
numports	libstar/xnms.h	/^	int		numports;		\/\/ .14$/;"	m	struct:__anon148
numresize	libstar/array.h	/^	int		numresize;		\/\/ resize 회수$/;"	m	struct:__anon27
numrow	libstar/xdb.h	/^	int		numrow;		\/\/ 현재까지 읽은 row 수 $/;"	m	struct:__anon119
numslot	libstar/xnms.h	/^	int		numslot;		\/\/ .14 : 1~16$/;"	m	struct:__anon147
numtable	libstar/vhash.h	/^	int		numtable;			\/\/ 몇개의 테이블이 생성되었는지..$/;"	m	struct:__anon105
nvt	libstar/xtn.c	/^void nvt(SOCKET server, uchar data)$/;"	f
nwaddr	libstar/dvdlib.h	/^	int		nwaddr;			\/\/ 다음 기록 주소 $/;"	m	struct:__anon33
nxt	libstar/sflowlib.h	/^	struct _SFLCounters_sample_element *nxt;	\/* linked list *\/$/;"	m	struct:_SFLCounters_sample_element	typeref:struct:_SFLCounters_sample_element::_SFLCounters_sample_element
nxt	libstar/sflowlib.h	/^	struct _SFLFlow_sample_element *nxt;$/;"	m	struct:_SFLFlow_sample_element	typeref:struct:_SFLFlow_sample_element::_SFLFlow_sample_element
object	json11/json11.hpp	/^    typedef std::map<std::string, Json> object;$/;"	t	class:json11::final
object_items	json11/json11.cpp	/^const map<string, Json> & Json::object_items()    const { return m_ptr->object_items(); }$/;"	f	class:json11::Json
object_items	json11/json11.cpp	/^const map<string, Json> & JsonValue::object_items()              const { return statics().empty_map; }$/;"	f	class:json11::JsonValue
objectid	libstar/snmpdef.h	/^	char	objectid[64];$/;"	m	struct:__anon76
oci_connect	libstar/ocilib.c	/^ociconn_t	*oci_connect(char *username, char *password, char *new_password, char *svcname, long session_mode)$/;"	f
oci_connection_close	libstar/ocilib.c	/^int	oci_connection_close(ociconn_t *conn)$/;"	f
oci_connection_commit	libstar/ocilib.c	/^int	oci_connection_commit(ociconn_t *conn)$/;"	f
oci_connection_ping	libstar/ocilib.c	/^int	oci_connection_ping(ociconn_t *conn)$/;"	f
oci_connection_rollback	libstar/ocilib.c	/^int	oci_connection_rollback(ociconn_t *conn)$/;"	f
oci_connection_status	libstar/ocilib.c	/^int	oci_connection_status(ociconn_t *conn)$/;"	f
oci_define	libstar/ocilib.h	/^	OCIDefine	*oci_define;	\/* define handle *\/$/;"	m	struct:__anon61
oci_error	libstar/ocilib.c	/^sb4	oci_error(OCIError *errp, sword status)$/;"	f
oci_fetch_errmsg	libstar/ocilib.c	/^sb4	oci_fetch_errmsg(OCIError *error_handle, text **error_buf)$/;"	f
oci_get_data_type_name	libstar/ocilib.c	/^char	*oci_get_data_type_name(int data_type)$/;"	f
oci_lob_create	libstar/ocilib.c	/^ocidescr_t	*oci_lob_create(ociconn_t *connp, long type)$/;"	f
oci_stmt_close	libstar/ocilib.c	/^int	oci_stmt_close(ocistmt_t *stmtp)$/;"	f
oci_stmt_create	libstar/ocilib.c	/^ocistmt_t	*oci_stmt_create(ociconn_t *connp, char *sql)$/;"	f
oci_stmt_execute	libstar/ocilib.c	/^int	oci_stmt_execute(ocistmt_t *stmtp)$/;"	f
oci_stmt_fetch	libstar/ocilib.c	/^int	oci_stmt_fetch(ocistmt_t *stmtp, ub4 nrows)$/;"	f
oci_stmt_prepare	libstar/ocilib.c	/^int	oci_stmt_prepare(ocistmt_t *stmtp , char *sql)$/;"	f
ocicolumn_t	libstar/ocilib.h	/^}	ocicolumn_t;$/;"	t	typeref:struct:__anon61
ociconn	libstar/ocilib.h	/^typedef struct ociconn {$/;"	s
ociconn_t	libstar/ocilib.h	/^}	ociconn_t;$/;"	t	typeref:struct:ociconn
ocidescr_t	libstar/ocilib.h	/^}	ocidescr_t;$/;"	t	typeref:struct:__anon62
ocistmt	libstar/ocilib.h	/^typedef struct ocistmt {$/;"	s
ocistmt_t	libstar/ocilib.h	/^}	ocistmt_t;$/;"	t	typeref:struct:ocistmt
octets	libstar/sflowlib.h	/^	uint64          octets;$/;"	m	struct:_SFLVlan_counters
odd_add_write_queue	libstar/oddlibwin.c	/^long	odd_add_write_queue(char *path, long szfrom, long szto)$/;"	f
odd_check_disk_recordable	libstar/oddlibwin.c	/^static	int	odd_check_disk_recordable(int drive)$/;"	f	file:
odd_check_tray_status	libstar/oddlibwin.c	/^ODDLIB_API int odd_check_tray_status(int drvIdx)$/;"	f
odd_data_block_in_drive	libstar/oddlibwin.c	/^static	int odd_data_block_in_drive(int drive, int *blocks_in_drive)$/;"	f	file:
odd_disp_error	libstar/oddlibwin.c	/^static void odd_disp_error(LPTSTR lpszFunction)$/;"	f	file:
odd_do_sync	libstar/oddlibwin.c	/^static	int odd_do_sync(int drive, int bImm)$/;"	f	file:
odd_drive_inquiry	libstar/oddlibwin.c	/^static	int odd_drive_inquiry(int drive)$/;"	f	file:
odd_drive_ready	libstar/oddlibwin.c	/^ODDLIB_API int odd_drive_ready(int drvIdx)$/;"	f
odd_exec_write	libstar/oddlibwin.c	/^static	int odd_exec_write(int drive, BYTE * buf, int blen, int nwa)$/;"	f	file:
odd_exit	libstar/oddlibwin.c	/^ODDLIB_API	void	odd_exit(int drvidx)$/;"	f
odd_find_drive_index	libstar/oddlibwin.c	/^static	int	odd_find_drive_index(char *target_string)$/;"	f	file:
odd_free_aspi_buffer	libstar/oddlibwin.c	/^static	int	odd_free_aspi_buffer(void)$/;"	f	file:
odd_get_drive	libstar/oddlibwin.c	/^ODDLIB_API int odd_get_drive(char *target_drive_letter)$/;"	f
odd_get_free_kbytes	libstar/oddlibwin.c	/^ODDLIB_API int odd_get_free_kbytes(int drive)$/;"	f
odd_get_nwa	libstar/oddlibwin.c	/^static	int odd_get_nwa(int drive, int sess, int *nwa, int *free_block)$/;"	f	file:
odd_get_odd_device_num	libstar/oddlibwin.c	/^static	int odd_get_odd_device_num(void)$/;"	f	file:
odd_get_queue_size	libstar/oddlibwin.c	/^long	odd_get_queue_size()$/;"	f
odd_init	libstar/oddlibwin.c	/^ODDLIB_API	int	odd_init(char *drive_char)$/;"	f
odd_init_aspi	libstar/oddlibwin.c	/^static	int	odd_init_aspi()$/;"	f	file:
odd_init_aspi_buffer	libstar/oddlibwin.c	/^static	int	odd_init_aspi_buffer(void)$/;"	f	file:
odd_packet_read	libstar/oddlibwin.c	/^ODDLIB_API int odd_packet_read(int drive, int lba, BYTE * buf, int buflen)$/;"	f
odd_packet_write	libstar/oddlibwin.c	/^ODDLIB_API int odd_packet_write(int drive, BYTE * buf, int buflen)$/;"	f
odd_r_discsize	libstar/oddlibwin.c	/^	UCHAR           odd_r_discsize;$/;"	m	struct:__anon65	file:
odd_rec_init	libstar/oddlibwin.c	/^ODDLIB_API int odd_rec_init(void)$/;"	f
odd_rec_shutdown	libstar/oddlibwin.c	/^ODDLIB_API int odd_rec_shutdown(void)$/;"	f
odd_recordable	libstar/oddlibwin.c	/^ODDLIB_API int odd_recordable(int drive)$/;"	f
odd_recv_track	libstar/oddlibwin.c	/^static	int odd_recv_track(int drive, int blen)$/;"	f	file:
odd_scan	libstar/oddlibwin.c	/^static	int	odd_scan()$/;"	f	file:
odd_send_packet	libstar/oddlibwin.c	/^ODDLIB_API int odd_send_packet(int drive, BYTE * aspibuf, UINT datalen,$/;"	f
odd_set_write_page	libstar/oddlibwin.c	/^static	int odd_set_write_page(int drive, int LastSessionState)$/;"	f	file:
odd_start_drive	libstar/oddlibwin.c	/^ODDLIB_API int odd_start_drive(int drive, int bImm)$/;"	f
odd_stop_drive	libstar/oddlibwin.c	/^ODDLIB_API int odd_stop_drive(int drive, int bImm)$/;"	f
odd_test_unit_ready	libstar/oddlibwin.c	/^static	int odd_test_unit_ready(int drive)$/;"	f	file:
odd_tray_close	libstar/oddlibwin.c	/^ODDLIB_API int odd_tray_close(int drive, int bImm)$/;"	f
odd_tray_open	libstar/oddlibwin.c	/^ODDLIB_API int odd_tray_open(int drive, int bImm)$/;"	f
odd_update_changed_device	libstar/oddlibwin.c	/^static	void odd_update_changed_device(void)$/;"	f	file:
oddhdr_t	libstar/oddlib.h	/^}	oddhdr_t;$/;"	t	typeref:struct:__anon64
off	libstar/nflowlib.h	/^	uint16       off;$/;"	m	struct:otpl_field
off64_t	libstar/io64.h	31;"	d
off64_t	libstar/type.h	/^typedef __off64_t		off64_t;$/;"	t
offsetToIPV4	libstar/sflowlib.h	/^	int             offsetToIPV4;$/;"	m	struct:_SFSample
offsetToIPV6	libstar/sflowlib.h	/^	int             offsetToIPV6;$/;"	m	struct:_SFSample
oid	libstar/xsnmp.h	/^	char		oid[80];$/;"	m	struct:__anon163
oidinfo	libstar/xnms.h	/^	void		*oidinfo;		\/\/ 사용자 저으이 OID 정보. callback() 함수에서 사용자가 알아서 별도 수집해야 한다.$/;"	m	struct:xnmsnode
oidinfosize	libstar/xnms.h	/^	int		oidinfosize;$/;"	m	struct:xnmsnode
ol	libstar/xtn.c	/^} ol[] = {$/;"	v	typeref:struct:ol_st
ol_st	libstar/xtn.c	/^struct ol_st$/;"	s	file:
oldiflist	libstar/xnms.h	/^	snmpif_t	*curiflist, *oldiflist;		\/\/ 5분 단위 I\/F 통계 정보$/;"	m	struct:xnmsnode
oldiflistday	libstar/xnms.h	/^	snmpif_t	*curiflistday, *oldiflistday, *miniflistday, *maxiflistday, *avgiflistday;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
oldiflisthour	libstar/xnms.h	/^	snmpif_t	*curiflisthour, *oldiflisthour, *miniflisthour, *maxiflisthour, *avgiflisthour;	\/\/ I\/F 통계 정보$/;"	m	struct:xnmsnode
oldnumif	libstar/xnms.h	/^	int		curnumif, oldnumif;$/;"	m	struct:xnmsnode
oldnumifday	libstar/xnms.h	/^	int		daycount, curnumifday, oldnumifday;$/;"	m	struct:xnmsnode
oldnumifhour	libstar/xnms.h	/^	int		hourcount, curnumifhour, oldnumifhour;$/;"	m	struct:xnmsnode
oldnumsess	libstar/xnms.h	/^	int		curnumsess, oldnumsess;$/;"	m	struct:xnmsnode
oldnumxif	libstar/xnms.h	/^	int		curnumxif, oldnumxif;$/;"	m	struct:xnmsnode
oldpingstatus	libstar/xnms.h	/^	int		oldpingstatus;		\/\/ EV_PING_xx 이전 PING 상태 $/;"	m	struct:xnmsnode
oldsesslist	libstar/xnms.h	/^	l4sess_t	*cursesslist, *oldsesslist;	\/\/ 5분 단위 L4 Session 정보 $/;"	m	struct:xnmsnode
oldsnmpstatus	libstar/xnms.h	/^	int		oldsnmpstatus;		\/\/ EV_SNMP_xx$/;"	m	struct:xnmsnode
oldstat	libstar/xflowlib.h	/^	xflow_perfstat_t	oldstat;	\/\/ 라우터에서 유입되는 트래픽 요약 $/;"	m	struct:xflow
oldsys	libstar/xnms.h	/^	snmpsys_t	*cursys, *oldsys;		\/\/ System 정보$/;"	m	struct:xnmsnode
oldxiflist	libstar/xnms.h	/^	snmpxif_t	*curxiflist, *oldxiflist;	\/\/ 5분 단위 I\/F 통계 정보$/;"	m	struct:xnmsnode
onair	libstar/xnms.h	/^	int		onair;			\/\/ collect() 수행중이면 1 - 중복 호출 방지용 $/;"	m	struct:xnmsnode
one_min_cpu	libstar/sflowlib.h	/^	uint            one_min_cpu;	\/* 1 minute average CPU utilization *\/$/;"	m	struct:_SFLProcessor_counters
op	hdaclib.h	/^	char	op[20];$/;"	m	struct:__anon5
open	contract.h	/^	hdac_t	*open(const char *nodeip, const int port, const char *userid, const char *password)$/;"	f	class:hdac_admin
open	contract.h	/^	hdac_t	*open(const char *nodeip, const int port, const char *userid, const char *password)$/;"	f	class:hdac_contract
open	node.h	/^	hdac_t	*open(const char *nodeip, const int port, const char *userid, const char *password)$/;"	f	class:hdac_node
open	node.h	/^	hdac_t	*open(const char *nodeip, const int port, const char *userid, const char *password)$/;"	f	class:hdac_virtual_device
open_contract	contract.c	/^int	hdac_admin::open_contract(const hdac_map_t *map)$/;"	f	class:hdac_admin
open_result	myjson/test.c	/^FILE	*open_result(const char *fname, const int num)$/;"	f
opencount	libstar/xdebug.c	/^	int		opencount;$/;"	m	struct:__anon120	file:
opened	libstar/xdb.h	/^	int		opened;		\/\/ Open 된 경우 1$/;"	m	struct:__anon118
opened	libstar/xutil.h	/^	int		opened;				\/\/ open된 상태면 1$/;"	m	struct:__anon180
opentime	libstar/xdebug.c	/^	time32		opentime;$/;"	m	struct:__anon120	file:
opentime	libstar/xtn.h	/^	time32		opentime;	\/\/ Telnet 세션 open 시각 $/;"	m	struct:xtn
operator	myjson/json2.c	/^json json::operator [](const int nth)$/;"	f	class:json
operator	myjson/json2.c	/^json json::operator [](const string name)$/;"	f	class:json
operator !=	json11/json11.hpp	/^    bool operator!= (const Json &rhs) const { return !(*this == rhs); }$/;"	f	class:json11::final
operator <	json11/json11.cpp	/^    bool operator<(NullStruct) const { return false; }$/;"	f	struct:json11::NullStruct
operator <	json11/json11.cpp	/^bool Json::operator< (const Json &other) const$/;"	f	class:json11::Json
operator <=	json11/json11.hpp	/^    bool operator<= (const Json &rhs) const { return !(rhs < *this); }$/;"	f	class:json11::final
operator =	json2.h	/^	json& operator =(const json newjs)$/;"	f	class:json
operator =	json2.h	/^	json& operator =(const jsonnode node)$/;"	f	class:json
operator =	json2.h	/^	json& operator =(const string jsonstr)$/;"	f	class:json
operator =	myjson/json.h	/^	json_t *operator=(class json& src)$/;"	f	class:json
operator =	myjson/json.h	/^	json_t *operator=(const char *str)$/;"	f	class:json
operator =	myjson/json.h	/^	json_t *operator=(json_t *src)$/;"	f	class:json
operator =	myjson/json.h	/^	json_t *operator=(string str)$/;"	f	class:json
operator =	myjson/json2.h	/^	json& operator =(const json newjs)$/;"	f	class:json
operator =	myjson/json2.h	/^	json& operator =(const jsonnode node)$/;"	f	class:json
operator =	myjson/json2.h	/^	json& operator =(const string jsonstr)$/;"	f	class:json
operator ==	json11/json11.cpp	/^    bool operator==(NullStruct) const { return true; }$/;"	f	struct:json11::NullStruct
operator ==	json11/json11.cpp	/^bool Json::operator== (const Json &other) const$/;"	f	class:json11::Json
operator ==	json2.h	/^	bool operator ==(const json& cmpjson)$/;"	f	class:json
operator ==	myjson/json2.h	/^	bool operator ==(const json& cmpjson)$/;"	f	class:json
operator >	json11/json11.hpp	/^    bool operator>  (const Json &rhs) const { return  (rhs < *this); }$/;"	f	class:json11::final
operator >=	json11/json11.hpp	/^    bool operator>= (const Json &rhs) const { return !(*this < rhs); }$/;"	f	class:json11::final
operator []	json11/json11.cpp	/^const Json &              JsonValue::operator[] (const string &) const { return static_null(); }$/;"	f	class:json11::JsonValue
operator []	json11/json11.cpp	/^const Json &              JsonValue::operator[] (size_t)         const { return static_null(); }$/;"	f	class:json11::JsonValue
operator []	json11/json11.cpp	/^const Json & Json::operator[] (const string &key) const { return (*m_ptr)[key];         }$/;"	f	class:json11::Json
operator []	json11/json11.cpp	/^const Json & Json::operator[] (size_t i)          const { return (*m_ptr)[i];           }$/;"	f	class:json11::Json
operator []	json11/json11.cpp	/^const Json & JsonArray::operator[] (size_t i) const$/;"	f	class:json11::JsonArray
operator []	json11/json11.cpp	/^const Json & JsonObject::operator[] (const string &key) const$/;"	f	class:json11::JsonObject
operator []	libstar/xlist.h	/^	void		*operator [](int nth)		{ return Get(nth); }$/;"	f	class:CXList
operator []	libstar/xsnmp.h	/^	SnmpVarList	*operator [](uint idx)			{ return GetVar(idx); }$/;"	f	class:CXSnmp
operator []	myjson/json.h	/^	json_t *operator[](int nth)	{ return json_get(list, nth); }$/;"	f	class:json
operator []	myjson/json.h	/^	json_t *operator[](string name)	{ return json_find(list, name.c_str()); }$/;"	f	class:json
operstatus	libstar/snmpdef.h	/^	int	operstatus;		\/\/ 1=up 2=down$/;"	m	struct:__anon78
operstatus	libstar/xnms.h	/^	int		operstatus;$/;"	m	struct:__anon150
operstatusName	libstar/xsnmpif.c	/^char	*operstatusName(int status, char *buf)$/;"	f
opt	libstar/xpcap.h	/^	int		opt;			\/\/ 세부적인 패킷 처리를 위한 플래그 $/;"	m	struct:__anon153
opt	libstar/xsnmp.h	/^	char		opt[64];		\/\/ @start, @end (TRAP 시작\/종료)$/;"	m	struct:__anon163
opt	libstar/xtn.h	/^	char		*opt;		\/\/ Option ("erase_prompt")$/;"	m	struct:xtn
option	libstar/xapp.h	/^	char		option[256];$/;"	m	struct:__anon113
option	libstar/xdebug.h	/^	int		option;$/;"	m	struct:__anon126
option	libstar/xtn.c	/^	_option option;$/;"	m	struct:ol_st	file:
ora_close	libstar/ocilib.h	103;"	d
ora_exec	libstar/ocilib.c	/^int	ora_exec(ociconn_t *connp, char *sql)$/;"	f
ora_open	libstar/ocilib.c	/^ociconn_t	*ora_open(char *userid, char *passwd, char *svcid, int mode)$/;"	f
ora_select	libstar/ocilib.c	/^int	ora_select(ociconn_t *connp, char *sql)$/;"	f
oradb	libstar/xdb.h	/^	ociconn_t	*oradb;		\/\/ Oracle DB - All flatforms$/;"	m	struct:__anon118
oradb	libstar/xdb.h	/^	void		*oradb;		\/\/ __ORACLE이 미정의된 경우 구조체의 offset을 맞추기 위함 $/;"	m	struct:__anon118
otheropts	libstar/lock.h	/^	char		otheropts[100];		\/\/ 다른 옵션 기능 $/;"	m	struct:__anon44
otpl_field	libstar/nflowlib.h	/^struct otpl_field$/;"	s
outAddrMaskReplys	libstar/snmpdef.h	/^	uint	outAddrMaskReplys;$/;"	m	struct:__anon83
outAddrMasks	libstar/snmpdef.h	/^	uint	outAddrMasks;$/;"	m	struct:__anon83
outBandwidthPer	libstar/snmpdef.h	/^	float	outBandwidthPer;$/;"	m	struct:__anon78
outBroadcastPkts	libstar/snmpdef.h	/^	double		outBroadcastPkts;$/;"	m	struct:__anon77
outBytesPerSec	libstar/snmpdef.h	/^	float		outBytesPerSec;		\/\/ 초당 들어온 바이트 수 $/;"	m	struct:__anon77
outBytesPerSec	libstar/snmpdef.h	/^	float	outBytesPerSec;		\/\/ 초당 들어온 바이트 수 $/;"	m	struct:__anon78
outDatagrams	libstar/snmpdef.h	/^	uint		outDatagrams;	\/\/ 해당 엔티티로부터 수신된 UDP 데이터그램의 총 개수 $/;"	m	struct:__anon86
outDestUnreachs	libstar/snmpdef.h	/^	uint	outDestUnreachs;$/;"	m	struct:__anon83
outDiscards	libstar/snmpdef.h	/^	uint	outDiscards;$/;"	m	struct:__anon78
outDiscards	libstar/snmpdef.h	/^	uint	outDiscards;$/;"	m	struct:__anon81
outEchoReplys	libstar/snmpdef.h	/^	uint	outEchoReplys;$/;"	m	struct:__anon83
outEchos	libstar/snmpdef.h	/^	uint	outEchos;$/;"	m	struct:__anon83
outErrors	libstar/snmpdef.h	/^	uint	outErrors;$/;"	m	struct:__anon78
outErrors	libstar/snmpdef.h	/^	uint	outErrors;$/;"	m	struct:__anon83
outMsgs	libstar/snmpdef.h	/^	uint	outMsgs;$/;"	m	struct:__anon83
outMulticastPkts	libstar/snmpdef.h	/^	double		outMulticastPkts;$/;"	m	struct:__anon77
outNUcastPkts	libstar/snmpdef.h	/^	uint	outNUcastPkts;		\/\/ broadcast$/;"	m	struct:__anon78
outNoRoutes	libstar/snmpdef.h	/^	uint	outNoRoutes;$/;"	m	struct:__anon81
outOctets	libstar/snmpdef.h	/^	double		outOctets;$/;"	m	struct:__anon77
outOctets	libstar/snmpdef.h	/^	uint	outOctets;$/;"	m	struct:__anon78
outParamProbs	libstar/snmpdef.h	/^	uint	outParamProbs;$/;"	m	struct:__anon83
outPkts	libstar/snmpdef.h	/^	double		outPkts;$/;"	m	struct:__anon77
outQLen	libstar/snmpdef.h	/^	uint	outQLen;$/;"	m	struct:__anon78
outRedirects	libstar/snmpdef.h	/^	uint	outRedirects;$/;"	m	struct:__anon83
outRequests	libstar/snmpdef.h	/^	uint	outRequests;$/;"	m	struct:__anon81
outRsts	libstar/snmpdef.h	/^	uint	outRsts;		\/\/ RST 플래그를 포함하는 송신된 TCP 세그먼트의 객수 $/;"	m	struct:__anon84
outSegs	libstar/snmpdef.h	/^	uint	outSegs;		\/\/ 현재 연결된 것을 포함하여 송신된 세그먼트의 총 개수 $/;"	m	struct:__anon84
outSrcQuenchs	libstar/snmpdef.h	/^	uint	outSrcQuenchs;$/;"	m	struct:__anon83
outTimeExceeds	libstar/snmpdef.h	/^	uint	outTimeExceeds;$/;"	m	struct:__anon83
outTimestampReplys	libstar/snmpdef.h	/^	uint	outTimestampReplys;$/;"	m	struct:__anon83
outTimestamps	libstar/snmpdef.h	/^	uint	outTimestamps;$/;"	m	struct:__anon83
outUcastPkts	libstar/snmpdef.h	/^	double		outUcastPkts;$/;"	m	struct:__anon77
outUcastPkts	libstar/snmpdef.h	/^	uint	outUcastPkts;$/;"	m	struct:__anon78
outUnitDiscards	libstar/snmpdef.h	/^	int	outUnitDiscards;$/;"	m	struct:__anon78
outUnitErrors	libstar/snmpdef.h	/^	int	outUnitErrors;$/;"	m	struct:__anon78
outUnitKBytes	libstar/snmpdef.h	/^	float		outUnitKBytes;		\/\/ 단위 시간당 나간 바이트 수 $/;"	m	struct:__anon77
outUnitKBytes	libstar/snmpdef.h	/^	float	outUnitKBytes;		\/\/ 단위 시간당 나간 바이트 수 $/;"	m	struct:__anon78
outUnitMcastPkts	libstar/snmpdef.h	/^	float	outUnitMcastPkts;	\/\/ 단위 시간당 나간 Multicast Pkts$/;"	m	struct:__anon78
outUnitPkts	libstar/snmpdef.h	/^	float		outUnitPkts;		\/\/ 단위 시간당 나간 바이트 수 $/;"	m	struct:__anon77
outUnitPkts	libstar/snmpdef.h	/^	float	outUnitPkts;		\/\/ 단위 시간당 나간 바이트 수 $/;"	m	struct:__anon78
outUnitQLen	libstar/snmpdef.h	/^	int	outUnitQLen;$/;"	m	struct:__anon78
out_encap	libstar/xflowlib.h	/^	int		out_encap;$/;"	m	struct:__anon129
out_encaps	libstar/nflowlib.h	/^	uint8		out_encaps;	\/\/ size in bytes of the output encapsulation$/;"	m	struct:__anon57
out_priority	libstar/sflowlib.h	/^	uint            out_priority;$/;"	m	struct:_SFSample
out_stack	libstar/sflowlib.h	/^	SFLLabelStack   out_stack;$/;"	m	struct:_SFLExtended_mpls
out_vlan	libstar/sflowlib.h	/^	uint            out_vlan;$/;"	m	struct:_SFSample
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:__anon53
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:__anon55
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:__anon57
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:__anon59
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:struct_export_v8_1
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:struct_export_v8_4
outifidx	libstar/nflowlib.h	/^	uint16		outifidx;	\/\/ output interface index$/;"	m	struct:struct_export_v8_5
outifidx	libstar/sflowlib.h	/^	uint            outifidx;$/;"	m	struct:_SFSample
outifidx	libstar/xflowlib.h	/^	int		outifidx;$/;"	m	struct:__anon129
outifidx_format	libstar/sflowlib.h	/^	uint            outifidx_format;$/;"	m	struct:_SFSample
outmcastpps	libstar/snmpdef.h	/^	float	outmcastpps;		\/\/ Multicast out PPS$/;"	m	struct:__anon78
outoctets64	libstar/snmpdef.h	/^	uint64	outoctets64;		\/\/ 64비트 처리용 $/;"	m	struct:__anon78
outpkts64	libstar/snmpdef.h	/^	uint64	outpkts64;		\/\/ 64비트 처리용 $/;"	m	struct:__anon78
outpps	libstar/snmpdef.h	/^	float		outpps;			\/\/ 초당 송신된 packet 수 $/;"	m	struct:__anon77
outpps	libstar/snmpdef.h	/^	float	outpps;			\/\/ 초당 송신된 packet 수 $/;"	m	struct:__anon78
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface *\/$/;"	m	struct:struct_export_v8_12
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface *\/$/;"	m	struct:struct_export_v8_13
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface *\/$/;"	m	struct:struct_export_v8_14
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface index *\/$/;"	m	struct:struct_export_v8_10
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface index *\/$/;"	m	struct:struct_export_v8_6
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface index *\/$/;"	m	struct:struct_export_v8_7
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface index *\/$/;"	m	struct:struct_export_v8_8
output	libstar/nflowlib.h	/^	uint16       output;	\/* output interface index *\/$/;"	m	struct:struct_export_v8_9
output	libstar/sflowlib.h	/^	uint            output;	\/* SNMP ifIndex of output interface,$/;"	m	struct:_SFLFlow_sample
output	libstar/sflowlib.h	/^	uint            output;	\/* SNMP ifIndex of output interface,$/;"	m	struct:_SFLFlow_sample_expanded
outputFormat	libstar/sflowlib.h	/^	uint            outputFormat;	\/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
overflow	hdaclib.h	/^	bool	overflow;			\/\/ stop sending: when name or seconds exceeds$/;"	m	struct:__anon8
overflow	libstar/worm.h	/^	int		overflow;		\/\/ 용량 초과한 경우 1$/;"	m	struct:__anon109
override	json11/json11.cpp	/^    const Json & operator[](const string &key) const override;$/;"	m	class:json11::final	file:
override	json11/json11.cpp	/^    const Json & operator[](size_t i) const override;$/;"	m	class:json11::final	file:
overwrite	libstar/fhash.h	/^	int		overwrite;		\/\/ insert시 동일 엔트리가 있으면 덮어 씀 $/;"	m	struct:__anon35
overwrite	libstar/hash.h	/^	int		overwrite;	\/\/ 중복 엔트리 없는 경우 1$/;"	m	struct:__anon41
overwrite	libstar/shash.h	/^	int		overwrite;		\/\/ insert시 동일 엔트리가 있으면 덮어 씀 $/;"	m	struct:__anon71
overwrite	libstar/vhash.h	/^	int		overwrite;		\/\/ 중복 엔트리 없는 경우 1 (insert\/update시 빨리 처리됨)$/;"	m	struct:__anon105
packet_data_tag	libstar/sflowlib.h	/^	uint            packet_data_tag;$/;"	m	struct:_SFSample
packet_sessions	libstar/netbios.c	/^	ushort		packet_sessions;$/;"	m	struct:__anon49	file:
pad	libstar/nflowlib.h	/^	uint8		pad;$/;"	m	struct:struct_export_v8_2
pad	libstar/nflowlib.h	/^	uint8		pad;$/;"	m	struct:struct_export_v8_3
pad	libstar/nflowlib.h	/^	uint8		pad;$/;"	m	struct:struct_export_v8_4
pad	libstar/nflowlib.h	/^	uint8        pad;$/;"	m	struct:struct_export_v8_13
pad	libstar/nflowlib.h	/^	uint8        pad;$/;"	m	struct:struct_export_v8_9
pad1	libstar/nflowlib.h	/^	uint16		pad1;$/;"	m	struct:__anon53
pad1	libstar/nflowlib.h	/^	uint8		pad1;$/;"	m	struct:__anon55
pad2	libstar/nflowlib.h	/^	uint16		pad2;		\/\/ Unused (zero) bytes$/;"	m	struct:__anon55
pad2	libstar/nflowlib.h	/^	uint8		pad2;		\/\/ Unused (zero) bytes$/;"	m	struct:__anon53
pad3	libstar/nflowlib.h	/^	uint8		pad3;		\/\/ Unused (zero) bytes$/;"	m	struct:__anon53
pad4	libstar/nflowlib.h	/^	uint8		pad4;		\/\/ Unused (zero) bytes$/;"	m	struct:__anon53
parexec	libstar/xutil.c	/^int	parexec(char *command)$/;"	f
parse	json11/json11.cpp	/^Json Json::parse(const string &in, string &err, JsonParse strategy)$/;"	f	class:json11::Json
parse	json11/json11.hpp	/^    static Json parse(const char * in,$/;"	f	class:json11::final
parse	libstar/xpcap.h	/^	xpcap_parse_t	parse;			\/\/ interpret_ether()에 의해 파싱된 결과 $/;"	m	struct:__anon154
parse	myjson/json.h	/^	json_t *parse(const string jsonstr)$/;"	f	class:json
parse	myjson/json2.c	/^json& json::parse(const string jsonstr)$/;"	f	class:json
parse_find	myjson/json.h	/^	json_t *parse_find(const string jsonstr, const string name, int opt = 0)$/;"	f	class:json
parse_find_value	myjson/json.h	/^	string parse_find_value(const string jsonstr, const string name, int opt = 0)$/;"	f	class:json
parse_from_stdin	json11/test.cpp	/^static void parse_from_stdin() {$/;"	f	file:
parse_get_range_value	myjson/json.h	/^	string parse_get_range_value(const string jsonstr, int from, int nitem)$/;"	f	class:json
parse_get_value	myjson/json.h	/^	string parse_get_value(const string jsonstr, const int nth)$/;"	f	class:json
parse_get_value	myjson/json.h	/^	string parse_get_value(const string jsonstr, const string name)$/;"	f	class:json
parse_json	json11/json11.cpp	/^    Json parse_json(int depth)$/;"	f	struct:json11::__anon15::final
parse_multi	json11/json11.cpp	/^vector<Json> Json::parse_multi(const string &in,$/;"	f	class:json11::Json
parse_multi	json11/json11.hpp	/^    static inline std::vector<Json> parse_multi($/;"	f	class:json11::final
parse_number	json11/json11.cpp	/^    Json parse_number() {$/;"	f	struct:json11::__anon15::final
parse_print	myjson/json.h	/^	int parse_print(const string jsonstr, FILE *outfp = NULL, int nspc = 4)$/;"	f	class:json
parse_string	json11/json11.cpp	/^    string parse_string() {$/;"	f	struct:json11::__anon15::final
parse_test	myjson/test.c	/^void	parse_test(const char *path)$/;"	f
parse_test	myjson/test2.c	/^void	parse_test(const char *path)$/;"	f
parseoption	libstar/xdebug.c	/^int	parseoption(int ac, char *av[])$/;"	f
parser	libstar/loglib.h	/^	int		(*parser) (struct logparam *param, char *ipaddr, char *type, char *path, char *pos, char *rec);$/;"	m	struct:logparam
parser	myjson/json2.c	/^int	json::parser(const string jsonstr)$/;"	f	class:json
passiveOpens	libstar/snmpdef.h	/^	uint	passiveOpens;		\/\/ TCP 접속이 Listen 상태에서 SYN-RCVD 상태로의$/;"	m	struct:__anon84
passwd	libstar/smslib.c	/^	char	passwd[10];		\/\/ 사용자암호$/;"	m	struct:__anon74	file:
passwd	libstar/ssmtplib.h	/^	char		passwd[40];$/;"	m	struct:__anon103
passwd	libstar/worm.h	/^	char		passwd[64];$/;"	m	struct:__anon109
passwd	libstar/xapp.h	/^	char		passwd[40];	\/\/ FTP passwd$/;"	m	struct:__anon113
passwd	libstar/xdb.h	/^	char		passwd[32];$/;"	m	struct:__anon118
path	libstar/dvdlib.h	/^	char		path[192];$/;"	m	struct:__anon31
path	libstar/oddlib.h	/^	char		path[192];$/;"	m	struct:__anon64
path	libstar/xdebug.c	/^	char		path[128];$/;"	m	struct:__anon120	file:
path	libstar/xutil.h	/^	char		path[256];$/;"	m	struct:__anon180
path_get_dirname	libstar/xstr.c	/^char		*path_get_dirname(char *path, char *dirbuf)$/;"	f
path_get_filename	libstar/xstr.c	/^char		*path_get_filename(char *path, char *filebuf)$/;"	f
pathname	libstar/worm.h	/^	char		pathname[200];		\/\/ ro:$/;"	m	struct:__anon110
pattern	libstar/xsnmptype.c	/^	char		pattern[100];$/;"	m	struct:__anon165	file:
pause	contract.c	/^int	hdac_contract::pause()$/;"	f	class:hdac_contract
pause_task	rpc.h	/^	string pause_task(const char *tasks)$/;"	f	class:hdac
pdu	libstar/xsnmp.h	/^	SnmpPdu		*pdu;$/;"	m	struct:__anon158
pdutype	libstar/xsnmp.h	/^	int		pdutype;$/;"	m	struct:__anon158
peer_nexthop	libstar/nflowlib.h	/^	uint32		peer_nexthop;	\/\/ IP address of the nexthop w\/in the peer (FIB)$/;"	m	struct:__anon57
peer_nexthop	libstar/xflowlib.h	/^	ipv4addr	peer_nexthop;	\/\/ IP address of the nexthop w\/in the peer (FIB)$/;"	m	struct:__anon129
pem_install	libstar/xnms.h	/^	int		pem_install;		\/\/ .23	\/\/ Power Entry Module 장착되면 1 (외부 48V 전원 연결용 모듈)$/;"	m	struct:__anon147
pem_passwd_callback	libstar/xssl.c	/^int	pem_passwd_callback(char *buf, int size, int rwflag, void *password)$/;"	f
pending_sessions	libstar/netbios.c	/^	ushort		pending_sessions;$/;"	m	struct:__anon49	file:
perm	contract.c	/^int	hdac_contract::perm(const char *stream, const char *fromaddr)$/;"	f	class:hdac_contract
perm	libstar/worm.h	/^	char		perm[20];		\/\/ Unix chmod 옵션 (default: file=0644 folder=0755)$/;"	m	struct:__anon110
pgdb	libstar/xdb.h	/^	PGconn		*pgdb;		\/\/ Postgres SQL DB - All flatforms$/;"	m	struct:__anon118
pgdb	libstar/xdb.h	/^	void		*pgdb;		\/\/ __PGSQL이 미정의된 경우 구조체의 offset을 맞추기 위함 $/;"	m	struct:__anon118
pgres	libstar/xdb.h	/^	PGresult	*pgres;$/;"	m	struct:__anon119
phys2str	libstar/xstr.c	/^char  *phys2str(char *phys, int len, char *buf)$/;"	f
physaddr	libstar/snmpdef.h	/^	char	physaddr[20];		\/\/ MAC address $/;"	m	struct:__anon78
physaddr	libstar/snmpdef.h	/^	char	physaddr[20];	\/\/ Media dependent physical addr	{ ipNetToMediaEntry 2 } RW $/;"	m	struct:__anon79
physaddr	libstar/xsnmp.h	/^	char	physaddr[20];		\/\/ 해당 엔트리의 MAC$/;"	m	struct:__anon161
physaddr	libstar/xsnmp.h	/^	char	physaddr[20];$/;"	m	struct:__anon160
physicalindex	libstar/xnms.h	/^	int		physicalindex;		\/\/ .27$/;"	m	struct:__anon148
pid	libstar/sflowlib.h	/^	uint            pid;$/;"	m	struct:_SFLProcess
pid	libstar/snmpdef.h	/^	int		pid;$/;"	m	struct:__anon85
pid	libstar/snmpdef.h	/^	int	pid;$/;"	m	struct:__anon87
pid	libstar/snmpdef.h	/^	int	pid;$/;"	m	struct:__anon92
piecewise	libstar/ocilib.h	/^	int		piecewise;	\/* column is fetched piece-by-piece *\/$/;"	m	struct:__anon61
ping_check_only	libstar/xnms.h	/^	int		ping_check_only;	\/\/ 1이면 PING만으로 장애 체크함.$/;"	m	struct:xnmsnode
ping_fail_fast_recovery	libstar/xnms.h	/^	int		ping_fail_fast_recovery;	\/\/ Ping 실패시 자주 Ping 보내서 UP 빨리 감지 $/;"	m	struct:__anon149
ping_fail_retry	libstar/xnms.h	/^	int		ping_fail_retry;		\/\/ Ping 실패시 몇 번 재시도할지..$/;"	m	struct:__anon149
ping_fail_step_event	libstar/xnms.h	/^	int		ping_fail_step_event;		\/\/ Ping 실패시 Minor->Major->Critical->DOWN 순서대로 장애 발생시킬 것 $/;"	m	struct:__anon149
ping_max_fail	libstar/xnms.h	/^	int		ping_max_fail;		\/\/ PING 연속 실패 횟수 (이 카운트가 차면 다운됨)$/;"	m	struct:xnmsnode
ping_pps	libstar/xnms.h	/^	int		ping_pps;			\/\/ 초당 PING 개수..$/;"	m	struct:__anon149
ping_timeout_ms	libstar/xnms.h	/^	int		ping_timeout_ms;		\/\/ 기본 Ping timeout MS$/;"	m	struct:__anon149
ping_timeout_ms	libstar/xnms.h	/^	int		ping_timeout_ms;	\/\/ PING Timeout MS$/;"	m	struct:xnmsnode
pingcount	libstar/xnms.h	/^	int		pingcount;		\/\/ PING 회수$/;"	m	struct:xnmsnode
pingfail	libstar/xnms.h	/^	int		pingfail;		\/\/ 연속적으로 PING 실패한 회수. PING 성공하면 0으로 초기화 됨.$/;"	m	struct:xnmsnode
pingfailtime	libstar/xnms.h	/^	time32		pingfailtime;		\/\/ 최초로 PING 실패한 시각 (이 시각부터 실제 다운 시각임)$/;"	m	struct:xnmsnode
pingok	libstar/xnms.h	/^	int		pingok;			\/\/ 연속적으로 PING 설공한 회수 $/;"	m	struct:xnmsnode
pingresponseMS	libstar/xnms.h	/^	float		pingresponseMS;		\/\/ PING 응답시간$/;"	m	struct:xnmsnode
pingstat	libstar/xnms.h	/^	int		pingstat;			\/\/ 최초 0, thread 시작시 1, 종료시 -1$/;"	m	struct:__anon149
pingstatus	libstar/xnms.h	/^	int		pingstatus;		\/\/ EV_PING_xx$/;"	m	struct:xnmsnode
pingstop	libstar/xnms.h	/^	int		pingstop;		\/\/ PING이 연속적으로 몇 번 실패하면 해당 노드에 대한 PING을 스톱시킬지 설정$/;"	m	struct:xnmsnode
pingterm	libstar/xnms.h	/^	int		pingterm;		\/\/ SNMP 정보 입수 실패시 PING 테스트 주기 (0 == 300초. -1==PING 사용 않음)$/;"	m	struct:xnmsnode
pingthread	libstar/xping.c	/^static	VTHREAD	pingthread(void *arg)$/;"	f	file:
pkoffset	libstar/xpcap.h	/^	int		pkoffset;$/;"	m	struct:__anon154
pkthdr	libstar/xpcap.h	/^	struct pcap_pkthdr *pkthdr;		\/\/ pcap_loop()에서 넘어온 패킷 헤더 $/;"	m	struct:__anon153	typeref:struct:__anon153::pcap_pkthdr
pkthead_t	libstar/xpcap.h	/^}	pkthead_t;$/;"	t	typeref:struct:__anon152
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ number of packets$/;"	m	struct:struct_export_v8_1
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ number of packets$/;"	m	struct:struct_export_v8_2
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ number of packets$/;"	m	struct:struct_export_v8_3
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ number of packets$/;"	m	struct:struct_export_v8_4
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ number of packets$/;"	m	struct:struct_export_v8_5
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ packets sent in duration$/;"	m	struct:__anon53
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ packets sent in duration$/;"	m	struct:__anon55
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ packets sent in duration$/;"	m	struct:__anon57
pkts	libstar/nflowlib.h	/^	uint32		pkts;		\/\/ packets sent in duration$/;"	m	struct:__anon59
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_10
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_11
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_12
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_13
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_14
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_6
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_7
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_8
pkts	libstar/nflowlib.h	/^	uint32       pkts;	\/* Packets sent in duration *\/$/;"	m	struct:struct_export_v8_9
pkts	libstar/xflowlib.h	/^	int		pkts;		\/\/ Collector로 유입되는 flow에 대한 통계 데이터 보관용 $/;"	m	struct:__anon130
pkts	libstar/xflowlib.h	/^	uint32		pkts;$/;"	m	struct:__anon129
pkts_recv	libstar/snmpdef.h	/^	float		pkts_recv;		\/\/ $/;"	m	struct:__anon96
pkts_recv_sum	libstar/snmpdef.h	/^	uint64		pkts_recv_sum;		\/\/ Counter64(70 - cntr64)$/;"	m	struct:__anon96
pkts_sent	libstar/snmpdef.h	/^	float		pkts_sent;		\/\/ $/;"	m	struct:__anon96
pkts_sent_sum	libstar/snmpdef.h	/^	uint64		pkts_sent_sum;		\/\/ Counter64(70 - cntr64)$/;"	m	struct:__anon96
policy	libstar/lock.h	/^	char		policy[92];$/;"	m	struct:__anon44
pop3_close	libstar/pop3.c	/^void	pop3_close(int sock)$/;"	f
pop3_del	libstar/pop3.c	/^int	pop3_del(int sock, int delid)$/;"	f
pop3_get	libstar/pop3.c	/^_ALLOC	char	*pop3_get(int sock, int msgid)$/;"	f
pop3_list	libstar/pop3.c	/^int	pop3_list(int sock, char *buf, int buflen)$/;"	f
pop3_login	libstar/pop3.c	/^int	pop3_login(int sock, char *userid, char *passwd)$/;"	f
pop3_open	libstar/pop3.c	/^int	pop3_open(uint addr, int port)$/;"	f
pop3_recv	libstar/pop3.c	/^int	pop3_recv(int sock, char *buf, int buflen, int maxline)$/;"	f
pop3_send	libstar/pop3.c	/^int	pop3_send(int sock, char *buf)$/;"	f
pop3_settimeout	libstar/pop3.c	/^void	pop3_settimeout(int timeout)$/;"	f
port	hdaclib.h	/^	int	port;		\/\/ RPC Port$/;"	m	struct:__anon9
port	libstar/snmpdef.h	/^	int	port;$/;"	m	struct:__anon92
port	libstar/ssmtplib.h	/^	int		port;$/;"	m	struct:__anon103
port	libstar/xdb.h	/^	int		port;$/;"	m	struct:__anon118
port	libstar/xflowlib.h	/^	int		port;		\/\/ Router export port$/;"	m	struct:xflow
port	libstar/xnms.h	/^	int		port;			\/\/ telnet port (default=23)$/;"	m	struct:__anon145
port	libstar/xtn.h	/^	int		port;$/;"	m	struct:xtn
portchecklist	libstar/xnms.h	/^	uint		portchecklist[MAX_NODE_IF];	\/\/ 포트 감시 리스트 (ifindex)$/;"	m	struct:xnmsnode
portcount_t	libstar/snmpdef.h	/^}	portcount_t;$/;"	t	typeref:struct:__anon92
porthash	libstar/gw.h	/^	hash_t	*porthash;		\/\/ Port routing을 위한 hash. 기본적으로 동일한 포트에 대해서는 routing 허용 $/;"	m	struct:gwinfo
portstatus	libstar/xnms.h	/^	char		portstatus[80];		\/\/ .15	\/\/ 첫 바이트는 전체 모듈 상태. 두번째부터는 각 포트 상태 (OperStatus)$/;"	m	struct:__anon148
pos	json2.h	/^	int	pos;		\/\/ position in a source string$/;"	m	class:tokeninfo
pos	libstar/loglib.h	/^	ulong		pos;		\/\/ 파일 읽을 위치..$/;"	m	struct:__anon45
pos	myjson/json2.h	/^	int	pos;		\/\/ position in a source string$/;"	m	class:tokeninfo
power1status	libstar/xnms.h	/^	char		power1status[20];	\/\/ .4 $/;"	m	struct:__anon147
power1testok	libstar/xnms.h	/^	char		power1testok[10];	\/\/ .5	\/\/ 0=정상 $/;"	m	struct:__anon147
power1type	libstar/xnms.h	/^	char		power1type[40];		\/\/ .3$/;"	m	struct:__anon147
power2status	libstar/xnms.h	/^	char		power2status[20];	\/\/ .7 $/;"	m	struct:__anon147
power2testok	libstar/xnms.h	/^	char		power2testok[10];	\/\/ .8	\/\/ 0=정상 $/;"	m	struct:__anon147
power2type	libstar/xnms.h	/^	char		power2type[40];		\/\/ .6$/;"	m	struct:__anon147
power3status	libstar/xnms.h	/^	char		power3status[20];	\/\/ .21 $/;"	m	struct:__anon147
power3testok	libstar/xnms.h	/^	char		power3testok[10];	\/\/ .22	\/\/ 0=정상 $/;"	m	struct:__anon147
power3type	libstar/xnms.h	/^	char		power3type[40];		\/\/ .20$/;"	m	struct:__anon147
pps	libstar/xflowlib.h	/^	int		pps;		\/\/ 초당 처리한 packet 수$/;"	m	struct:__anon130
pps	libstar/xicmp.h	/^	int		pps;$/;"	m	struct:__anon136
pps	libstar/xping.h	/^	int		pps;			\/\/ Send Ping Per Sec$/;"	m	struct:xping
precision	libstar/ocilib.h	/^	ub2		precision;	\/* column precision *\/$/;"	m	struct:__anon61
preparelockunspent	rpc.h	/^	string preparelockunspent(const char *asset_qty, const bool lock = true)$/;"	f	class:hdac
preparelockunspentfrom	rpc.h	/^	string preparelockunspentfrom(const char *fromaddr, const char *asset_qty, const bool lock = true)$/;"	f	class:hdac
prev	libstar/hash.h	/^	struct hashentry *prev, *next;$/;"	m	struct:hashentry	typeref:struct:hashentry::hashentry
prev	libstar/xlist.h	/^	struct xlistnode *prev;		\/\/ 이전 리스트 포인트$/;"	m	struct:xlistnode	typeref:struct:xlistnode::xlistnode
prevcount	libstar/xdebug.c	/^	int	prevcount;		\/\/ 이전 할당 카운트 $/;"	m	struct:__anon121	file:
prevfsize	libstar/xdebug.c	/^	float	prevfsize;		\/\/ 이전 사이즈와 변경 체크시 $/;"	m	struct:__anon121	file:
prevsize	libstar/dvdlib.h	/^	uint		prevsize;		\/\/ 이전 파일 크기 (화면 출력시 비교용)$/;"	m	struct:__anon32
prevtime	libstar/gw.h	/^	uint	prevtime;		\/\/ 이전 retry 시각 $/;"	m	struct:gwrule
print	libstar/xdebug.c	/^	int	print;			\/\/ 프린트 횟수 $/;"	m	struct:__anon121	file:
print	myjson/json.h	/^	int print(FILE *outfp = NULL, const int nspc = 4, int opt = 0)$/;"	f	class:json
print	myjson/json2.c	/^string json::print(const int tab, FILE *outfp)$/;"	f	class:json
printBlock	libstar/aria.c	/^static	void printBlock(uint8 *b)$/;"	f	file:
printBlockOfLength	libstar/aria.c	/^static	void printBlockOfLength(uint8 *b, int len)$/;"	f	file:
printerr	myjson/json2.c	/^void	json::printerr(int pos, string msg)$/;"	f	class:json
priority	libstar/sflowlib.h	/^	uint            priority;	\/* IP priority *\/$/;"	m	struct:_SFLSampled_ipv6
privoid_t	libstar/xsnmp.h	/^}	privoid_t;$/;"	t	typeref:struct:__anon163
proc	libstar/xtn.c	/^	LPCODEPROC proc;$/;"	m	struct:codec_st	file:
process	libstar/sflowlib.h	/^	SFLExtended_process process;$/;"	m	union:_SFLFlow_type
process_SFv2v4_packet	libstar/sflowlib.c	/^static	int	process_SFv2v4_packet(xflow_t *xfp, uint routeraddr, SFSample * spp)$/;"	f	file:
process_SFv5_packet	libstar/sflowlib.c	/^static	int	process_SFv5_packet(xflow_t *xfp, uint routeraddr, SFSample * spp)$/;"	f	file:
processes	libstar/sflowlib.h	/^	SFLProcess      processes[SFL_MAX_PROCESSES];$/;"	m	struct:_SFLExtended_process
processor	libstar/sflowlib.h	/^	SFLProcessor_counters processor;$/;"	m	union:_SFLCounters_type
progfile	contract.h	/^	char	progfile[256];			\/\/ Contract program filename$/;"	m	struct:__anon1
promisc	libstar/xpcap.h	/^	int		promisc;		\/\/ 1이면 promisc mode로 세팅.$/;"	m	struct:__anon154
prompt	libstar/xnms.h	/^	char		prompt[20][40];$/;"	m	struct:__anon145
prot	libstar/nflowlib.h	/^	uint8		prot;		\/\/ IP protocol, e.g., 6=TCP, 17=UDP, ...$/;"	m	struct:__anon53
prot	libstar/nflowlib.h	/^	uint8		prot;		\/\/ IP protocol, e.g., 6=TCP, 17=UDP, ...$/;"	m	struct:__anon55
prot	libstar/nflowlib.h	/^	uint8		prot;		\/\/ IP protocol, e.g., 6=TCP, 17=UDP, ...$/;"	m	struct:__anon57
prot	libstar/nflowlib.h	/^	uint8		prot;		\/\/ IP protocol, e.g., 6=TCP, 17=UDP, ...$/;"	m	struct:__anon59
prot	libstar/nflowlib.h	/^	uint8		prot;	\/\/ IP protocol (TCP=6, UDP=17, etc.)$/;"	m	struct:struct_export_v8_2
prot	libstar/nflowlib.h	/^	uint8        prot;	\/* IP protocol *\/$/;"	m	struct:struct_export_v8_10
prot	libstar/nflowlib.h	/^	uint8        prot;	\/* protocol *\/$/;"	m	struct:struct_export_v8_14
prot	libstar/nflowlib.h	/^	uint8        prot;	\/* protocol *\/$/;"	m	struct:struct_export_v8_8
prot	libstar/xflowlib.h	/^	int		prot;$/;"	m	struct:__anon129
proto	libstar/snmpdef.h	/^	int	proto;			\/\/ mechanism by which route was learned	{ipRouteEntry 9 } $/;"	m	struct:__anon82
proto	libstar/xpcap.h	/^	int		proto;			\/\/ ethernet protocol type: ETHERTYPE_ARP, _IP, _ICMP$/;"	m	struct:__anon153
protocol	libstar/sflowlib.h	/^	uint            protocol;	\/* IP Protocol type (for example, TCP = 6, UDP = 17) *\/$/;"	m	struct:_SFLSampled_ipv6
protocol	libstar/sflowlib.h	/^	uint            protocol;	\/\/ IP Protocol type (for example, TCP = 6, UDP = 17) $/;"	m	struct:_SFLSampled_ipv4
protocol	libstar/sflowlib.h	/^    uint8_t protocol;$/;"	m	struct:iphdr
ps_killps	libstar/xutil.c	/^VTHREAD	ps_killps(void *arg)$/;"	f
psflows	libstar/xflowlib.h	/^	uint		psflows;$/;"	m	struct:__anon130
psper	libstar/xflowlib.h	/^	float		psper;		\/\/ 전체 입력에 대해 초당 처리된 비율$/;"	m	struct:__anon130
pthread_create	libstar/proflib.c	/^int pthread_create(pthread_t * __restrict thread, __const pthread_attr_t * __restrict attr, void *(*start_routine) (void *), void *__restrict arg)$/;"	f
pthread_create_orig	libstar/proflib.c	/^static int      (*pthread_create_orig) (pthread_t * __restrict, __const pthread_attr_t * __restrict, void *(*)(void *), void *__restrict) = NULL;$/;"	v	file:
ptr	libstar/xdebug.c	/^	char	*ptr;			\/\/ 최종 할당 포인터 $/;"	m	struct:__anon121	file:
pubkey	hdaclib.h	/^	char	pubkey[HDAC_MAX_MULTISIG][HDAC_PUBKEY_LEN];	\/\/ IN$/;"	m	struct:__anon10
publish	rpc.h	/^	string publish(const char *stream_id, const char *item_key, const char *data, int datalen = 0)$/;"	f	class:hdac
publishfrom	rpc.h	/^	string publishfrom(const char *fromaddr, const char *stream_id, const char *item_key, const char *data, int datalen = 0)$/;"	f	class:hdac
q1printf	libstar/xdebug.h	142;"	d
q2printf	libstar/xdebug.h	141;"	d
q3printf	libstar/xdebug.h	140;"	d
q4printf	libstar/xdebug.h	139;"	d
q5printf	libstar/xdebug.h	138;"	d
qbuf	libstar/xpcap.h	/^	char		*qbuf;			\/\/ 패킷 버퍼 (최소 1MB)$/;"	m	struct:__anon154
qbufsize	libstar/xpcap.h	/^	uint		qbufsize;		\/\/ 버퍼 크기 $/;"	m	struct:__anon154
qhead	libstar/xqueue.h	/^	int	qhead;$/;"	m	struct:__anon156
qlen	libstar/xflowlib.h	/^	int		qlen;		\/\/ Queue length$/;"	m	struct:__anon130
qlen	libstar/xqueue.h	/^	int	qlen;$/;"	m	struct:__anon156
qprintf	libstar/xdebug.h	143;"	d
qtail	libstar/xqueue.h	/^	int	qtail;$/;"	m	struct:__anon156
question_class	libstar/netbios.c	/^	ushort		question_class;$/;"	m	struct:__anon47	file:
question_class	libstar/netbios.c	/^	ushort		question_class;$/;"	m	struct:__anon48	file:
question_count	libstar/netbios.c	/^	ushort		question_count;$/;"	m	struct:__anon47	file:
question_count	libstar/netbios.c	/^	ushort		question_count;$/;"	m	struct:__anon48	file:
question_name	libstar/netbios.c	/^	char		question_name[34];$/;"	m	struct:__anon47	file:
question_name	libstar/netbios.c	/^	char		question_name[34];$/;"	m	struct:__anon48	file:
question_type	libstar/netbios.c	/^	ushort		question_type;$/;"	m	struct:__anon47	file:
question_type	libstar/netbios.c	/^	ushort		question_type;$/;"	m	struct:__anon48	file:
queue	libstar/xflowlib.h	/^	xlist_t		*queue;		\/\/ Raw data 저장할 queue$/;"	m	struct:xflow
queue	libstar/xqueue.h	/^	char	**queue;$/;"	m	struct:__anon156
quota_mb	libstar/worm.h	/^	char		quota_mb[10];$/;"	m	struct:__anon109
rawSample	libstar/sflowlib.h	/^	uchar          *rawSample;$/;"	m	struct:_SFSample
rawSampleLen	libstar/sflowlib.h	/^	uint            rawSampleLen;$/;"	m	struct:_SFSample
rawcallback	libstar/xflowlib.h	/^	void (*rawcallback) (struct xflow *xfp, uint routeraddr, int export_ver, int entry_count, void *rawdata, uint size);$/;"	m	struct:xflow
rdata_length	libstar/netbios.c	/^	ushort		rdata_length;$/;"	m	struct:__anon48	file:
re	libstar/re.h	/^	regex_t		re;$/;"	m	struct:__anon66
re	libstar/xsnmptype.c	/^	re_t		*re;$/;"	m	struct:__anon165	file:
re_find	libstar/re.c	/^char	*re_find(re_t *re, char *string)$/;"	f
re_free	libstar/re.h	31;"	d
re_init	libstar/re.c	/^re_t	*re_init(const char *pattern, int case_sensitive)$/;"	f
re_next	libstar/re.c	/^char	*re_next(re_t *re)$/;"	f
re_perror	libstar/re.c	/^void	re_perror(re_t *re)$/;"	f
re_replace	libstar/re.c	/^int	re_replace(re_t *re, char *data, char *replacestr, char *outbuf, int outbuflen)$/;"	f
re_t	libstar/re.h	/^}	re_t;$/;"	t	typeref:struct:__anon66
re_wildcard2re	libstar/re.c	/^char	*re_wildcard2re(char *regex, char *buf, int buflen, int add_caret)$/;"	f
read	contract.c	/^int	hdac_contract::read()$/;"	f	class:hdac_contract
readExtendedClass	libstar/sflowlib.c	/^static	void	readExtendedClass(SFSample * sample)$/;"	f	file:
readExtendedGateway	libstar/sflowlib.c	/^static	void	readExtendedGateway(SFSample * sample)$/;"	f	file:
readExtendedGateway_v2	libstar/sflowlib.c	/^static	void	readExtendedGateway_v2(SFSample * sample)$/;"	f	file:
readExtendedMpls	libstar/sflowlib.c	/^static	void	readExtendedMpls(SFSample * sample)$/;"	f	file:
readExtendedMplsFTN	libstar/sflowlib.c	/^static	void	readExtendedMplsFTN(SFSample * sample)$/;"	f	file:
readExtendedMplsLDP_FEC	libstar/sflowlib.c	/^static	void	readExtendedMplsLDP_FEC(SFSample * sample)$/;"	f	file:
readExtendedMplsTunnel	libstar/sflowlib.c	/^static	void	readExtendedMplsTunnel(SFSample * sample)$/;"	f	file:
readExtendedMplsVC	libstar/sflowlib.c	/^static	void	readExtendedMplsVC(SFSample * sample)$/;"	f	file:
readExtendedNat	libstar/sflowlib.c	/^static	void	readExtendedNat(SFSample * sample)$/;"	f	file:
readExtendedProcess	libstar/sflowlib.c	/^static	void	readExtendedProcess(SFSample * sample)$/;"	f	file:
readExtendedRouter	libstar/sflowlib.c	/^static	void	readExtendedRouter(SFSample * sample)$/;"	f	file:
readExtendedSwitch	libstar/sflowlib.c	/^static	void	readExtendedSwitch(SFSample * sample)$/;"	f	file:
readExtendedUrl	libstar/sflowlib.c	/^static	void	readExtendedUrl(SFSample * sample)$/;"	f	file:
readExtendedUser	libstar/sflowlib.c	/^static	void	readExtendedUser(SFSample * sample)$/;"	f	file:
readExtendedVlanTunnel	libstar/sflowlib.c	/^static	void	readExtendedVlanTunnel(SFSample * sample)$/;"	f	file:
readFlowSample_IPv4	libstar/sflowlib.c	/^static	void	readFlowSample_IPv4(SFSample * sample)$/;"	f	file:
readFlowSample_IPv6	libstar/sflowlib.c	/^static	void	readFlowSample_IPv6(SFSample * sample)$/;"	f	file:
readFlowSample_ethernet	libstar/sflowlib.c	/^static	void	readFlowSample_ethernet(SFSample * sample)$/;"	f	file:
readFlowSample_header	libstar/sflowlib.c	/^static	void	readFlowSample_header(SFSample * sample)$/;"	f	file:
read_count	libstar/dvdlib.h	/^	uint		read_count;$/;"	m	struct:__anon33
read_enter	myjson/test.c	/^void	read_enter(int level)$/;"	f
read_enter	myjson/test2.c	/^void	read_enter(int level)$/;"	f
read_enter	test.c	/^void	read_enter(int level)$/;"	f
readcmd	libstar/xutil.c	/^int	readcmd(char *buf, uint bufsz, char *cmd)$/;"	f
readconf	libstar/xstr.c	/^char	*readconf(char *filename, char *name, char *retbuf)$/;"	f
readfile	libstar/xutil.c	/^int	readfile(const char *fname, void *buf, int buflen)$/;"	f
readline	libstar/xstr.c	/^int	readline(int fd, char *buf, int buflen)$/;"	f
readopt	libstar/loglib.h	/^	char		readopt[40];	\/\/ all=전체 end=파일의 끝 ###=해당 위치부터 $/;"	m	struct:__anon45
readv2v4CountersSample	libstar/sflowlib.c	/^static	void	readv2v4CountersSample(SFSample * sample)$/;"	f	file:
readv2v4FlowSample	libstar/sflowlib.c	/^static	void	readv2v4FlowSample(SFSample * sample)$/;"	f	file:
readv5CountersSample	libstar/sflowlib.c	/^static	void	readv5CountersSample(SFSample * sample)$/;"	f	file:
readv5FlowSample	libstar/sflowlib.c	/^static	void	readv5FlowSample(SFSample * sample, int expanded)$/;"	f	file:
ready	libstar/thrpool.h	/^	int		ready;$/;"	m	struct:thrdata
ready	libstar/xpcap.h	/^	uint		ready;			\/\/ 1이면 사용 가능한 패킷 $/;"	m	struct:__anon152
real_array_free	libstar/array.c	/^void	real_array_free(register array_t *ap)$/;"	f
real_create_thread	libstar/xutil.c	/^int	real_create_thread(pthread_t *tid, pthread_attr_t *attr, VTHREAD (*func)(void *), void * arg, const char *file, const int line, const char *func_name)$/;"	f
real_dprintf	libstar/xdebug.c	/^void	real_dprintf(const char *opt, const char *fmt, ...)$/;"	f
real_exit_thread	libstar/xutil.c	/^void	real_exit_thread(const char *file, const int line, VTHREAD (*func)(void *), const char *func_name)$/;"	f
real_fhash_close	libstar/fhash.c	/^void	real_fhash_close(fhash_t *ht)$/;"	f
real_fhash_free	libstar/fhash.c	/^void	real_fhash_free(fhash_t *ht)$/;"	f
real_fhash_init	libstar/fhash.c	/^fhash_t		*real_fhash_init(char *filename, int lineno, char *hashfile, int tablesize, int instsize, int keylen)$/;"	f
real_fhash_insert	libstar/fhash.c	/^fhashent_t	*real_fhash_insert(char *filename, int lineno, char *hashname, register fhash_t *ht, void *key, void *inst)$/;"	f
real_fhash_update	libstar/fhash.c	/^fhashent_t	*real_fhash_update(char *filename, int lineno, char *hashname, register fhash_t *ht, void *key, void *inst)$/;"	f
real_ftp_free	libstar/ftp.c	/^void	real_ftp_free(char *filename, int lineno, xftp_t *ftp)$/;"	f
real_hash_free	libstar/hash.c	/^void	real_hash_free(const char *filename, const int lineno, hash_t *ht)$/;"	f
real_hash_init	libstar/hash.c	/^hash_t	*real_hash_init(const char *filename, const int lineno, uint (*myhashf)(const void *, size_t),$/;"	f
real_hash_insert	libstar/hash.c	/^hashent_t	*real_hash_insert(const char *filename, const int lineno, const char *hashname, register hash_t *ht, void *key, int keylen)$/;"	f
real_hash_update	libstar/hash.c	/^hashent_t	*real_hash_update(const char *filename, const int lineno, const char *hashname, register hash_t *ht, void *key, int keylen)$/;"	f
real_ipc_client_init	libstar/xsock.c	/^int	real_ipc_client_init(const char *filename, const int lineno, char *path)$/;"	f
real_ipc_server_init	libstar/xsock.c	/^int	real_ipc_server_init(const char *filename, const int lineno, char *path)$/;"	f
real_logprintf	libstar/xdebug.c	/^int	real_logprintf(char *logfile, int level, ...)$/;"	f
real_loopcheck	libstar/xdebug.c	/^int	real_loopcheck(char *file, int line, int limit)$/;"	f
real_ora_close	libstar/ocilib.c	/^int	real_ora_close(ociconn_t *connp)$/;"	f
real_re_free	libstar/re.c	/^void	real_re_free(re_t *re)$/;"	f
real_shash_free	libstar/shash.c	/^void	real_shash_free(shash_t *ht)$/;"	f
real_shash_init	libstar/shash.c	/^shash_t		*real_shash_init(const char *filename, const int lineno, int tablesize, int instsize, int keylen)$/;"	f
real_shash_insert	libstar/shash.c	/^shashent_t	*real_shash_insert(const char *hashname, register shash_t *ht, void *key, void *inst)$/;"	f
real_shash_update	libstar/shash.c	/^shashent_t	*real_shash_update(const char *hashname, register shash_t *ht, void *key, void *inst)$/;"	f
real_sock_accept	libstar/xsock.c	/^xsock_t	*real_sock_accept(char *filename, int lineno, int port, int *sockfd, xsock_t *sock)$/;"	f
real_sock_client_init	libstar/xsock.c	/^int	real_sock_client_init(const char *filename, const int lineno, uint addr, int port)$/;"	f
real_sock_client_init_timeout	libstar/xsock.c	/^int	real_sock_client_init_timeout(char *filename, int lineno, uint addr, int port, int timeoutMS)$/;"	f
real_sock_close	libstar/xsock.c	/^void	real_sock_close(const char *filename, const int lineno, int sock)$/;"	f
real_sock_open	libstar/xsock.c	/^int	real_sock_open(const char *filename, const int cvneno, int domain, int type, int proto)$/;"	f
real_sock_server_init	libstar/xsock.c	/^int	real_sock_server_init(const char *filename, const int lineno, int port)$/;"	f
real_sslsock_client_close	libstar/xssl.c	/^void	real_sslsock_client_close(xsslsock_t *sslsock)$/;"	f
real_sslsock_server_close	libstar/xssl.c	/^void	real_sslsock_server_close(xsslsock_t *sslsock)$/;"	f
real_tprintf	libstar/xdebug.c	/^void	real_tprintf(double diff, char *filename, int lineno, char *fmt, ...)$/;"	f
real_vhash_find	libstar/vhash.c	/^vhashent_t	*real_vhash_find(const char *filename, const int lineno, vhash_t *ht, const void *key, const int keylen)$/;"	f
real_vhash_free	libstar/vhash.c	/^void	real_vhash_free(char *filename, int lineno, vhash_t *ht)$/;"	f
real_vhash_init	libstar/vhash.c	/^vhash_t	*real_vhash_init(const char *filename, const int lineno, int tablesize, int instsize, int maxkeylen)$/;"	f
real_worm_close	libstar/worm.c	/^int	real_worm_close(wormfile_t *wormfile)$/;"	f
real_worm_logout	libstar/worm.c	/^int	real_worm_logout(worm_t *worm)$/;"	f
real_xalarm	libstar/xtime.c	/^void	real_xalarm(const char *file, const int lineno, pthread_t tid, float clk)$/;"	f
real_xclose	libstar/xdebug.c	/^void	real_xclose(const char *filename, const int lineno, int fd)$/;"	f
real_xdb_first	libstar/xdb.c	/^xdbloop_t	*real_xdb_first(char *filename, int lineno, xdbloop_t *xdbloop)$/;"	f
real_xdb_next	libstar/xdb.c	/^xdbloop_t	*real_xdb_next(char *filename, int lineno, xdbloop_t *xdbloop)$/;"	f
real_xdb_select	libstar/xdb.c	/^vhash_t	*real_xdb_select(char *filename, int lineno, xdb_t *xdb, char *sqlbuf, int *numrow, int *numcol)$/;"	f
real_xdir_close	libstar/xutil.c	/^void	real_xdir_close(xdir_t *xdp)$/;"	f
real_xfclose	libstar/xdebug.c	/^void	real_xfclose(const char *filename, const int lineno, FILE *fp)$/;"	f
real_xfopen	libstar/xdebug.c	/^FILE	*real_xfopen(const char *filename, const int lineno, char *path, const char *mode)$/;"	f
real_xfree	libstar/xdebug.c	/^void	real_xfree(const char *file, const int lineno, void *buf)$/;"	f
real_xfreev	libstar/xdebug.c	/^void	real_xfreev(const char *file, const int lineno, void **sv)$/;"	f
real_xindex_free	libstar/xindex.c	/^void	real_xindex_free(register xindex_t *ap)$/;"	f
real_xlist_addtail	libstar/xlist.c	/^xlistnode_t	*real_xlist_addtail(const char *file, const int lineno, xlist_t *xl)$/;"	f
real_xlist_free	libstar/xlist.c	/^void	real_xlist_free(xlist_t *xl)$/;"	f
real_xlist_init	libstar/xlist.c	/^xlist_t	*real_xlist_init(const char *file, const int line, int instsize)$/;"	f
real_xmalloc	libstar/xdebug.c	/^void	*real_xmalloc(const char *file, const int lineno, uint size)$/;"	f
real_xmonitor	libstar/xdebug.c	/^void	real_xmonitor(const char *filename, const int lineno, char *msg, int isopen, int limit)$/;"	f
real_xopen	libstar/xdebug.c	/^int	real_xopen(const char *filename, const int lineno, const char *path, int flags, const int mode)$/;"	f
real_xping_free	libstar/xping.c	/^void	real_xping_free(xping_t *xp)$/;"	f
real_xprintf	libstar/xdebug.c	/^void	real_xprintf(const char *fmt, ...)$/;"	f
real_xprof_start	libstar/xtime.c	/^void	real_xprof_start(char *filename, int lineno, char *name, int idx)$/;"	f
real_xqueue_free	libstar/xqueue.c	/^void	real_xqueue_free(xqueue_t *xq)$/;"	f
real_xrealloc	libstar/xdebug.c	/^void	*real_xrealloc(char *file, int lineno, void *ptr, uint size)$/;"	f
real_xsnmp_close	libstar/xsnmp.c	/^void	real_xsnmp_close(char *file, int line, xsnmp_t *xs)$/;"	f
real_xsnmp_free	libstar/xsnmp.c	/^void	real_xsnmp_free(char *file, int line, xsnmp_t *xs)$/;"	f
real_xsnmp_init	libstar/xsnmp.c	/^xsnmp_t	*real_xsnmp_init(char *filename, int lineno)$/;"	f
real_xsnmp_open	libstar/xsnmp.c	/^int	real_xsnmp_open(char *file, int line, xsnmp_t *xs, char *orghostname, char *orgcommunity)$/;"	f
real_xsnmp_open_node	libstar/xnms.c	/^int	real_xsnmp_open_node(char *filename, int lineno, xsnmp_t *xs, xnmsnode_t *xn)$/;"	f
real_xsock_close	libstar/xsock.c	/^void	real_xsock_close(char *filename, int lineno, xsock_t *sock)$/;"	f
real_xtn_close	libstar/xtn.c	/^void	real_xtn_close(xtn_t *tnp)$/;"	f
realport	libstar/snmpdef.h	/^	int		realport;$/;"	m	struct:__anon77
realport	libstar/snmpdef.h	/^	int	realport;		\/\/ 실제 connector가 존재하면 1$/;"	m	struct:__anon78
reasmFails	libstar/snmpdef.h	/^	uint	reasmFails;$/;"	m	struct:__anon81
reasmOKs	libstar/snmpdef.h	/^	uint	reasmOKs;$/;"	m	struct:__anon81
reasmReqds	libstar/snmpdef.h	/^	uint	reasmReqds;$/;"	m	struct:__anon81
reasmTimeout	libstar/snmpdef.h	/^	int	reasmTimeout;$/;"	m	struct:__anon81
reasmmaxsize	libstar/snmpdef.h	/^	int	reasmmaxsize;$/;"	m	struct:__anon78
reasmmaxsize	libstar/snmpdef.h	/^	int	reasmmaxsize;$/;"	m	struct:__anon80
reasmpkt	libstar/xpcap.h	/^	char		*reasmpkt;		\/\/ 재조립된 패킷 (사용 후 메모리 해제해야 함)$/;"	m	struct:__anon153
rec_count	libstar/dvdlib.h	/^	uint		rec_count, freekb, totalkb;	\/\/ 현재 DVD에 대한 기록 카운트, 여유용량, 전체용량$/;"	m	struct:__anon33
reccount	libstar/dvdlib.h	/^	int		reccount;		\/\/ 레코딩 횟수 (DVD 교체시 초기화됨)$/;"	m	struct:__anon32
receipt	rpc.h	/^	string receipt(const char *txid)$/;"	f	class:hdac
received	libstar/netbios.c	/^	uint		received;$/;"	m	struct:__anon49	file:
rechash	libstar/dvdlib.h	/^	vhash_t		*rechash;$/;"	m	struct:__anon33
recq	libstar/dvdlib.h	/^	xlist_t		*recq;$/;"	m	struct:__anon33
recsec	libstar/dvdlib.h	/^	float		recsec;			\/\/ 레코딩에 걸린 시간 $/;"	m	struct:__anon32
recsize	libstar/dvdlib.h	/^	uint		recsize;		\/\/ 실제 레코딩된 크기 $/;"	m	struct:__anon32
recv_timeout	libstar/ftp.c	/^static	int	recv_timeout(int sock, void *buf, int buflen, int timeoutMS, const char *waitstr)$/;"	f	file:
recvaddr	hdaclib.h	/^	char	recvaddr[HDAC_ADDR_LEN];	\/\/ IN$/;"	m	struct:__anon10
recvaddr	libstar/xicmp.h	/^	uint		recvaddr;		\/\/ 상기 hostname에 해당하는 address$/;"	m	struct:__anon136
recvaddrin	libstar/xicmp.h	/^	struct sockaddr_in	recvaddrin;	\/\/ 받을 주소 (family = AF_INET, port = 0)$/;"	m	struct:__anon136	typeref:struct:__anon136::sockaddr_in
recvbuf	libstar/xtn.h	/^	char		*recvbuf;	\/\/ 수신 전용 버퍼 $/;"	m	struct:xtn
recvbytes	libstar/udp.h	/^	uint	recvbytes;		\/\/ 누적된 수신 바이트 수 $/;"	m	struct:__anon104
recvbytes	libstar/xapp.h	/^	uint		recvbytes;	\/\/ 받은 파일 용량 $/;"	m	struct:__anon113
recvid	libstar/xicmp.h	/^	int		recvid;			\/\/ ICMP 패킷의 ID로 기본적으로 위의 addr이 들어간다.$/;"	m	struct:__anon136
recvlen	libstar/xtn.h	/^	int		recvlen;	\/\/ 수신된 바이트 수 $/;"	m	struct:xtn
recvpkts	libstar/xapp.h	/^	uint		recvpkts;	\/\/ 받은 파일 수 $/;"	m	struct:__anon113
recvsize	libstar/xtn.h	/^	int		recvsize;	\/\/ 설정된 버퍼 크기 $/;"	m	struct:xtn
recvtimeoutMS	libstar/xicmp.h	/^	int		recvtimeoutMS;		\/\/ Receive timeout (밀리초)$/;"	m	struct:__anon136
remoteAddr	libstar/snmpdef.h	/^	char		remoteAddr[16];$/;"	m	struct:__anon85
remoteAddr	libstar/snmpdef.h	/^	char	remoteAddr[16];$/;"	m	struct:__anon87
remotePort	libstar/snmpdef.h	/^	int		remotePort;$/;"	m	struct:__anon85
remotePort	libstar/snmpdef.h	/^	int	remotePort;$/;"	m	struct:__anon87
remoteaddr	libstar/gw.h	/^	uint	remoteaddr;$/;"	m	struct:__anon40
remoteaddr	libstar/udp.h	/^	int	remoteaddr;		\/\/ Remote 주소 $/;"	m	struct:__anon104
remoteaddr	libstar/xapp.h	/^	uint		remoteaddr;	\/\/ FTP 서버 주소 $/;"	m	struct:__anon113
remoteaddr	libstar/xsock.h	/^	uint		remoteaddr;	\/\/ remote IP address $/;"	m	struct:xsocket
remotemac	libstar/xsock.h	/^	char		remotemac[20];$/;"	m	struct:xsocket
remoteport	libstar/gw.h	/^	uint	remoteport;$/;"	m	struct:__anon40
remoteport	libstar/udp.h	/^	int	remoteport;		\/\/ Remote 포트 $/;"	m	struct:__anon104
remoteport	libstar/xapp.h	/^	int		remoteport;	\/\/ FTP 서버 포트 $/;"	m	struct:__anon113
remoteport	libstar/xsock.h	/^	int		remoteport;	\/\/ remote port 번호 $/;"	m	struct:xsocket
remotetype	libstar/gw.h	/^	uint	remotetype;$/;"	m	struct:__anon40
remotetype	libstar/xsock.h	/^	uint		remotetype;	\/\/ remote IP의 type (GW_GATEWAY, GW_MANAGER, GW_AGENT...)$/;"	m	struct:xsocket
remove	myjson/json2.c	/^json& json::remove(const int nth)$/;"	f	class:json
repath	libstar/loglib.h	/^	char		repath[200];	\/\/ RE용 파일 패스명만..$/;"	m	struct:__anon45
repeat	libstar/xnms.h	/^	char		repeat[20][20];$/;"	m	struct:__anon145
replace	myjson/json2.c	/^json& json::replace(const int nth, const string name, const double value)$/;"	f	class:json
replace	myjson/json2.c	/^json& json::replace(const int nth, const string name, const long value)$/;"	f	class:json
replace	myjson/json2.c	/^json& json::replace(const int nth, const string name, const string value)$/;"	f	class:json
replace	myjson/json2.c	/^json& json::replace(const int nth, jsonnode node)$/;"	f	class:json
replace_common	myjson/json2.c	/^json& json::replace_common(const int nth, const string name, const string value, jsontype type)$/;"	f	class:json
replace_datestr	libstar/xtime.c	/^char	*replace_datestr(char *from, char *to)$/;"	f
replace_path	libstar/xtime.c	/^char	*replace_path(char *indir, char *infile, char *format, char *output)$/;"	f
req_raw	libstar/xsock.h	/^	int		req_raw;	\/\/ Web에서 소켓 연결 후 응답을 보내고 나면 바로 소켓 닫음. RAWDATA 요청한 경우 1 (Socket 닫지 않음)$/;"	m	struct:xsocket
request_bytes	libstar/snmpdef.h	/^	float		request_bytes;		\/\/ $/;"	m	struct:__anon96
request_bytes_sum	libstar/snmpdef.h	/^	uint64		request_bytes_sum;	\/\/ Counter64(70 - cntr64)$/;"	m	struct:__anon96
request_rate	libstar/snmpdef.h	/^	float		request_rate;		\/\/ OCTET STRING$/;"	m	struct:__anon96
requests	libstar/snmpdef.h	/^	float		requests;		\/\/ The total number of requests received on this service\/vserver. $/;"	m	struct:__anon96
requests_sum	libstar/snmpdef.h	/^	uint64		requests_sum;		\/\/ The total number of requests received on this service\/vserver. Counter64(70 - cntr64)$/;"	m	struct:__anon96
resendwallettxs	rpc.h	/^	string resendwallettxs()$/;"	f	class:hdac
reserved	libstar/nflowlib.h	/^	uint16		reserved;	\/\/  unused$/;"	m	struct:__anon54
reserved	libstar/nflowlib.h	/^	uint16		reserved;$/;"	m	struct:__anon56
reserved	libstar/nflowlib.h	/^	uint16		reserved;$/;"	m	struct:__anon58
reserved	libstar/nflowlib.h	/^	uint16		reserved;$/;"	m	struct:struct_export_v8_2
reserved	libstar/nflowlib.h	/^	uint16		reserved;$/;"	m	struct:struct_export_v8_3
reserved	libstar/nflowlib.h	/^	uint16		reserved;$/;"	m	struct:struct_export_v8_4
reserved	libstar/nflowlib.h	/^	uint16		reserved;$/;"	m	struct:struct_export_v8_5
reserved	libstar/nflowlib.h	/^	uint16       reserved;$/;"	m	struct:struct_export_v8_10
reserved	libstar/nflowlib.h	/^	uint16       reserved;$/;"	m	struct:struct_export_v8_11
reserved	libstar/nflowlib.h	/^	uint16       reserved;$/;"	m	struct:struct_export_v8_12
reserved	libstar/nflowlib.h	/^	uint16       reserved;$/;"	m	struct:struct_export_v8_7
reserved	libstar/nflowlib.h	/^	uint16       reserved;$/;"	m	struct:struct_export_v8_9
reserved	libstar/nflowlib.h	/^	uint32		reserved;	\/\/ Unused (zero) bytes$/;"	m	struct:__anon53
reserved	libstar/nflowlib.h	/^	uint32		reserved;	\/\/ unused$/;"	m	struct:__anon60
reserved	libstar/nflowlib.h	/^	uint8        reserved;$/;"	m	struct:struct_export_v8_8
resizesize	libstar/hash.h	/^	int   		resizesize;	\/\/ num items hashed after which we should increase the number of buckets $/;"	m	struct:__anon41
resolved_path	libstar/loglib.h	/^	char		resolved_path[200];	\/\/ ${YYYY} ${MM} ${DD} 등이 처리된 패스명 $/;"	m	struct:__anon45
response	libstar/xsnmp.h	/^	SnmpPdu		*response;$/;"	m	struct:__anon158
responsePer	libstar/xping.h	/^	int		responsePer;		\/\/ 응답 성공 비율$/;"	m	struct:xping
responseUS	libstar/xicmp.h	/^	int		responseUS;		\/\/ 현재 PING의 응답시각 (us)$/;"	m	struct:__anon136
responseUS	libstar/xicmp.h	/^	int		responseUS;$/;"	m	struct:__anon134
responseUS	libstar/xicmp.h	/^	int		responseUS;$/;"	m	struct:__anon135
response_bytes	libstar/snmpdef.h	/^	float		response_bytes;		\/\/ $/;"	m	struct:__anon96
response_bytes_sum	libstar/snmpdef.h	/^	uint64		response_bytes_sum;	\/\/ Counter64(70 - cntr64)$/;"	m	struct:__anon96
responses	libstar/snmpdef.h	/^	float		responses;		\/\/ $/;"	m	struct:__anon96
responses_sum	libstar/snmpdef.h	/^	uint64		responses_sum;		\/\/ Counter64(70 - cntr64)$/;"	m	struct:__anon96
result	hdaclib.h	/^	char	result[HDAC_TX_LEN];	\/\/ txid$/;"	m	struct:__anon5
result	libstar/smslib.c	/^	char	result[2];		\/\/ 전송결과(아래의 설명 참조)$/;"	m	struct:__anon75	file:
resume	contract.c	/^int	hdac_contract::resume()$/;"	f	class:hdac_contract
resume_task	rpc.h	/^	string resume_task(const char *tasks)$/;"	f	class:hdac
retaddr	libstar/xicmp.h	/^	uint		retaddr;		\/\/ 보낸 IP와 다른 IP로 응답이 오는 경우..$/;"	m	struct:__anon136
retaddr	libstar/xicmp.h	/^	uint		retaddr;		\/\/ 보낸 IP와 받은 IP가 다른 경우..$/;"	m	struct:__anon134
retcode	libstar/ocilib.h	/^	ub2		retcode;	\/* code returned when fetching this particular column *\/$/;"	m	struct:__anon61
retcode	libstar/worm.h	/^	char		retcode[8];$/;"	m	struct:__anon108
retjson	hdaclib.h	/^	char	*retjson;	\/\/ response JSON$/;"	m	struct:__anon9
retjsonlen	hdaclib.h	/^	int	retjsonlen;	\/\/ response JSON length$/;"	m	struct:__anon9
retlen	libstar/ocilib.h	/^	ub2		retlen;		\/* *\/   $/;"	m	struct:__anon61
retlen4	libstar/ocilib.h	/^	ub4		retlen4;	\/* *\/   $/;"	m	struct:__anon61
retransSegs	libstar/snmpdef.h	/^	uint	retransSegs;		\/\/ 재전송되는 세그먼트의 총 개수 $/;"	m	struct:__anon84
retries	libstar/xsnmp.h	/^	int		retries;		\/\/ xsnmp_open() 전에 xsnmp_settimeout()을 사용하는 경우를 대비해서...$/;"	m	struct:__anon158
retry	libstar/xicmp.h	/^	int		retry;			\/\/ 재발송 회수 (PING 응답 없는 경우..)$/;"	m	struct:__anon136
retryitv	libstar/gw.h	/^	uint	retryitv;		\/\/ Client accept용 socket 초기화 실패시 몇 초 간격으로 재시도 할지..$/;"	m	struct:gwrule
retryitv	libstar/xping.h	/^	int		retryitv;		\/\/ 재시도 간격$/;"	m	struct:xping
retval	hdaclib.h	/^	int	retval;$/;"	m	struct:__anon5
revoke	rpc.h	/^	string revoke(const char *addrs, const char *perms, const double native_amount = 0, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
revoke_contract	contract.c	/^int	hdac_admin::revoke_contract(const char *stream, const char *sender)$/;"	f	class:hdac_admin
revoke_contract	contract.c	/^int	hdac_admin::revoke_contract(const hdac_map_t *map)$/;"	f	class:hdac_admin
revokefrom	rpc.h	/^	string revokefrom(const char *fromaddr, const char *toaddrs, const char *perms, const double native_amount = 0, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
risingAlarm	libstar/xsnmptrap.c	/^static oid      risingAlarm[] = { 1, 3, 6, 1, 6, 3, 2, 1, 1, 3, 1 };$/;"	v	file:
rol	lib/sha1.c	27;"	d	file:
ror	lib/sha256.c	16;"	d	file:
rot	libstar/xhash.c	45;"	d	file:
route_itv	libstar/xnms.h	/^	int		route_itv;		\/\/ 라우팅 테이블 수집 주기 $/;"	m	struct:xnmsnode
router	libstar/sflowlib.h	/^	SFLExtended_router router;$/;"	m	union:_SFLFlow_type
router	libstar/xflowlib.h	/^	ipv4addr	router;		\/\/ Router의 ip address$/;"	m	struct:__anon129
router_sc	libstar/nflowlib.h	/^	ipv4addr	router_sc;	\/\/ IP address of the router that is bypassed by the Catalyst 5000 series switch.$/;"	m	struct:__anon59
router_sc	libstar/nflowlib.h	/^	uint32       router_sc;	\/* IP address of the router being shortcut *\/$/;"	m	struct:struct_export_v8_6
router_sc	libstar/nflowlib.h	/^	uint32       router_sc;	\/* IP address of the router being shortcut *\/$/;"	m	struct:struct_export_v8_7
router_sc	libstar/nflowlib.h	/^	uint32       router_sc;	\/* IP address of the router being shortcut *\/$/;"	m	struct:struct_export_v8_8
routeraddr	libstar/xflowlib.h	/^	uint	routeraddr;$/;"	m	struct:__anon128
routerbps	libstar/xflowlib.h	/^	int		routerbps;	\/\/ 라우터에서 발생한 실제 트래픽 $/;"	m	struct:__anon130
routerfps	libstar/xflowlib.h	/^	int		routerfps;	\/\/ 라우터에서 발생한 실제 트래픽 $/;"	m	struct:__anon130
routerpps	libstar/xflowlib.h	/^	int		routerpps;	\/\/ 라우터에서 발생한 실제 트래픽 $/;"	m	struct:__anon130
routing	libstar/gwauto.c	/^int	routing(xsock_t *srcsock, hash_t *ht, gwheadermax_t *hp, char *buf, int fromtype, int totype)$/;"	f
routingDiscards	libstar/snmpdef.h	/^	uint	routingDiscards;$/;"	m	struct:__anon81
row	libstar/xdb.h	/^	int		row;$/;"	m	struct:__anon115
row	libstar/xdb.h	/^	int		row;$/;"	m	struct:__anon116
row	libstar/xdb.h	/^	int		row;$/;"	m	struct:__anon117
rowbuf	libstar/xdb.h	/^	char		*rowbuf;	\/\/ SQL 1 row 저장하기 위한 버퍼 (1MB)$/;"	m	struct:__anon119
rpc_error	myjson/json.h	/^	bool rpc_error(const string jsonstr)$/;"	f	class:json
rpcip	contract.h	/^	char	rpcip[40];$/;"	m	class:hdac_admin
rpcpassword	contract.h	/^	char	rpcpassword[128];$/;"	m	class:hdac_admin
rpcpassword	hdaclib.h	/^	char	rpcpassword[64];	\/\/ RPC Password$/;"	m	struct:__anon9
rpcport	contract.h	/^	int	rpcport;$/;"	m	class:hdac_admin
rpcuser	contract.h	/^	char	rpcuser[128];$/;"	m	class:hdac_admin
rpcuserid	hdaclib.h	/^	char	rpcuserid[64];	\/\/ RPC UserId$/;"	m	struct:__anon9
rptr	libstar/xpcap.h	/^	char		*rptr;			\/\/ Read 위치 $/;"	m	struct:__anon154
rr_flags	libstar/netbios.c	/^	ushort		rr_flags;$/;"	m	struct:__anon46	file:
rsvDate	libstar/smslib.c	/^	char	rsvDate[8];		\/\/ 예약날짜(YYYYMMDD)$/;"	m	struct:__anon74	file:
rsvTime	libstar/smslib.c	/^	char	rsvTime[4];		\/\/ 예약시간(HHMM) *예약시간과 날짜는 둘다 입력이 되어야만 합니다.$/;"	m	struct:__anon74	file:
rsvd	libstar/nflowlib.h	/^	uint8		rsvd;$/;"	m	struct:__anon57
rtoAlgorithm	libstar/snmpdef.h	/^	int	rtoAlgorithm;		\/\/ 인정되지 않은 옥테트를 재전송하기 위해 사용되는 타임아웃 $/;"	m	struct:__anon84
rtoMax	libstar/snmpdef.h	/^	int	rtoMax;			\/\/ 1\/100 초 단위로 측정되는 재전송 타임 아웃을 위한 TCP 구현에 $/;"	m	struct:__anon84
rtoMin	libstar/snmpdef.h	/^	int	rtoMin;			\/\/ 1\/100 초 단위로 측정되는 재전송 타임아웃을 위한 TCP 구현에 $/;"	m	struct:__anon84
rttUS	libstar/snmpdef.h	/^	int	rttUS;			\/\/ 응답시간 (us)$/;"	m	struct:__anon78
running	libstar/xsock.h	/^	int		running;$/;"	m	struct:__anon166
rxbytes_rate	libstar/snmpdef.h	/^	float		rxbytes_rate;		\/\/ OCTET STRING$/;"	m	struct:__anon96
sac_recv	libstar/smslib.c	/^static	int	sac_recv(smsack_t *ack)$/;"	f	file:
sac_send	libstar/smslib.c	/^static	int	sac_send(smsmsg_t *sm)$/;"	f	file:
saddr	libstar/sflowlib.h	/^    uint32_t saddr;$/;"	m	struct:iphdr
samplePool	libstar/sflowlib.h	/^	uint            samplePool;$/;"	m	struct:_SFSample
sampleType	libstar/sflowlib.h	/^	uint            sampleType;$/;"	m	struct:_SFSample
sample_pool	libstar/sflowlib.h	/^	uint            sample_pool;	\/* Total number of packets that could have been$/;"	m	struct:_SFLFlow_sample
sample_pool	libstar/sflowlib.h	/^	uint            sample_pool;	\/* Total number of packets that could have been$/;"	m	struct:_SFLFlow_sample_expanded
sampledPacketSize	libstar/sflowlib.h	/^	uint            sampledPacketSize;$/;"	m	struct:_SFSample
samplesGenerated	libstar/sflowlib.h	/^	uint            samplesGenerated;$/;"	m	struct:_SFSample
samplesInPacket	libstar/sflowlib.h	/^	uint		samplesInPacket;$/;"	m	struct:_SFSample
sampling	libstar/xflowlib.h	/^	int		sampling;	\/\/ 샘플링 비율. 10이면 매 10번째 패킷만 받아서 처리..$/;"	m	struct:xflow
sampling_rate	libstar/sflowlib.h	/^	uint            sampling_rate;	\/* fsPacketSamplingRate *\/$/;"	m	struct:_SFLFlow_sample
sampling_rate	libstar/sflowlib.h	/^	uint            sampling_rate;	\/* fsPacketSamplingRate *\/$/;"	m	struct:_SFLFlow_sample_expanded
savetty	libstar/xstr.c	/^static	struct termio savetty = {0};$/;"	v	typeref:struct:termio	file:
sbproc_term	libstar/xtn.c	/^void sbproc_term(SOCKET server,unsigned char data)$/;"	f
scale	libstar/ocilib.h	/^	ub2		scale;		\/* column scale *\/$/;"	m	struct:__anon61
scanitv	libstar/xping.h	/^	int		scanitv;		\/\/ Scan Interval$/;"	m	struct:xping
sec	libstar/xpcap.h	/^	uint		sec;			\/\/ 캡쳐한 시각 (초) $/;"	m	struct:__anon152
sec	libstar/xtime.c	/^	uchar    hour, min, sec;	\/\/ 0..23시간  0..59분  0..59초 $/;"	m	struct:__anon169	file:
seconds	hdaclib.h	/^	int	seconds;$/;"	m	struct:__anon8
secu_name	libstar/xnms.h	/^	char		secu_name[40];		\/\/ SNMP v3 security name$/;"	m	struct:xnmsnode
secu_name	libstar/xsnmp.h	/^	char		secu_name[64];		\/\/ 이름 $/;"	m	struct:__anon158
secu_passwd	libstar/xnms.h	/^	char		secu_passwd[40];	\/\/ SNMP v3 security pass phrase$/;"	m	struct:xnmsnode
secu_passwd	libstar/xsnmp.h	/^	char		secu_passwd[64];	\/\/ 패스워드 문자열$/;"	m	struct:__anon158
secu_proto	libstar/xnms.h	/^	char		secu_proto[8];		\/\/ SNMP v3 security protocol$/;"	m	struct:xnmsnode
secu_proto	libstar/xsnmp.h	/^	char		secu_proto[20];		\/\/ MD5\/SHA$/;"	m	struct:__anon158
selectquery	libstar/xdb.h	/^	char		selectquery[256];$/;"	m	struct:__anon118
selftestfail	libstar/xnms.h	/^	int		selftestfail;		\/\/ .11	\/\/ 0=self test passwd other=error condition$/;"	m	struct:__anon148
send	contract.c	/^int	hdac_contract::send()$/;"	f	class:hdac_contract
send	rpc.h	/^	string send(const char *addr, const double amount, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
send_asset	rpc.h	/^	string send_asset(const char *addr, const char *asset_qty, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
send_stat	hdaclib.h	/^	hdac_send_limit_t	*send_stat;$/;"	m	struct:__anon9
send_value	hdaclib.h	/^	char	send_value[64];			\/\/ IN$/;"	m	struct:__anon10
sendaddr	libstar/xicmp.h	/^	uint		sendaddr;		\/\/ 상기 hostname에 해당하는 address$/;"	m	struct:__anon136
sendaddrin	libstar/xicmp.h	/^	struct sockaddr_in	sendaddrin;	\/\/ 보낼 주소 (family = AF_INET, port = 0)$/;"	m	struct:__anon136	typeref:struct:__anon136::sockaddr_in
sendasset	rpc.h	/^	string sendasset(const char *addr, const char *asset_id, const double asset_qty, const double native_amount, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
sendassetfrom	rpc.h	/^	string sendassetfrom(const char *fromaddr, const char *toaddr, const char *asset_id, const double asset_qty, const double native_amount, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
sendbytes	libstar/udp.h	/^	uint	sendbytes;		\/\/ 누적된 송신 바이트 수$/;"	m	struct:__anon104
sendbytes	libstar/xapp.h	/^	uint		sendbytes;	\/\/ 보낸 파일 용량 $/;"	m	struct:__anon113
sendclock	libstar/xicmp.h	/^	double		sendclock;		\/\/ 데이터 보낸 시각으로 HiresClock 시간이다.$/;"	m	struct:__anon136
sender	contract.h	/^	char	sender[HDAC_ADDR_LEN];		\/\/ contract sender$/;"	m	struct:__anon1
sendfrom	rpc.h	/^	string sendfrom(const char *fromaddr, const char *toaddr, const double amount, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
sendfrom_asset	rpc.h	/^	string sendfrom_asset(const char *fromaddr, const char *toaddr, const char *asset_qty, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
sendfromaccount	rpc.h	/^	string sendfromaccount(const char *fromaccount, const char *toaddr, const double amount, const int minconf = 1, const char *comment = "", const char *comment_to = "")$/;"	f	class:hdac
sendid	libstar/xicmp.h	/^	int		sendid;			\/\/ ICMP 패킷의 ID로 기본적으로 위의 addr이 들어간다.$/;"	m	struct:__anon136
sendmany	rpc.h	/^	string sendmany(const char *fromaccount, const char *addr_amounts, const int minconf = 1, const char *comment = "")$/;"	f	class:hdac
sendpkts	libstar/xapp.h	/^	uint		sendpkts;	\/\/ 보낸 파일 수 $/;"	m	struct:__anon113
sendrawtx	rpc.h	/^	string sendrawtx(const char *tx_hex, bool allowhighfees = false)$/;"	f	class:hdac
sendthread	libstar/xping.c	/^static	VTHREAD	sendthread(void *arg)$/;"	f	file:
sendtimeoutMS	libstar/xicmp.h	/^	int		sendtimeoutMS;		\/\/ Send timeout (밀리초)$/;"	m	struct:__anon136
sendwithdata	rpc.h	/^	string sendwithdata(const char *addr, const double amount, const char *data, int datalen = 0)$/;"	f	class:hdac
sendwithdata_asset	rpc.h	/^	string sendwithdata_asset(const char *addr, const char *asset_qty, const char *data, int datalen = 0)$/;"	f	class:hdac
sendwithdatafrom	rpc.h	/^	string sendwithdatafrom(const char *fromaddr, const char *toaddr, const double amount, const char *data, int datalen = 0)$/;"	f	class:hdac
sendwithdatafrom_asset	rpc.h	/^	string sendwithdatafrom_asset(const char *fromaddr, const char *toaddr, const char *asset_qty, const char *data, int datalen = 0)$/;"	f	class:hdac
seq	libstar/sflowlib.h	/^		uint           *seq;$/;"	m	union:_SFLExtended_as_path_segment::__anon70
seq	libstar/xicmp.h	/^	int		seq;			\/\/ 몇번동안 라우터를 거쳐왔는지 알기 위해...$/;"	m	struct:__anon136
seq	libstar/xpcap.h	/^	uint		seq, ack;$/;"	m	struct:__anon153
sequence	libstar/sflowlib.h	/^      uint16_t	sequence;$/;"	m	struct:icmphdr::__anon67::__anon68
sequenceNo	libstar/sflowlib.h	/^	uint            sequenceNo;	\/* XXX: suffers cleanup *\/$/;"	m	struct:_SFSample
sequence_number	libstar/sflowlib.h	/^	uint            sequence_number;	\/* Incremented with each counters sample$/;"	m	struct:_SFLCounters_sample
sequence_number	libstar/sflowlib.h	/^	uint            sequence_number;	\/* Incremented with each counters sample$/;"	m	struct:_SFLCounters_sample_expanded
sequence_number	libstar/sflowlib.h	/^	uint            sequence_number;	\/* Incremented with each flow sample$/;"	m	struct:_SFLFlow_sample
sequence_number	libstar/sflowlib.h	/^	uint            sequence_number;	\/* Incremented with each flow sample$/;"	m	struct:_SFLFlow_sample_expanded
sequence_number	libstar/sflowlib.h	/^	uint            sequence_number;	\/* Incremented with each sample datagram$/;"	m	struct:_SFLSample_datagram_hdr
serial	libstar/lock.h	/^	char		serial[64];		\/\/ 결과 Serial 번호 $/;"	m	struct:__anon44
serial	libstar/snmpdef.h	/^	char	serial[30];$/;"	m	struct:__anon76
serialize	myjson/json.h	/^	string serialize()$/;"	f	class:json
seriallen	libstar/lock.h	/^	int		seriallen;		\/\/ 비교할 serial 길이 (8, 16)$/;"	m	struct:__anon44
serialno	libstar/xnms.h	/^	int		serialno;		\/\/ .17$/;"	m	struct:__anon147
serialno	libstar/xnms.h	/^	int		serialno;		\/\/ .3	08.11.1$/;"	m	struct:__anon148
serialstr	libstar/xnms.h	/^	char		serialstr[32];		\/\/ .19$/;"	m	struct:__anon147
serialstr	libstar/xnms.h	/^	char		serialstr[32];		\/\/ .26$/;"	m	struct:__anon148
server	libstar/ocilib.h	/^	OCIServer	*server;	\/* private server handle *\/$/;"	m	struct:ociconn
server	libstar/ssmtplib.h	/^	char		server[80];$/;"	m	struct:__anon103
serverName	libstar/http.c	/^	char	serverName[60];	\/\/ Microsoft-IIS\/5.0 $/;"	m	struct:__anon43	file:
serverflags	libstar/ssmtp.h	/^	int             serverflags;		\/\/ Server capability flags $/;"	m	struct:__anon101
serviceName	libstar/snmpdef.h	/^	char	serviceName[32];	\/\/ \/etc\/services 서비스명$/;"	m	struct:__anon92
service_name	libstar/netbios.c	/^	char		*service_name;$/;"	m	struct:__anon51	file:
service_number	libstar/netbios.c	/^	uchar		service_number;$/;"	m	struct:__anon51	file:
services	libstar/snmpdef.h	/^	uint	services;$/;"	m	struct:__anon76
sess_cur	libstar/snmpdef.h	/^	uint		sess_cur;		\/\/ 현재 세션 수$/;"	m	struct:__anon96
sess_drop	libstar/snmpdef.h	/^	uint		sess_drop;		\/\/ $/;"	m	struct:__anon96
sess_fail	libstar/snmpdef.h	/^	uint		sess_fail;		\/\/ 세션 fail 수$/;"	m	struct:__anon96
sess_high	libstar/snmpdef.h	/^	uint		sess_high;$/;"	m	struct:__anon96
sess_process	libstar/snmpdef.h	/^	uint		sess_process;		\/\/ 처리된 세션 수 (total 세션수의 차이)$/;"	m	struct:__anon96
sess_total	libstar/snmpdef.h	/^	float		sess_total;		\/\/ 총 세션 수 (누적)$/;"	m	struct:__anon96
sessid	libstar/worm.h	/^	char		sessid[40];$/;"	m	struct:__anon109
session	libstar/ocilib.h	/^	OCISession	*session;	\/* private session handle *\/$/;"	m	struct:ociconn
session	libstar/xsnmp.h	/^	SnmpSession	*session;$/;"	m	struct:__anon158
sessp	libstar/xsnmp.h	/^	void		*sessp;$/;"	m	struct:__anon158
set	contract.c	/^int	hdac_contract::set(hdac_map_t& map)$/;"	f	class:hdac_contract
set	contract.h	/^	void	set(hdac_t *newhdac)$/;"	f	class:hdac_contract
set	libstar/sflowlib.h	/^		uint           *set;$/;"	m	union:_SFLExtended_as_path_segment::__anon70
set_hdac	contract.h	/^	void	set_hdac(hdac_t *newhdac)$/;"	f	class:hdac_admin
set_hdac	node.h	/^	void	set_hdac(hdac_t *newhdac)$/;"	f	class:hdac_node
set_hdac	node.h	/^	void	set_hdac(hdac_t *newhdac)$/;"	f	class:hdac_virtual_device
set_limit	rpc.h	/^	int set_limit(const hdac_send_limit_t *lp)$/;"	f	class:hdac
setaccount	rpc.h	/^	string setaccount(const char *addr, const char *account)$/;"	f	class:hdac
setcmdwaitms	libstar/xutil.c	/^void	setcmdwaitms(int waitMS)$/;"	f
setconfopt	libstar/xstr.c	/^void	setconfopt(char *opt, int isset)$/;"	f
setdebugopt	libstar/xdebug.h	64;"	d
setlastblock	rpc.h	/^	string setlastblock(const int height)$/;"	f	class:hdac
setlastblockbyhash	rpc.h	/^	string setlastblockbyhash(const char *hash)$/;"	f	class:hdac
setlogcallback	libstar/xdebug.c	/^void	setlogcallback(char *logfile, void (*logfunc) (char *buf))$/;"	f
setlogfile	libstar/xdebug.c	/^logdata_t	*setlogfile(char *logfile, uint size, int nbackup)$/;"	f
setlogopt	libstar/xdebug.c	/^void	setlogopt(char *logfile, uint size, int nbackup, int opt)$/;"	f
setname	myjson/json2.c	/^json& json::setname(const int nth, const string name)$/;"	f	class:json
setoption	libstar/xdebug.h	62;"	d
setoptionstr	libstar/xdebug.h	63;"	d
setoptionvalue	libstar/xdebug.c	/^int	setoptionvalue(char *name, char *value)$/;"	f
setruntimeparam	rpc.h	/^	string setruntimeparam(const char *param_name, const char *param_value = "")$/;"	f	class:hdac
setsignal	libstar/xdebug.c	/^void	setsignal(void)$/;"	f
settxfee	rpc.h	/^	string settxfee(const double amount)$/;"	f	class:hdac
setvalue	myjson/json2.c	/^json& json::setvalue(const int nth, const string name, const double value)$/;"	f	class:json
setvalue	myjson/json2.c	/^json& json::setvalue(const int nth, const string name, const long value)$/;"	f	class:json
setvalue	myjson/json2.c	/^json& json::setvalue(const int nth, const string name, const string value)$/;"	f	class:json
setvalue_common	myjson/json2.c	/^json& json::setvalue_common(const int nth, const string name, const string value, const jsontype type)$/;"	f	class:json
sfclass	libstar/sflowlib.h	/^	uint            sfclass;$/;"	m	struct:_SFSample
sflow_parse	libstar/sflowlib.c	/^int	sflow_parse(xflow_t *xfp, xflow_packet_t *pktp)$/;"	f
sflow_to_common	libstar/xflowconv.c	/^int	sflow_to_common(ipv4addr exportaddr, SFSample *spp, register xflow_rawdata_t *common)$/;"	f
sha1	lib/libhash.c	/^char	*sha1(char *outhash, const char *str, const size_t len)$/;"	f
sha256	lib/libhash.c	/^char	*sha256(char *outhash, const char *str, const size_t len)$/;"	f
sha256_impl	lib/base58.c	/^bool (*sha256_impl)(void *, const void *, size_t) = NULL;$/;"	v
sha512	lib/libhash.c	/^char	*sha512(char *outhash, const char *str, const size_t len)$/;"	f
shape	json11/json11.hpp	/^    typedef std::initializer_list<std::pair<std::string, Type>> shape;$/;"	t	class:json11::final
shash_delete	libstar/shash.c	/^void		shash_delete(register shash_t *ht, register shashent_t *she)$/;"	f
shash_deleteall	libstar/shash.c	/^void		shash_deleteall(shash_t *ht)$/;"	f
shash_fast_func	libstar/shash.c	/^uint32	shash_fast_func(const char *data, size_t len)$/;"	f
shash_find	libstar/shash.c	/^shashent_t	*shash_find(register shash_t *ht, void *key)$/;"	f
shash_findempty	libstar/shash.c	/^shashent_t	*shash_findempty(register shash_t *ht, void *key)$/;"	f
shash_findnext	libstar/shash.c	/^shashent_t	*shash_findnext(register shash_t *ht, shashloop_t *slp, void *key)$/;"	f
shash_first	libstar/shash.c	/^shashent_t	*shash_first(shash_t *ht, shashloop_t *slp)$/;"	f
shash_free	libstar/shash.h	62;"	d
shash_func	libstar/shash.c	/^uint	shash_func(const void *key, size_t len)$/;"	f
shash_getdata	libstar/shash.c	/^void		*shash_getdata(shash_t *ht, shashent_t *she, int *datalen)$/;"	f
shash_getkey	libstar/shash.c	/^void		*shash_getkey(shash_t *ht, shashent_t *she, int *keylen)$/;"	f
shash_getsize	libstar/shash.c	/^int	shash_getsize(shash_t *ht)$/;"	f
shash_init	libstar/shash.h	59;"	d
shash_insert	libstar/shash.h	72;"	d
shash_lock	libstar/shash.h	65;"	d
shash_next	libstar/shash.c	/^shashent_t	*shash_next(shash_t *ht, shashloop_t *slp)$/;"	f
shash_t	libstar/shash.h	/^}	shash_t;$/;"	t	typeref:struct:__anon71
shash_unlock	libstar/shash.h	66;"	d
shash_update	libstar/shash.h	73;"	d
shashent_t	libstar/shash.h	/^}	shashent_t;$/;"	t	typeref:struct:__anon73
shashloop_t	libstar/shash.h	/^}	shashloop_t;$/;"	t	typeref:struct:__anon72
shellcommand	libstar/xutil.c	/^int		shellcommand(const char *command, int flag)$/;"	f
sign1	hdaclib.h	/^	char	sign1[1600];			\/\/ 1'st OUT$/;"	m	struct:__anon10
sign2	hdaclib.h	/^	char	sign2[2048];			\/\/ 2'nd OUT$/;"	m	struct:__anon10
signmessage	rpc.h	/^	string signmessage(const char *addr_or_privkey, const char *message)$/;"	f	class:hdac
signrawtx	rpc.h	/^	string signrawtx(const char *tx_hex, const char *prevtxs = "", const char *privatekeys = "", const char *sighashtype = "ALL")$/;"	f	class:hdac
simul_down	libstar/xicmp.c	/^int	simul_down(uint addr)$/;"	f
sitename	libstar/snmpdef.h	/^	char		sitename[20];		\/\/ OCTET STRING(4 - octets)$/;"	m	struct:__anon96
size	json11/json11.hpp	/^    const int size()$/;"	f	class:json11::final
size	json2.h	/^	int size(int depth = 1)	{ return m_count[depth]; }$/;"	f	class:json
size	libstar/loglib.h	/^	uint		size;		\/\/ 마지막 파일 크기 $/;"	m	struct:__anon45
size	libstar/worm.h	/^	char		size[16];		\/\/ 버퍼 크기 or quota_size_mb$/;"	m	struct:__anon110
size	libstar/xdebug.h	/^	uint		size;			\/\/ default=1MB$/;"	m	struct:__anon126
size	libstar/xstr.h	/^	uint	size;	\/\/ 버퍼의 크기 $/;"	m	struct:__anon168
size	myjson/json.h	/^	int size(const int depth = 0)$/;"	f	class:json
size	myjson/json2.h	/^	int size(int depth = 1)	{ return m_count[depth]; }$/;"	f	class:json
skipBytes	libstar/sflowlib.c	/^static	void	skipBytes(SFSample * sample, int skip)$/;"	f	file:
skiponfail	libstar/xnms.h	/^	int		skiponfail;		\/\/ SNMP 쿼리 실패시 즉각 SNMP 쿼리 중단함 (GETNEXT 항목인 많은 경우에 유용함)$/;"	m	struct:xnmsnode
sleepms	libstar/xtime.c	/^int	sleepms(int millisec)$/;"	f
sleepms	myjson/test.c	9;"	d	file:
sleepms	myjson/test2.c	9;"	d	file:
sleepus	libstar/xtime.c	/^int	sleepus(uint microsec)$/;"	f
slotconfig	libstar/xnms.h	/^	char		slotconfig[40];		\/\/ .15	\/\/ f(x)=0 : slot 없음. f(x)=exp(2,x-1) : 해당 비트의 모듈 장착됨 $/;"	m	struct:__anon147
slotnum	libstar/xnms.h	/^	int		slotnum;		\/\/ .25	\/\/ slot number$/;"	m	struct:__anon148
slow_snmp_response_limit	libstar/xnms.h	/^	int		slow_snmp_response_limit;	\/\/ 응답시간이 늦은 장비는 별도 관리되는데.. 그 기준이 되는 시간..$/;"	m	struct:__anon149
sms_close	libstar/smslib.c	/^void	sms_close()$/;"	f
sms_open	libstar/smslib.c	/^int	sms_open(char *ipaddr, int port)$/;"	f
sms_send	libstar/smslib.c	/^int	sms_send(char *userid, char *passwd, char *phoneNumber, char *message, char *replyNumber)$/;"	f
smsack_t	libstar/smslib.c	/^}	smsack_t;$/;"	t	typeref:struct:__anon75	file:
smsmsg_t	libstar/smslib.c	/^}	smsmsg_t;$/;"	t	typeref:struct:__anon74	file:
smtp_close	libstar/smtp.c	/^void	smtp_close(int sock)$/;"	f
smtp_open	libstar/smtp.c	/^int	smtp_open(uint addr, int port)$/;"	f
smtp_recv	libstar/smtp.c	/^static	int	smtp_recv(int sock, char *errbuf)$/;"	f	file:
smtp_send	libstar/smtp.c	/^static	int	smtp_send(int sock, const char *buf)$/;"	f	file:
smtp_sendmail	libstar/smtp.c	/^int	smtp_sendmail(int sock, char *orguserid, char *from, char *to, char *subject, char *text, char *errbuf)$/;"	f
smtp_settimeout	libstar/smtp.c	/^void	smtp_settimeout(int timeout)$/;"	f
snaplen	libstar/xpcap.h	/^	int		snaplen;		\/\/ 패킷 캡쳐 길이 $/;"	m	struct:__anon154
snmp_allocinfo	libstar/snmpsub.c	/^snmpinfo_t	*snmp_allocinfo(snmpinfo_t *sizei)$/;"	f
snmp_bulk_size	libstar/xsnmp.h	/^	int		snmp_bulk_size;$/;"	m	struct:__anon158
snmp_calc_l4sess	libstar/snmpsub.c	/^void	snmp_calc_l4sess(l4sess_t *cursesslist, int curnumsess, l4sess_t *oldsesslist, int oldnumsess)$/;"	f
snmp_calcavg	libstar/snmpsub.c	/^void	snmp_calcavg(snmpif_t *avgiflist, snmpif_t *sumiflist, int numif, int count)$/;"	f
snmp_calcif	libstar/snmpsub.c	/^void	snmp_calcif(snmpif_t *curiflist, int ncuriflist, snmpif_t *oldiflist, int noldiflist)$/;"	f
snmp_calcif2	libstar/snmpsub.c	/^void	snmp_calcif2(snmpif_t *curif, snmpif_t *oldif, float interval)$/;"	f
snmp_calcstat	libstar/snmpsub.c	/^void	snmp_calcstat(snmpif_t *destiflist, int ndestiflist, snmpif_t *srciflist, int nsrciflist, int op)$/;"	f
snmp_calcstat2	libstar/snmpsub.c	/^void	snmp_calcstat2(snmpif_t *destif, snmpif_t *srcif, float interval, int op)$/;"	f
snmp_calcxif	libstar/snmpsub.c	/^void	snmp_calcxif(snmpif_t *curiflist, int curnumif, snmpxif_t *curxiflist, int ncurxiflist, snmpxif_t *oldxiflist, int noldxiflist)$/;"	f
snmp_check_ifhw	libstar/xnms.c	/^static	int	snmp_check_ifhw(xnmsnode_t *xn)$/;"	f	file:
snmp_check_status	libstar/xnms.c	/^static	int	snmp_check_status(vhash_t *ifhash, xnmsnode_t *xn, snmpif_t *ifstatusrt, int numif)$/;"	f	file:
snmp_check_syshw	libstar/xnms.c	/^static	int	snmp_check_syshw(xnmsnode_t *xn)$/;"	f	file:
snmp_clearinfo	libstar/snmpsub.c	/^void	snmp_clearinfo(snmpinfo_t *snmpi)$/;"	f
snmp_dumpinfo	libstar/snmpdump.c	/^void	snmp_dumpinfo(snmpinfo_t *snmpi)$/;"	f
snmp_dupinfo	libstar/snmpsub.c	/^snmpinfo_t	*snmp_dupinfo(snmpinfo_t *srcsnmpi)$/;"	f
snmp_freeinfo	libstar/snmpsub.c	/^void	snmp_freeinfo(snmpinfo_t *snmpi)$/;"	f
snmp_get_ver	libstar/xnms.h	/^	int		snmp_get_ver;		\/\/ SNMP get version  (0=자동)$/;"	m	struct:xnmsnode
snmp_get_ver	libstar/xsnmp.h	/^	int		snmp_get_ver;		\/\/ SNMP 쿼리 버전 (이 버전으로만 정보 입수함)$/;"	m	struct:__anon158
snmp_inf_cache_sec	libstar/xsnmp.h	/^	int		snmp_inf_cache_sec;	\/\/ INF 정보 캐시 보관 시간..$/;"	m	struct:__anon158
snmp_setdefinfo	libstar/snmpsub.c	/^snmpinfo_t	*snmp_setdefinfo(snmpinfo_t *sizei)$/;"	f
snmp_timeout_ms	libstar/xnms.h	/^	int		snmp_timeout_ms;		\/\/ SNMP 마이크로초 단위 (default=1000000==1초)$/;"	m	struct:xnmsnode
snmp_trap_callback	libstar/xsnmptrap.c	/^int snmp_trap_callback(int op, struct snmp_session *session, int reqid, struct snmp_pdu *pdu, void *magic)$/;"	f
snmp_v1_only	libstar/xnms.h	/^	int		snmp_v1_only;			\/\/ 1이면 모든 쿼리는 SNMP v1으로.. (GETBULK가 문제를 일으키는 경우가 있음)$/;"	m	struct:__anon149
snmp_version	libstar/snmpdef.h	/^	int	snmp_version;		\/\/ SNMP Version$/;"	m	struct:__anon76
snmp_version	libstar/xnms.h	/^	int		snmp_version;		\/\/ SNMP V2 지원하면 2$/;"	m	struct:xnmsnode
snmp_version	libstar/xsnmp.h	/^	int		snmp_version;$/;"	m	struct:__anon158
snmpat_t	libstar/snmpdef.h	/^}	snmpat_t;$/;"	t	typeref:struct:__anon79
snmpcount	libstar/xnms.h	/^	int		snmpcount;		\/\/ I\/F 전체 수집 횟수$/;"	m	struct:xnmsnode
snmpdelayMS	libstar/xnms.h	/^	int		snmpdelayMS;		\/\/ SNMP 쿼리 중간의 delay 시간 $/;"	m	struct:xnmsnode
snmpdelayMS	libstar/xsnmp.h	/^	int		snmpdelayMS;		\/\/ SNMP 쿼리 중간의 delay (IF 전체 긁어올 때)$/;"	m	struct:__anon158
snmpfail	libstar/xnms.h	/^	int		snmpfail;		\/\/ 연속적으로 SNMP 실패한 회수. 연속 snmpstop회 이상이면$/;"	m	struct:xnmsnode
snmpfailkey_t	libstar/xsnmpif.c	/^}	snmpfailkey_t;$/;"	t	typeref:struct:__anon164	file:
snmpfailtime	libstar/xnms.h	/^	time32		snmpfailtime;		\/\/ SNMP fail 시작 시간 $/;"	m	struct:xnmsnode
snmpgetnext	libstar/xnms.h	/^	int		snmpgetnext;		\/\/ SNMP_GETNEXT로 정보 수집이 되는 경우...$/;"	m	struct:xnmsnode
snmpgetnext	libstar/xsnmp.h	/^	int		snmpgetnext;		\/\/ SNMP_GETNEXT로 정보 수집해야 함...$/;"	m	struct:__anon158
snmphwcount	libstar/xnms.h	/^	int		snmphwcount;		\/\/ H\/W 전체 수집 횟수$/;"	m	struct:xnmsnode
snmpicmp_t	libstar/snmpdef.h	/^}	snmpicmp_t;$/;"	t	typeref:struct:__anon83
snmpif_t	libstar/snmpdef.h	/^}	snmpif_t;$/;"	t	typeref:struct:__anon78
snmpifcache_t	libstar/xsnmp.h	/^}	snmpifcache_t;$/;"	t	typeref:struct:__anon159
snmpinfo_t	libstar/snmpdef.h	/^}	snmpinfo_t;$/;"	t	typeref:struct:__anon93
snmpip_t	libstar/snmpdef.h	/^}	snmpip_t;$/;"	t	typeref:struct:__anon81
snmpiptable_t	libstar/snmpdef.h	/^}	snmpiptable_t;$/;"	t	typeref:struct:__anon80
snmpres	libstar/xnms.h	/^	void		*snmpres;		\/\/ 결과값 저장용 변수$/;"	m	struct:xnmsnode
snmpresponseMS	libstar/xnms.h	/^	float		snmpresponseMS;		\/\/ SNMP 응답시간$/;"	m	struct:xnmsnode
snmpretry	libstar/xnms.h	/^	int		snmpretry;		\/\/ SNMP 실패시 재시도 회수 (default=3회)$/;"	m	struct:xnmsnode
snmproute_t	libstar/snmpdef.h	/^}	snmproute_t;$/;"	t	typeref:struct:__anon82
snmpstatus	libstar/xnms.h	/^	int		snmpstatus;		\/\/ EV_SNMP_xx$/;"	m	struct:xnmsnode
snmpstop	libstar/xnms.h	/^	int		snmpstop;		\/\/ SNMP 쿼리가 연속적으로 몇 번 실패하면 해당 노드에 대한 SNMP를 스톱시킬지 설정$/;"	m	struct:xnmsnode
snmpsys_t	libstar/snmpdef.h	/^}	snmpsys_t;$/;"	t	typeref:struct:__anon76
snmptcp_t	libstar/snmpdef.h	/^}	snmptcp_t;$/;"	t	typeref:struct:__anon84
snmptcpconn_t	libstar/snmpdef.h	/^}	snmptcpconn_t;$/;"	t	typeref:struct:__anon85
snmptcpsum_t	libstar/snmpdef.h	/^}	snmptcpsum_t;$/;"	t	typeref:struct:__anon91
snmpterm	libstar/xnms.h	/^	int		snmpterm;		\/\/ I\/F 정보 수집 주기$/;"	m	struct:xnmsnode
snmptrapd_add_session	libstar/xsnmptrap.c	/^static struct snmp_session *snmptrapd_add_session(netsnmp_transport * t)$/;"	f	file:
snmptrapd_close_sessions	libstar/xsnmptrap.c	/^static void snmptrapd_close_sessions(struct snmp_session *sess_list)$/;"	f	file:
snmpudp_t	libstar/snmpdef.h	/^}	snmpudp_t;$/;"	t	typeref:struct:__anon86
snmpudpconn_t	libstar/snmpdef.h	/^}	snmpudpconn_t;$/;"	t	typeref:struct:__anon87
snmpus	libstar/snmpdef.h	/^	float	snmpus;			\/\/ SNMP 응답시간 $/;"	m	struct:__anon76
snmpxif_t	libstar/snmpdef.h	/^}	snmpxif_t;$/;"	t	typeref:struct:__anon77
snprint_bitstring	libstar/xsnmp.h	67;"	d
snprint_counter	libstar/xsnmp.h	72;"	d
snprint_counter64	libstar/xsnmp.h	65;"	d
snprint_double	libstar/xsnmp.h	78;"	d
snprint_float	libstar/xsnmp.h	77;"	d
snprint_gauge	libstar/xsnmp.h	73;"	d
snprint_integer	libstar/xsnmp.h	66;"	d
snprint_ipaddress	libstar/xsnmp.h	71;"	d
snprint_null	libstar/xsnmp.h	69;"	d
snprint_object_identifier	libstar/xsnmp.h	70;"	d
snprint_octet_string	libstar/xsnmp.h	68;"	d
snprint_opaque	libstar/xsnmp.h	75;"	d
snprint_timeticks	libstar/xsnmp.h	74;"	d
snprint_uinteger	libstar/xsnmp.h	76;"	d
snprintf	json11/json11.hpp	66;"	d
snprintf	libstar/xstr.c	/^int	snprintf(char *buf, ...)$/;"	f
sock	libstar/udp.h	/^	int	sock;			\/\/ socket descriptor$/;"	m	struct:__anon104
sock	libstar/xapp.h	/^	int		sock;		\/\/ FTP command socket$/;"	m	struct:__anon113
sock	libstar/xicmp.h	/^	int		sock;			\/\/ ICMP 패킷을 보낼 소켓$/;"	m	struct:__anon136
sock	libstar/xtn.h	/^	int		sock;		\/\/ telnet 세션 socket$/;"	m	struct:xtn
sock_accept	libstar/xsock.h	120;"	d
sock_client_init	libstar/xsock.h	116;"	d
sock_client_init_timeout	libstar/xsock.h	117;"	d
sock_close	libstar/xsock.h	119;"	d
sock_closed	libstar/xsock.c	/^int	sock_closed(int sockfd)$/;"	f
sock_hasdata	libstar/xsock.c	/^int	sock_hasdata(int sockfd, int waitMS)$/;"	f
sock_open	libstar/xsock.h	118;"	d
sock_server_init	libstar/xsock.h	115;"	d
sock_timeout	libstar/xsock.c	/^void	sock_timeout(int ms)$/;"	f
sockaddr	libstar/udp.h	/^	struct sockaddr_in sockaddr;$/;"	m	struct:__anon104	typeref:struct:__anon104::sockaddr_in
sockcallback_t	libstar/xsock.h	/^typedef void (*sockcallback_t) (xsock_t *sock, int event, char *buf, int buflen);$/;"	t
socket	libstar/ssmtp.h	/^	int             socket;			\/\/ socket handle $/;"	m	struct:__anon101
sockfd	libstar/xssl.h	/^	int		sockfd;$/;"	m	struct:__anon167
socklen_t	libstar/type.h	/^typedef	int			socklen_t;$/;"	t
socklen_t	libstar/type.h	/^typedef	uint			socklen_t;$/;"	t
sockno_check	libstar/xdebug.c	/^int	sockno_check(int port, int maxcount, int limit)$/;"	f
sockno_count	libstar/xdebug.c	/^void	sockno_count(const char *filename, const int lineno, int sock, int isopen)$/;"	f
sockpath	libstar/xdb.h	/^	char		sockpath[256];$/;"	m	struct:__anon118
sortkey	libstar/snmpdef.h	/^	int	sortkey;$/;"	m	struct:__anon92
sourceIP	libstar/sflowlib.h	/^	struct in_addr  sourceIP;$/;"	m	struct:_SFSample	typeref:struct:_SFSample::in_addr
sourceIPAddress	libstar/xicmp.h	/^	uint		sourceIPAddress;	\/\/ Source address$/;"	m	struct:__anon131
source_id	libstar/nflowlib.h	/^	uint32       source_id;	\/* Exporter Observation Domain *\/$/;"	m	struct:template_cache_entry
source_id	libstar/sflowlib.h	/^	uint            source_id;	\/* fsSourceId *\/$/;"	m	struct:_SFLCounters_sample
source_id	libstar/sflowlib.h	/^	uint            source_id;	\/* fsSourceId *\/$/;"	m	struct:_SFLFlow_sample
speedmbps	libstar/snmpdef.h	/^	float		speedmbps;$/;"	m	struct:__anon77
speedmbps	libstar/snmpdef.h	/^	float	speedmbps;		\/\/ I\/F speed Mbps - 100Kbps 나오는 장비도 있기 때문에..$/;"	m	struct:__anon78
split_token	hdaclib.c	/^int	split_token(const char *data, char *tokenv[], int maxnumtoken)$/;"	f
sql	libstar/xdb.h	/^	char		*sql;		\/\/ SQL 문장 (alloc됨)$/;"	m	struct:__anon119
sqlcount	libstar/xdb.h	/^	uint		sqlcount;	\/\/ 실행한 SQL 문장 수 $/;"	m	struct:__anon118
sqlfailcount	libstar/xdb.h	/^	uint		sqlfailcount;$/;"	m	struct:__anon118
sqlokcount	libstar/xdb.h	/^	uint		sqlokcount;$/;"	m	struct:__anon118
squeeze_path	libstar/xstr.c	/^char	*squeeze_path(char *src, char *dst, int dstlen)$/;"	f
srbExec	libstar/dvdlib.c	/^	SRB_ExecSCSICmd srbExec;$/;"	m	struct:__anon28	file:
srbExec	libstar/oddlibwin.c	/^	SRB_ExecSCSICmd srbExec;$/;"	m	struct:__anon65	file:
src	libstar/sflowlib.h	/^	SFLAddress      src;	\/* Source address *\/$/;"	m	struct:_SFLExtended_nat
srcMask	libstar/sflowlib.h	/^	uint            srcMask;$/;"	m	struct:_SFSample
src_as	libstar/nflowlib.h	/^	uint16       src_as;	\/* Source AS *\/$/;"	m	struct:struct_export_v8_11
src_as	libstar/nflowlib.h	/^	uint16       src_as;	\/* Source AS *\/$/;"	m	struct:struct_export_v8_13
src_as	libstar/nflowlib.h	/^	uint16       src_as;	\/* originating AS of source address *\/$/;"	m	struct:struct_export_v8_9
src_as	libstar/sflowlib.h	/^	uint            src_as;	\/* AS number of source (origin) *\/$/;"	m	struct:_SFLExtended_gateway
src_as	libstar/sflowlib.h	/^	uint            src_as;$/;"	m	struct:_SFSample
src_charset	libstar/sflowlib.h	/^	uint            src_charset;	\/* MIBEnum value of character set used to encode a string - See RFC 2978$/;"	m	struct:_SFLExtended_user
src_ip	libstar/sflowlib.h	/^	struct in6_addr src_ip;	\/* Source IP Address *\/$/;"	m	struct:_SFLSampled_ipv6	typeref:struct:_SFLSampled_ipv6::in6_addr
src_ip	libstar/sflowlib.h	/^	struct in_addr  src_ip;	\/\/ Source IP Address $/;"	m	struct:_SFLSampled_ipv4	typeref:struct:_SFLSampled_ipv4::in_addr
src_ip	libstar/sflowlib.h	/^	uint8           src_ip[16];$/;"	m	struct:_SFLSampled_ipv6
src_mac	libstar/sflowlib.h	/^	uint8           src_mac[8];	\/\/ 6 bytes + 2 pad $/;"	m	struct:_SFLSampled_ethernet
src_mask	libstar/nflowlib.h	/^	uint8        src_mask;	\/* Source Prefix mask length *\/$/;"	m	struct:struct_export_v8_11
src_mask	libstar/nflowlib.h	/^	uint8        src_mask;	\/* Source Prefix mask length *\/$/;"	m	struct:struct_export_v8_13
src_mask	libstar/nflowlib.h	/^	uint8        src_mask;	\/* Source Prefix mask length *\/$/;"	m	struct:struct_export_v8_14
src_mask	libstar/sflowlib.h	/^	uint            src_mask;	\/* Source address prefix mask bits *\/$/;"	m	struct:_SFLExtended_router
src_peer_as	libstar/sflowlib.h	/^	uint            src_peer_as;	\/* AS number of source peer *\/$/;"	m	struct:_SFLExtended_gateway
src_peer_as	libstar/sflowlib.h	/^	uint            src_peer_as;$/;"	m	struct:_SFSample
src_port	libstar/sflowlib.h	/^	uint            src_port;	\/* TCP\/UDP source port number or equivalent *\/$/;"	m	struct:_SFLSampled_ipv6
src_port	libstar/sflowlib.h	/^	uint            src_port;	\/\/ TCP\/UDP source port number or equivalent $/;"	m	struct:_SFLSampled_ipv4
src_prefix	libstar/nflowlib.h	/^	uint32       src_prefix;	\/* Source Prefix *\/$/;"	m	struct:struct_export_v8_11
src_prefix	libstar/nflowlib.h	/^	uint32       src_prefix;	\/* Source Prefix *\/$/;"	m	struct:struct_export_v8_13
src_prefix	libstar/nflowlib.h	/^	uint32       src_prefix;	\/* Source Prefix *\/$/;"	m	struct:struct_export_v8_14
src_priority	libstar/sflowlib.h	/^	uint            src_priority;	\/* The 802.1p priority *\/$/;"	m	struct:_SFLExtended_switch
src_user	libstar/sflowlib.h	/^	SFLString       src_user;$/;"	m	struct:_SFLExtended_user
src_user	libstar/sflowlib.h	/^	char            src_user[SA_MAX_EXTENDED_USER_LEN + 1];$/;"	m	struct:_SFSample
src_user_charset	libstar/sflowlib.h	/^	uint            src_user_charset;$/;"	m	struct:_SFSample
src_user_len	libstar/sflowlib.h	/^	uint            src_user_len;$/;"	m	struct:_SFSample
src_vlan	libstar/sflowlib.h	/^	uint            src_vlan;	\/* The 802.1Q VLAN id of incomming frame *\/$/;"	m	struct:_SFLExtended_switch
srcaddr	libstar/nflowlib.h	/^	ipv4addr	srcaddr;	\/\/ source IP address (0 for dest-only flows)$/;"	m	struct:__anon59
srcaddr	libstar/nflowlib.h	/^	ipv4addr	srcaddr;	\/\/ source IP address$/;"	m	struct:__anon53
srcaddr	libstar/nflowlib.h	/^	ipv4addr	srcaddr;	\/\/ source IP address$/;"	m	struct:__anon55
srcaddr	libstar/nflowlib.h	/^	ipv4addr	srcaddr;	\/\/ source IP address$/;"	m	struct:__anon57
srcaddr	libstar/nflowlib.h	/^	uint32       srcaddr;	\/* source IP address *\/$/;"	m	struct:struct_export_v8_8
srcaddr	libstar/nflowlib.h	/^	uint32       srcaddr;	\/* source address *\/$/;"	m	struct:struct_export_v8_7
srcaddr	libstar/xflowlib.h	/^	ipv4addr	srcaddr;	\/\/ source IP address (0 for dest-only flows)$/;"	m	struct:__anon129
srcaddr	libstar/xpcap.h	/^	uint		srcaddr;		\/\/ Source IP$/;"	m	struct:__anon153
srcas	libstar/nflowlib.h	/^	uint16		srcas;		\/\/ originating AS of source address (always 0)$/;"	m	struct:__anon59
srcas	libstar/nflowlib.h	/^	uint16		srcas;		\/\/ originating AS of source address$/;"	m	struct:__anon55
srcas	libstar/nflowlib.h	/^	uint16		srcas;		\/\/ originating AS of source address$/;"	m	struct:__anon57
srcas	libstar/nflowlib.h	/^	uint16		srcas;		\/\/ source AS$/;"	m	struct:struct_export_v8_1
srcas	libstar/nflowlib.h	/^	uint16		srcas;		\/\/ source AS$/;"	m	struct:struct_export_v8_3
srcas	libstar/nflowlib.h	/^	uint16		srcas;		\/\/ source AS$/;"	m	struct:struct_export_v8_5
srcas	libstar/xflowlib.h	/^	int		srcas;$/;"	m	struct:__anon129
srccclass	libstar/xflowlib.h	/^	ipv4addr	srccclass;	\/\/ source IP address (0 for dest-only flows)$/;"	m	struct:__anon129
srcmac	libstar/xflowlib.h	/^	uchar		srcmac[8];$/;"	m	struct:__anon129
srcmac	libstar/xpcap.h	/^	uchar		*srcmac;		\/\/ Source physical address$/;"	m	struct:__anon153
srcmask	libstar/nflowlib.h	/^	uint8		srcmask;	\/\/ source address prefix mask bits (always 0)$/;"	m	struct:__anon59
srcmask	libstar/nflowlib.h	/^	uint8		srcmask;	\/\/ source address prefix mask bits$/;"	m	struct:__anon55
srcmask	libstar/nflowlib.h	/^	uint8		srcmask;	\/\/ source address prefix mask bits$/;"	m	struct:__anon57
srcmask	libstar/nflowlib.h	/^	uint8		srcmask;	\/\/ source netmask length (bits)$/;"	m	struct:struct_export_v8_5
srcmask	libstar/nflowlib.h	/^	uint8		srcmask;	\/\/ source network mask length (bits)$/;"	m	struct:struct_export_v8_3
srcmask	libstar/xflowlib.h	/^	uint32		srcmask;$/;"	m	struct:__anon129
srcname	libstar/xpcap.h	/^	char		*srcname;		\/\/ ARP에서 메모리 할당됨 (flag가 F_SUM으로 되어 있은 때만)$/;"	m	struct:__anon153
srcnet	libstar/nflowlib.h	/^	ipv4addr	srcnet;		\/\/ source network$/;"	m	struct:struct_export_v8_3
srcnet	libstar/nflowlib.h	/^	ipv4addr	srcnet;		\/\/ source network$/;"	m	struct:struct_export_v8_5
srcport	libstar/nflowlib.h	/^	uint16		srcport;	\/\/ TCP\/UDP source port number or equivalent$/;"	m	struct:__anon53
srcport	libstar/nflowlib.h	/^	uint16		srcport;	\/\/ TCP\/UDP source port number or equivalent$/;"	m	struct:__anon55
srcport	libstar/nflowlib.h	/^	uint16		srcport;	\/\/ TCP\/UDP source port number or equivalent$/;"	m	struct:__anon57
srcport	libstar/nflowlib.h	/^	uint16		srcport;	\/\/ TCP\/UDP source port number or equivalent,$/;"	m	struct:__anon59
srcport	libstar/nflowlib.h	/^	uint16		srcport;	\/\/ source port$/;"	m	struct:struct_export_v8_2
srcport	libstar/nflowlib.h	/^	uint16       srcport;	\/* Source port *\/$/;"	m	struct:struct_export_v8_14
srcport	libstar/nflowlib.h	/^	uint16       srcport;	\/* TCP\/UDP source port *\/$/;"	m	struct:struct_export_v8_8
srcport	libstar/nflowlib.h	/^	uint16       srcport;	\/* TCP\/UDP source port number of equivalent *\/$/;"	m	struct:struct_export_v8_10
srcport	libstar/xflowlib.h	/^	int		srcport;$/;"	m	struct:__anon129
srcport	libstar/xpcap.h	/^	int		srcport;		\/\/ IP source port$/;"	m	struct:__anon153
ssl	libstar/xssl.h	/^	SSL		*ssl;$/;"	m	struct:__anon167
ssl_ctx	libstar/xssl.h	/^	SSL_CTX		*ssl_ctx;$/;"	m	struct:__anon167
sslsock_accept	libstar/xssl.c	/^int	sslsock_accept(xsslsock_t *sslsock)$/;"	f
sslsock_client_close	libstar/xssl.h	34;"	d
sslsock_client_init	libstar/xssl.c	/^xsslsock_t *sslsock_client_init(char *pServerIp, int iServerPort)$/;"	f
sslsock_close_client_session	libstar/xssl.c	/^void	sslsock_close_client_session(xsslsock_t *sslsock)$/;"	f
sslsock_recv	libstar/xssl.c	/^int	sslsock_recv(xsslsock_t *sslsock, void *buf, int bufsize, int timeoutMS)$/;"	f
sslsock_send	libstar/xssl.c	/^int	sslsock_send(xsslsock_t *sslsock, void *buf, int bufsize, int timeoutMS)$/;"	f
sslsock_server_close	libstar/xssl.h	36;"	d
sslsock_server_init	libstar/xssl.c	/^xsslsock_t *sslsock_server_init(int port, char *psPasswd)$/;"	f
ssmtp_data_t	libstar/ssmtplib.h	/^}	ssmtp_data_t;$/;"	t	typeref:struct:__anon103
ssmtp_info_t	libstar/ssmtplib.h	/^}	ssmtp_info_t;$/;"	t	typeref:struct:__anon102
st	libstar/xutil.h	/^	struct stat	st;$/;"	m	struct:__anon180	typeref:struct:__anon180::stat
stack	libstar/sflowlib.h	/^	SFLVlanStack    stack;	\/* List of stripped 802.1Q TPID\/TCI layers. Each $/;"	m	struct:_SFLExtended_vlan_tunnel
stack	libstar/sflowlib.h	/^	uint           *stack;	\/* first entry is top of stack - see RFC 3032 for encoding *\/$/;"	m	struct:_SFLLabelStack
standbystatus	libstar/xnms.h	/^	char		standbystatus[10];	\/\/ .21	\/\/ Redundant status: other(1), active(2), standby(3), error(4)$/;"	m	struct:__anon148
starserial_t	libstar/lock.h	/^}	starserial_t;$/;"	t	typeref:struct:__anon44
start	libstar/xflowlib.h	/^	int		start;		\/\/ xflow_start() 해야만 동작함..$/;"	m	struct:xflow
start	libstar/xpcap.h	/^	int		start;$/;"	m	struct:__anon154
start_routine	libstar/proflib.c	/^	void           *(*start_routine) (void *);$/;"	m	struct:wrapper_s	file:
startaddr	libstar/dvdlib.h	/^	int		startaddr;		\/\/ 시작 주소..$/;"	m	struct:__anon33
startclk	libstar/xdb.h	/^	double		startclk;	\/\/ 시작시간 $/;"	m	struct:__anon119
starttime	hdaclib.h	/^	time_t	starttime;			\/\/ check start time$/;"	m	struct:__anon8
starttime	libstar/dvdlib.h	/^	time32		starttime, endtime;	\/\/ 현재 DVD에 대한 기록 시작\/끝시각$/;"	m	struct:__anon33
starttime	libstar/dvdlib.h	/^	time32		starttime;		\/\/ 레코딩 시작시간 (DVD 교체시 초기화됨)$/;"	m	struct:__anon32
starttime	libstar/thrpool.h	/^	time_t		starttime;	\/\/ 이 thread가 activation된 시각.$/;"	m	struct:thrdata
starttime	libstar/xdb.h	/^	time32		starttime;	\/\/ 시작 시간 $/;"	m	struct:__anon118
starttime	libstar/xflowlib.h	/^	time32		starttime;	\/\/ sysUptime at start of flow$/;"	m	struct:__anon129
starttime	libstar/xtime.c	/^	double	starttime;$/;"	m	struct:__anon171	file:
starttime	libstar/xtn.h	/^	time32		starttime;	\/\/ Command 수행 시작 시각 $/;"	m	struct:xtn
starttm	libstar/xtime.h	/^	xtime_t		starttm;$/;"	m	struct:__anon173
stat	libstar/xflowlib.h	/^	xflow_perfstat_t	stat;		\/\/ 라우터에서 유입되는 트래픽 요약 $/;"	m	struct:xflow
stat	myjson/json.h	/^	jsonstat_t *stat()$/;"	f	class:json
stat	myjson/json2.c	/^jsonstat json::stat()$/;"	f	class:json
state	lib/sha256.h	/^    uint32_t    state[8];$/;"	m	struct:__anon22
state	lib/sha512.h	/^    uint64_t    state[8];$/;"	m	struct:__anon24
state	libstar/snmpdef.h	/^	int		state;$/;"	m	struct:__anon85
state	libstar/snmpdef.h	/^	int	state;$/;"	m	struct:__anon87
state	libstar/xnms.h	/^	int		state;			\/\/ STATE_xxx$/;"	m	struct:xnmsnode
state	libstar/xtn.c	/^	int	state;		\/\/ = STATE_DATA;$/;"	m	struct:__anon177	file:
static_null	json11/json11.cpp	/^static const Json & static_null()$/;"	f	namespace:json11
statics	json11/json11.cpp	/^static const Statics & statics()$/;"	f	namespace:json11
statsSamplingInterval	libstar/sflowlib.h	/^	uint            statsSamplingInterval;$/;"	m	struct:_SFSample
stattype	libstar/snmpdef.h	/^	char		stattype[8];		\/\/ AVG MAX...$/;"	m	struct:__anon96
stattype	libstar/snmpdef.h	/^	char	stattype[8];$/;"	m	struct:__anon78
status	libstar/http.c	/^	char	status[50];	\/\/ 200 OK \/ 302 Moved temporarily $/;"	m	struct:__anon43	file:
std	contract.c	/^using namespace std;$/;"	v
std	ctadmin.c	/^using namespace std;$/;"	v
std	ctexec.c	/^using namespace std;$/;"	v
std	ctsend.c	/^using namespace std;$/;"	v
std	hvm.c	/^using namespace std;$/;"	v
std	myjson/json2.c	/^using namespace std;$/;"	v
std	myjson/test.c	/^using namespace std;$/;"	v
std	myjson/test2.c	/^using namespace std;$/;"	v
std	test.c	/^using namespace std;$/;"	v
stmt	libstar/ocilib.h	/^	OCIStmt		*stmt;		\/* statement handle *\/$/;"	m	struct:ocistmt
stmtid	libstar/ocilib.h	/^	int		stmtid;		\/* statement id for cursors *\/$/;"	m	struct:__anon61
stmtp	libstar/ocilib.h	/^	ocistmt_t	*stmtp;		\/* statement handle. used when fetching REFCURSORS *\/$/;"	m	struct:__anon61
stmtp	libstar/ocilib.h	/^	struct ocistmt	*stmtp;$/;"	m	struct:ociconn	typeref:struct:ociconn::ocistmt
stmttype	libstar/ocilib.h	/^	ub2		stmttype;	\/* statement type *\/$/;"	m	struct:ocistmt
stop	libstar/gw.h	/^	uint	stop;			\/\/ gateway stop용$/;"	m	struct:gwinfo
stopclient	libstar/gw.h	/^	uint	stopclient;		\/\/ client stop용 $/;"	m	struct:gwinfo
stopdaemon	libstar/xnms.h	/^	int		stopdaemon;			\/\/ TRUE면 모든 thread 정지...$/;"	m	struct:__anon149
stopserver	libstar/gw.h	/^	uint	stopserver;		\/\/ server stop용 $/;"	m	struct:gwinfo
storage_size4	libstar/ocilib.h	/^	ub4		storage_size4;	\/* size used when allocating buffers *\/$/;"	m	struct:__anon61
str	json11/json11.cpp	/^    const string &str;$/;"	m	struct:json11::__anon15::final	file:
str	libstar/sflowlib.h	/^	char           *str;$/;"	m	struct:_SFLString
str2addr	libstar/xstr.c	/^uint	str2addr(const char *ipaddr)$/;"	f
str2gmttime	libstar/xtime.c	/^time32	str2gmttime(char *str, int *ms, int *isgmt)$/;"	f
str2mac	libstar/xstr.c	/^uchar	*str2mac(char *macstr, uchar *mac)$/;"	f
strategy	json11/json11.cpp	/^    const JsonParse strategy;$/;"	m	struct:json11::__anon15::final	file:
stream	contract.h	/^	char	stream[32];			\/\/ stream for contract permission handling$/;"	m	struct:__anon1
string_value	json11/json11.cpp	/^const string &            JsonValue::string_value()              const { return statics().empty_string; }$/;"	f	class:json11::JsonValue
string_value	json11/json11.cpp	/^const string & Json::string_value()               const { return m_ptr->string_value(); }$/;"	f	class:json11::Json
strip_quote	hdaclib.c	/^char	*strip_quote(char *data)$/;"	f
strip_quote	myjson/json2.c	/^string json::strip_quote(const string token)$/;"	f	class:json
stripped	libstar/sflowlib.h	/^	uint            stripped;	\/\/ header\/trailer bytes stripped by sender $/;"	m	struct:_SFLSampled_header
stripped	libstar/sflowlib.h	/^	uint            stripped;$/;"	m	struct:_SFSample
stristr	libstar/xstr.c	/^char	*stristr(char *base, char *cmp)$/;"	f
strp	libstar/re.h	/^	char		*strp;		\/\/ 원본 문자열에 대한 포인터..$/;"	m	struct:__anon66
strtolower	libstar/xstr.c	/^char	*strtolower(char *buf)$/;"	f
strtoupper	libstar/xstr.c	/^char	*strtoupper(char *buf)$/;"	f
struct_export_v8_1	libstar/nflowlib.h	/^typedef struct struct_export_v8_1 {$/;"	s
struct_export_v8_10	libstar/nflowlib.h	/^struct struct_export_v8_10$/;"	s
struct_export_v8_11	libstar/nflowlib.h	/^struct struct_export_v8_11$/;"	s
struct_export_v8_12	libstar/nflowlib.h	/^struct struct_export_v8_12$/;"	s
struct_export_v8_13	libstar/nflowlib.h	/^struct struct_export_v8_13$/;"	s
struct_export_v8_14	libstar/nflowlib.h	/^struct struct_export_v8_14$/;"	s
struct_export_v8_2	libstar/nflowlib.h	/^typedef struct struct_export_v8_2 {$/;"	s
struct_export_v8_3	libstar/nflowlib.h	/^typedef struct struct_export_v8_3 {$/;"	s
struct_export_v8_4	libstar/nflowlib.h	/^typedef struct struct_export_v8_4 {$/;"	s
struct_export_v8_5	libstar/nflowlib.h	/^typedef struct struct_export_v8_5 {$/;"	s
struct_export_v8_6	libstar/nflowlib.h	/^struct struct_export_v8_6$/;"	s
struct_export_v8_7	libstar/nflowlib.h	/^struct struct_export_v8_7$/;"	s
struct_export_v8_8	libstar/nflowlib.h	/^struct struct_export_v8_8$/;"	s
struct_export_v8_9	libstar/nflowlib.h	/^struct struct_export_v8_9$/;"	s
sub_agent_id	libstar/sflowlib.h	/^	uint            sub_agent_id;	\/* Used to distinguishing between datagram$/;"	m	struct:_SFLSample_datagram_hdr
subject	libstar/ssmtplib.h	/^	char		subject[256];$/;"	m	struct:__anon103
subnetmask	libstar/xsock.h	/^	char		subnetmask[20];$/;"	m	struct:__anon166
subscribe	rpc.h	/^	string subscribe(const char *entity_ids, const bool rescan = true)$/;"	f	class:hdac
subtype	libstar/ssmtplib.h	/^	int		subtype;$/;"	m	struct:__anon102
subtype2name	libstar/xnms.h	/^	char		subtype2name[32];	\/\/ .24	$/;"	m	struct:__anon148
subtypename	libstar/xnms.h	/^	char		subtypename[32];	\/\/ .16	\/\/ Module subType other(1), empty(2), wsf5510(3), wsf5511(4), wsx5304(6), wsf5520(7), $/;"	m	struct:__anon148
surge_count	libstar/snmpdef.h	/^	uint		surge_count;		\/\/ The number requests in the surge queue. Counter32(65 - cntr32)$/;"	m	struct:__anon96
svc	libstar/ocilib.h	/^	OCISvcCtx	*svc;		\/* private service context handle *\/$/;"	m	struct:ociconn
svcport	libstar/snmpdef.h	/^	int		svcport;		\/\/ The port at which the service is running.$/;"	m	struct:__anon96
svctype	libstar/snmpdef.h	/^	char		svctype[20];		\/\/ The protocol type of the service.$/;"	m	struct:__anon96
svrindex	libstar/snmpdef.h	/^	int		svrindex;		\/\/ Real server index$/;"	m	struct:__anon96
svrip	libstar/snmpdef.h	/^	char		svrip[20];		\/\/ Server IP$/;"	m	struct:__anon96
svrmac	libstar/snmpdef.h	/^	char		svrmac[20];$/;"	m	struct:__anon96
svrname	libstar/snmpdef.h	/^	char		svrname[40];$/;"	m	struct:__anon96
svrstate	libstar/snmpdef.h	/^	char		svrstate[20];		\/\/ 서버 상태 $/;"	m	struct:__anon96
svrtype	libstar/xapp.h	/^	char		svrtype[100];	\/\/ FTP server type (SYST result)$/;"	m	struct:__anon113
sw	libstar/sflowlib.h	/^	SFLExtended_switch sw;$/;"	m	union:_SFLFlow_type
swapbyte	libstar/xsock.h	/^	int		swapbyte;	\/\/ 1이면 오더 바뀐 경우..$/;"	m	struct:xsocket
switch_port	libstar/snmpdef.h	/^	int		switch_port;		\/\/ 서버가 연결된 스위치 포트 $/;"	m	struct:__anon96
swver	libstar/xnms.h	/^	char		swver[40];		\/\/ .20	\/\/ Software version$/;"	m	struct:__anon148
synflood_rate	libstar/snmpdef.h	/^	float		synflood_rate;		\/\/ OCTET STRING$/;"	m	struct:__anon96
syns_recv	libstar/snmpdef.h	/^	float		syns_recv;		\/\/ $/;"	m	struct:__anon96
syns_recv_sum	libstar/snmpdef.h	/^	uint64		syns_recv_sum;		\/\/ Counter64(70 - cntr64)$/;"	m	struct:__anon96
sysUpTime	libstar/sflowlib.h	/^	uint            sysUpTime;	\/* XXX: suffers cleanup *\/$/;"	m	struct:_SFSample
sysUptime	libstar/nflowlib.h	/^	uint32		sysUptime;	\/\/ current time in msecs since router booted$/;"	m	struct:__anon56
sysUptime	libstar/nflowlib.h	/^	uint32		sysUptime;	\/\/ current time in msecs since router booted$/;"	m	struct:__anon60
sysUptime	libstar/nflowlib.h	/^	uint32		sysUptime;$/;"	m	struct:__anon52
sysUptime	libstar/nflowlib.h	/^	uint32		sysUptime;$/;"	m	struct:__anon54
sysUptime	libstar/nflowlib.h	/^	uint32		sysUptime;$/;"	m	struct:__anon58
sysdescr	libstar/snmpdef.h	/^	char	sysdescr[256];$/;"	m	struct:__anon76
syslog_apply_bomb_filter	libstar/syslog.c	/^int	syslog_apply_bomb_filter(char *data, char *outbuf, int outbuflen)$/;"	f
syslog_callback_t	libstar/xnms.h	/^typedef void (syslog_callback_t) (char *nodeip, int facility, int priority, time32 tm, char *message, int evlevel);$/;"	t
syslog_facility	libstar/syslog.c	/^const char	*syslog_facility[] = {$/;"	v
syslog_filter_add	libstar/syslog.c	/^int	syslog_filter_add(char *filter, int include, int evlevel)$/;"	f
syslog_filter_check	libstar/syslog.c	/^int	syslog_filter_check(char *data, int *evlevel)$/;"	f
syslog_filter_clear	libstar/syslog.c	/^void	syslog_filter_clear()$/;"	f
syslog_filter_count	libstar/syslog.c	/^int	syslog_filter_count(char *type)$/;"	f
syslog_init	libstar/syslog.c	/^void	syslog_init(syslog_callback_t *func, int syslog_port)$/;"	f
syslog_priority	libstar/syslog.c	/^const char	*syslog_priority[] = {$/;"	v
t	json11/json11.cpp	/^    const std::shared_ptr<JsonValue> t = make_shared<JsonBoolean>(true);$/;"	m	struct:json11::Statics	file:
t1printf	libstar/xdebug.h	105;"	d
t2printf	libstar/xdebug.h	104;"	d
t3printf	libstar/xdebug.h	103;"	d
t4printf	libstar/xdebug.h	102;"	d
t5printf	libstar/xdebug.h	101;"	d
tab2spc	libstar/xstr.c	/^char	*tab2spc(const char *buf, char *newbuf)$/;"	f
table	libstar/hash.h	/^	struct hashentry **table;$/;"	m	struct:__anon41	typeref:struct:__anon41::hashentry
table	libstar/shash.h	/^	uchar		*table;			\/\/ 데이터 저장 위치 $/;"	m	struct:__anon71
table	libstar/vhash.h	/^	struct vhashentry **table[MAX_VHASH_TABLE];	\/\/ 최대 100개 테이블이 생성되게...$/;"	m	struct:__anon105	typeref:struct:__anon105::vhashentry
tablesize	libstar/fhash.h	/^	int		tablesize;		\/\/ 엔트리 개수$/;"	m	struct:__anon35
tablesize	libstar/hash.h	/^	int   		tablesize;	\/\/ number of buckets $/;"	m	struct:__anon41
tablesize	libstar/shash.h	/^	int		tablesize;		\/\/ 엔트리 개수$/;"	m	struct:__anon71
tablesize	libstar/vhash.h	/^	int   		tablesize;		\/\/ number of buckets $/;"	m	struct:__anon105
tag	libstar/sflowlib.h	/^	uint            tag;	\/* SFLCounters_type_tag *\/$/;"	m	struct:_SFLCounters_sample_element
tag	libstar/sflowlib.h	/^	uint            tag;	\/* SFLFlow_type_tag *\/$/;"	m	struct:_SFLFlow_sample_element
tail	libstar/xlist.h	/^	xlistnode_t	*tail;		\/\/ 마지막 노드 포인터 (add시 마지막에 추가됨)$/;"	m	struct:xlist
tcp	libstar/xpcap.h	/^	struct tcphdr	*tcp;			\/\/ TCP protocol$/;"	m	struct:__anon153	typeref:struct:__anon153::tcphdr
tcp_flags	libstar/nflowlib.h	/^	uint8		tcp_flags;	\/\/ Cumulative OR of tcp flags$/;"	m	struct:__anon53
tcp_flags	libstar/nflowlib.h	/^	uint8		tcp_flags;	\/\/ bitwise OR of all TCP flags in flow (always 0)$/;"	m	struct:__anon59
tcp_flags	libstar/nflowlib.h	/^	uint8		tcp_flags;	\/\/ bitwise OR of all TCP flags in flow; 0x10$/;"	m	struct:__anon55
tcp_flags	libstar/nflowlib.h	/^	uint8		tcp_flags;	\/\/ bitwise OR of all TCP flags seen in flow$/;"	m	struct:__anon57
tcp_flags	libstar/sflowlib.h	/^	uint            tcp_flags;	\/* TCP flags *\/$/;"	m	struct:_SFLSampled_ipv6
tcp_flags	libstar/sflowlib.h	/^	uint            tcp_flags;	\/\/ TCP flags $/;"	m	struct:_SFLSampled_ipv4
tcp_flags	libstar/xflowlib.h	/^	uint32		tcp_flags;$/;"	m	struct:__anon129
tcpestab	libstar/snmpdef.h	/^	int	tcpestab;		\/\/ TCP 연결 수 $/;"	m	struct:__anon76
tcpflag	libstar/xpcap.h	/^	uint		tcpflag;$/;"	m	struct:__anon153
tcphdrlen	libstar/xpcap.h	/^	int		tcphdrlen;		\/\/ TCP 헤더 크기 $/;"	m	struct:__anon153
tcplen	libstar/xpcap.h	/^	int		tcplen;			\/\/ 헤더를 제외한 TCP 블록의 크기 $/;"	m	struct:__anon153
tcpstat	libstar/snmpdef.h	/^	int	tcpstat[TCPSTAT_MAX];	\/\/ 각 상태의 수$/;"	m	struct:__anon92
tcpstat	libstar/snmpdef.h	/^	int	tcpstat[TCPSTAT_MAX];$/;"	m	struct:__anon91
tempalarm	libstar/xnms.h	/^	char		tempalarm[10];		\/\/ .13$/;"	m	struct:__anon147
template_cache	libstar/nflowlib.h	/^struct template_cache$/;"	s
template_cache_entry	libstar/nflowlib.h	/^struct template_cache_entry$/;"	s
template_field_v9	libstar/nflowlib.h	/^struct template_field_v9$/;"	s
template_hdr_v9	libstar/nflowlib.h	/^struct template_hdr_v9$/;"	s
template_id	libstar/nflowlib.h	/^	uint16       template_id;	\/* template ID *\/$/;"	m	struct:template_cache_entry
template_id	libstar/nflowlib.h	/^	uint16       template_id;$/;"	m	struct:template_hdr_v9
term_index	libstar/xtn.c	/^int term_index = 1;$/;"	v
terminal	libstar/xtn.c	/^} terminal[NUM_TERMINALS] = {$/;"	v	typeref:struct:terminal_st
terminal_st	libstar/xtn.c	/^struct terminal_st$/;"	s	file:
termproc	libstar/xtn.c	/^	LPDATAPROC termproc;$/;"	m	struct:terminal_st	file:
test1	libstar/xhash.c	/^test1()$/;"	f
test_api	test.c	/^void	test_api(hdac_t *hdac)$/;"	f
test_auth	test.c	/^void	test_auth(hdac_t *hdac)$/;"	f
test_auth2	test.c	/^void	test_auth2(hdac_t *hdac)$/;"	f
test_basic_rpc	test.c	/^void	test_basic_rpc(hdac_t *hdac)$/;"	f
test_cert_doc	test.c	/^void	test_cert_doc(hdac_t *hdac)$/;"	f
test_dns	test.c	/^void	test_dns(hdac_t *hdac)$/;"	f
test_multisig	test.c	/^void	test_multisig(hdac_t *hdac)$/;"	f
test_rpc	test.c	/^void	test_rpc(hdac_t *hdac)$/;"	f
test_rpc_block_tx	test.c	/^void	test_rpc_block_tx(hdac_t *hdac)$/;"	f
test_rpc_blockchain	test.c	/^void	test_rpc_blockchain(hdac_t *hdac)$/;"	f
test_rpc_control	test.c	/^void	test_rpc_control(hdac_t *hdac)$/;"	f
test_rpc_generating	test.c	/^void	test_rpc_generating(hdac_t *hdac)$/;"	f
test_rpc_grant	test.c	/^void	test_rpc_grant(hdac_t *hdac)$/;"	f
test_rpc_mining	test.c	/^void	test_rpc_mining(hdac_t *hdac)$/;"	f
test_rpc_network	test.c	/^void	test_rpc_network(hdac_t *hdac)$/;"	f
test_rpc_raw_xch	test.c	/^void	test_rpc_raw_xch(hdac_t *hdac)$/;"	f
test_rpc_stream	test.c	/^void	test_rpc_stream(hdac_t *hdac)$/;"	f
test_rpc_util	test.c	/^void	test_rpc_util(hdac_t *hdac)$/;"	f
test_rpc_wallet	test.c	/^void	test_rpc_wallet(hdac_t *hdac)$/;"	f
test_rpc_wallet_send	test.c	/^void	test_rpc_wallet_send(hdac_t *hdac)$/;"	f
thrdata	libstar/thrpool.h	/^	thrdata_t	*thrdata;$/;"	m	struct:thrpool
thrdata	libstar/thrpool.h	/^typedef struct thrdata {$/;"	s
thrdata_t	libstar/thrpool.h	/^}	thrdata_t;$/;"	t	typeref:struct:thrdata
thread	libstar/gw.h	/^	VTHREAD	(*thread) (void *arg);	\/\/ Client 접속 처리용 thread$/;"	m	struct:gwrule
thread_alarm	libstar/xtime.c	/^static	VTHREAD	thread_alarm(void *arg)$/;"	f	file:
thread_auto_client_accept	libstar/gwauto.c	/^static	VTHREAD	thread_auto_client_accept(void *arg)$/;"	f	file:
thread_client	libstar/gwcli.c	/^static	VTHREAD	thread_client(void *arg)$/;"	f	file:
thread_client_accept	libstar/gwsvr.c	/^static	VTHREAD	thread_client_accept(void *arg)$/;"	f	file:
thread_client_monitor	libstar/gwauto.c	/^static	VTHREAD	thread_client_monitor(void *arg)$/;"	f	file:
thread_dvd_record	libstar/dvdlib.c	/^VTHREAD thread_dvd_record(void *arg)$/;"	f
thread_odd_record	libstar/oddlibwin.c	/^VTHREAD thread_odd_record(void *arg)$/;"	f
thread_poolfunc	libstar/thrpool.c	/^VTHREAD	thread_poolfunc(void *arg)$/;"	f
thread_socket_open_check	libstar/xsock.c	/^VTHREAD	thread_socket_open_check(void *arg)$/;"	f
thread_syslog	libstar/syslog.c	/^static	VTHREAD	thread_syslog(void *arg)$/;"	f	file:
thread_trap	libstar/xsnmptrap.c	/^static VTHREAD thread_trap(void *funcarg)$/;"	f	file:
thread_xflow_collector	libstar/xflowlib.c	/^static	VTHREAD	thread_xflow_collector(void *arg)$/;"	f	file:
thread_xflow_compute	libstar/xflowlib.c	/^static	VTHREAD	thread_xflow_compute(void *arg)$/;"	f	file:
thread_xnms_cfg_scan	libstar/xnms.c	/^static	VTHREAD	thread_xnms_cfg_scan(void *arg)$/;"	f	file:
thread_xnms_ping	libstar/xnms.c	/^static	VTHREAD	thread_xnms_ping(void *arg)$/;"	f	file:
thread_xnms_port_check	libstar/xnms.c	/^static	VTHREAD	thread_xnms_port_check(void *arg)$/;"	f	file:
thread_xnms_snmp	libstar/xnms.c	/^static	VTHREAD	thread_xnms_snmp(void *arg)$/;"	f	file:
thread_xtimer	libstar/xtime.c	/^static	VTHREAD	thread_xtimer(void *arg)$/;"	f	file:
thread_xtn_receiver	libstar/xtn.c	/^VTHREAD	thread_xtn_receiver(void *arg)$/;"	f
thrid	libstar/xflowlib.h	/^	pthread_t	thrid;		\/\/ thread의 ID$/;"	m	struct:xflow
thrid	libstar/xnms.h	/^	int		thrid;			\/\/ Thread ID$/;"	m	struct:xnmsnode
thrid	libstar/xnms.h	/^	int		thrid;$/;"	m	struct:__anon149
thron	libstar/xicmp.h	/^	int		thron;			\/\/ 1이면 PING packet send thread가 enable 된 상태임$/;"	m	struct:__anon136
thrpool	libstar/thrpool.h	/^	struct thrpool	*thrpool;$/;"	m	struct:thrdata	typeref:struct:thrdata::thrpool
thrpool	libstar/thrpool.h	/^typedef struct thrpool {$/;"	s
thrpool_callback_t	libstar/thrpool.h	/^typedef void (*thrpool_callback_t) (struct thrdata *thrdata, void *userdata);$/;"	t
thrpool_free	libstar/thrpool.c	/^void	thrpool_free(thrpool_t *thrp)$/;"	f
thrpool_gettimeout	libstar/thrpool.c	/^int	thrpool_gettimeout(thrpool_t *thrp)$/;"	f
thrpool_init	libstar/thrpool.c	/^thrpool_t	*thrpool_init(int nthread)$/;"	f
thrpool_run	libstar/thrpool.c	/^int	thrpool_run(thrpool_t *thrp, thrpool_callback_t cbf, void *userdata)$/;"	f
thrpool_settimeout	libstar/thrpool.c	/^void	thrpool_settimeout(thrpool_t *thrp, int timeoutMS)$/;"	f
thrpool_t	libstar/thrpool.h	/^}	thrpool_t;$/;"	t	typeref:struct:thrpool
thrpool_wait	libstar/thrpool.c	/^void	thrpool_wait(thrpool_t *thrp)$/;"	f
thrstat	libstar/xnms.h	/^	int		thrstat[MAX_SNMP_THREAD + MAX_SNMP_SLOW_THREAD];$/;"	m	struct:__anon149
ti_timeouts	libstar/netbios.c	/^	ushort		ti_timeouts;$/;"	m	struct:__anon49	file:
tid	hvm.c	/^	pthread_t tid;$/;"	m	struct:__anon11	file:
tid	libstar/thrpool.h	/^	pthread_t	tid;$/;"	m	struct:thrdata
tid	libstar/xtime.c	/^	pthread_t	tid;$/;"	m	struct:__anon170	file:
tid	libstar/xtn.h	/^	pthread_t	tid;		\/\/ 수신 전용 thread id$/;"	m	struct:xtn
time	libstar/snmpdef.h	/^	time32		time;$/;"	m	struct:__anon77
time	libstar/snmpdef.h	/^	time32	time;			\/\/ 데이터 수집 시간 $/;"	m	struct:__anon78
time	libstar/snmpdef.h	/^	time32	time;			\/\/ 정보 수집 시각$/;"	m	struct:__anon76
time	libstar/xdebug.c	/^	time32	time;			\/\/ 최종 할당 시간 $/;"	m	struct:__anon121	file:
time	libstar/xdebug.h	/^	time_t	time;$/;"	m	struct:__anon124
time	libstar/xflowlib.h	/^	time32		time;		\/\/ 받은 시각$/;"	m	struct:__anon129
time	libstar/xlock.h	/^	uint		time;		\/\/ lock time $/;"	m	struct:__anon141
time	libstar/xnms.h	/^	time32		time;$/;"	m	struct:__anon147
time	libstar/xnms.h	/^	time32		time;$/;"	m	struct:__anon148
time	libstar/xnms.h	/^	time32		time;$/;"	m	struct:__anon150
time	libstar/xpcap.h	/^	time32		time;			\/\/ 패킷 캡쳐 후 지난시간 측정용 $/;"	m	struct:__anon153
time	libstar/xsnmp.h	/^	time32	time;$/;"	m	struct:__anon161
time	node.h	/^	time_t	time;$/;"	m	struct:__anon14
time32	libstar/type.h	/^typedef int		time32;$/;"	t
timeoutMS	libstar/thrpool.h	/^	int		timeoutMS;$/;"	m	struct:thrpool
timeoutMS	libstar/xlock.h	/^	int		timeoutMS;	\/\/ Timeout(ms) $/;"	m	struct:__anon141
timeoutMS	libstar/xping.h	/^	int		timeoutMS;		\/\/ Timeout (초)$/;"	m	struct:xping
timeoutMS	libstar/xsnmp.h	/^	int		timeoutMS;		\/\/ xsnmp_open() 전에 xsnmp_settimeout()을 사용하는 경우를 대비해서...$/;"	m	struct:__anon158
timeoutMS	libstar/xsock.h	/^	int		timeoutMS;$/;"	m	struct:xsocket
timeout_ms	libstar/xtn.h	/^	int		timeout_ms;	\/\/ Timeout $/;"	m	struct:xtn
tl_timeouts	libstar/netbios.c	/^	ushort		tl_timeouts;$/;"	m	struct:__anon49	file:
tlock	libstar/xlock.h	81;"	d
tlock_t	libstar/xlock.h	/^}	tlock_t;$/;"	t	typeref:struct:__anon141
tlockfree	libstar/xlock.c	/^void	tlockfree(tlock_t *lock)$/;"	f
tlockinit	libstar/xlock.c	/^void	tlockinit(tlock_t *lock)$/;"	f
tlocksettimeout	libstar/xlock.c	/^void	tlocksettimeout(tlock_t *lock, int timeoutMS)$/;"	f
to	libstar/re.h	/^	int		from, to;$/;"	m	struct:__anon66
to	libstar/ssmtplib.h	/^	char		*to[256];$/;"	m	struct:__anon103
to_value	myjson/json.h	/^	string to_value(json_t *values, char *outbuf, int outbuflen)$/;"	f	class:json
toaddr	hdaclib.h	/^	char	toaddr[HDAC_ADDR_LEN];		\/\/ to address$/;"	m	struct:__anon8
toaddr	hdaclib.h	/^	char	toaddr[HDAC_ADDR_LEN];$/;"	m	struct:__anon3
token	contract.h	/^	char	token[128];			\/\/ Token for this contract$/;"	m	struct:__anon1
tokeninfo	json2.h	/^	tokeninfo()$/;"	f	class:tokeninfo
tokeninfo	json2.h	/^class tokeninfo {$/;"	c
tokeninfo	myjson/json2.h	/^	tokeninfo()$/;"	f	class:tokeninfo
tokeninfo	myjson/json2.h	/^class tokeninfo {$/;"	c
tokenizer	myjson/json2.c	/^int	json::tokenizer(const string jsonstr)$/;"	f	class:json
tokenname	myjson/json.h	/^	char	*tokenname;$/;"	m	struct:jsonnode
tokenring	libstar/sflowlib.h	/^	SFLTokenring_counters tokenring;$/;"	m	union:_SFLCounters_type
toliteral	libstar/ocilib.c	892;"	d	file:
toliteral	libstar/ocilib.h	24;"	d
toliteral	libstar/xicmp.c	39;"	d	file:
tos	libstar/nflowlib.h	/^	uint8		tos;		\/\/ IP Type-of-Service$/;"	m	struct:__anon53
tos	libstar/nflowlib.h	/^	uint8		tos;		\/\/ IP Type-of-Service$/;"	m	struct:__anon55
tos	libstar/nflowlib.h	/^	uint8		tos;		\/\/ IP Type-of-Service$/;"	m	struct:__anon57
tos	libstar/nflowlib.h	/^	uint8		tos;		\/\/ IP Type-of-Service$/;"	m	struct:__anon59
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_10
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_11
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_12
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_13
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_14
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_6
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_7
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_8
tos	libstar/nflowlib.h	/^	uint8        tos;	\/* tos *\/$/;"	m	struct:struct_export_v8_9
tos	libstar/sflowlib.h	/^	uint            tos;	\/\/ IP type of service $/;"	m	struct:_SFLSampled_ipv4
tos	libstar/sflowlib.h	/^    uint8_t tos;$/;"	m	struct:iphdr
tos	libstar/xflowlib.h	/^	int		tos;$/;"	m	struct:__anon129
tostr	myjson/json2.c	/^char *json::tostr(char *buf, size_t bufsz, const bool isstrip)$/;"	f	class:json
tostr	myjson/json2.c	/^string json::tostr(const bool isstrip)$/;"	f	class:json
tosvr	libstar/xpcap.h	/^	int		tosvr;			\/\/ 서버로 가는 거면 1$/;"	m	struct:__anon153
tot_len	libstar/sflowlib.h	/^    uint16_t tot_len;$/;"	m	struct:iphdr
total_conn64	libstar/snmpdef.h	/^	uint64		total_conn64;		\/\/ 총 세션 누적 $/;"	m	struct:__anon96
total_encap_levels	libstar/xpcap.h	/^	int		total_encap_levels;	\/\/$/;"	m	struct:__anon153
total_memory	libstar/sflowlib.h	/^	uint64          total_memory;	\/* total memory (in bytes) *\/$/;"	m	struct:_SFLProcessor_counters
total_rec_count	libstar/dvdlib.h	/^	ulonglong_t		total_rec_count;$/;"	m	struct:__anon33
totalbytes	libstar/xflowlib.h	/^	uint		totalbytes;$/;"	m	struct:__anon130
totalentry	libstar/xflowlib.h	/^	uint		totalentry;$/;"	m	struct:__anon130
totalflows	libstar/xflowlib.h	/^	uint		totalflows;$/;"	m	struct:__anon130
totalkb	libstar/dvdlib.h	/^	uint		rec_count, freekb, totalkb;	\/\/ 현재 DVD에 대한 기록 카운트, 여유용량, 전체용량$/;"	m	struct:__anon33
totalpkts	libstar/xflowlib.h	/^	uint		totalpkts;$/;"	m	struct:__anon130
totalsize	libstar/worm.h	/^	longlong_t	totalsize;		\/\/ 전체 용량 (bytes)$/;"	m	struct:__anon109
tpl	libstar/nflowlib.h	/^	struct otpl_field tpl[NF9_MAX_DEFINED_FIELD];$/;"	m	struct:template_cache_entry	typeref:struct:template_cache_entry::otpl_field
tprint_info_t	libstar/xdebug.h	/^}	tprint_info_t;$/;"	t	typeref:struct:__anon122
tprintf	libstar/xdebug.h	153;"	d
trace	libstar/xicmp.h	/^	int		trace;			\/\/ traceroute처럼 중간 라우터를 확인할 경우에서 사용.$/;"	m	struct:__anon136
traceaddr	libstar/xicmp.h	/^	uint		traceaddr;		\/\/ 추적할 주소 (라우터 추적시 중간에 매번 addr이 바뀌므로..)$/;"	m	struct:__anon136
transaction_id	libstar/netbios.c	/^	ushort		transaction_id;$/;"	m	struct:__anon47	file:
transaction_id	libstar/netbios.c	/^	ushort		transaction_id;$/;"	m	struct:__anon48	file:
transmit_aborts	libstar/netbios.c	/^	ushort		transmit_aborts;$/;"	m	struct:__anon49	file:
transmitted	libstar/netbios.c	/^	uint		transmitted;$/;"	m	struct:__anon49	file:
trap_apply_bomb_filter	libstar/syslog.c	/^int	trap_apply_bomb_filter(char *data, char *outbuf, int outbuflen)$/;"	f
trap_callback_t	libstar/xnms.h	/^typedef void (trap_callback_t) (char *nodeip, char *via_ip, int via_port, $/;"	t
trap_filter_add	libstar/syslog.c	/^int	trap_filter_add(char *filter, int include, int evlevel)$/;"	f
trap_filter_check	libstar/syslog.c	/^int	trap_filter_check(char *data, int *evlevel)$/;"	f
trap_filter_clear	libstar/syslog.c	/^void	trap_filter_clear()$/;"	f
trap_filter_count	libstar/syslog.c	/^int	trap_filter_count(char *type)$/;"	f
trap_init	libstar/xsnmptrap.c	/^void trap_init(trap_callback_t * func, int trap_port)$/;"	f
trap_syslog_filter_t	libstar/xnms.h	/^}	trap_syslog_filter_t;$/;"	t	typeref:struct:__anon151
treallock	libstar/xlock.c	/^void	treallock(const char *file, const int lineno, char *name, tlock_t *lock)$/;"	f
trealunlock	libstar/xlock.c	/^void	trealunlock(const char *file, const int lineno, const char *name, tlock_t *lock)$/;"	f
ttl	libstar/netbios.c	/^	uint		ttl;$/;"	m	struct:__anon48	file:
ttl	libstar/sflowlib.h	/^    uint8_t ttl;$/;"	m	struct:iphdr
ttl	libstar/xicmp.h	/^	int		ttl;			\/\/ TTL (default=30)$/;"	m	struct:__anon136
ttyclose	libstar/xstr.c	/^void	ttyclose()$/;"	f
ttygetc	libstar/xstr.c	/^int	ttygetc(int timeoutMS)$/;"	f
ttygetline	libstar/xstr.c	/^char	*ttygetline(char *buf, int buflen)$/;"	f
ttyopen	libstar/xstr.c	/^int	ttyopen()$/;"	f
tunlock	libstar/xlock.h	82;"	d
tunnel_cos	libstar/sflowlib.h	/^	uint            tunnel_cos;	\/* Tunnel COS value *\/$/;"	m	struct:_SFLExtended_mpls_tunnel
tunnel_id	libstar/sflowlib.h	/^	uint            tunnel_id;	\/* Tunnel ID *\/$/;"	m	struct:_SFLExtended_mpls_tunnel
tunnel_lsp_name	libstar/sflowlib.h	/^	SFLString       tunnel_lsp_name;	\/* Tunnel name *\/$/;"	m	struct:_SFLExtended_mpls_tunnel
tv	libstar/xlock.h	/^	struct timeval	tv;$/;"	m	struct:__anon141	typeref:struct:__anon141::timeval
tv	libstar/xpcap.h	/^	struct timeval	tv;			\/\/ 패킷 캡쳐 시간 $/;"	m	struct:__anon153	typeref:struct:__anon153::timeval
tv_sec	libstar/xtime.h	/^	time32	tv_sec;$/;"	m	struct:__anon172
tv_usec	libstar/xtime.h	/^	time32	tv_usec;$/;"	m	struct:__anon172
txbytes_rate	libstar/snmpdef.h	/^	float		txbytes_rate;		\/\/ OCTET STRING$/;"	m	struct:__anon96
txdata	hdaclib.h	/^	hdac_auth_txdata_t	txdata;$/;"	m	struct:__anon9
txid	hdaclib.h	/^	char	txid[256];	\/\/ transaction id of command result$/;"	m	struct:__anon9
txid	hdaclib.h	/^	char	txid[HDAC_TX_LEN];	\/\/ txid of document tx$/;"	m	struct:__anon7
txid	hdaclib.h	/^	char	txid[HDAC_TX_LEN];$/;"	m	struct:__anon6
txid	node.h	/^	char	txid[HDAC_TX_LEN];$/;"	m	struct:__anon14
type	json11/json11.cpp	/^Json::Type Json::type()                           const { return m_ptr->type();         }$/;"	f	class:json11::Json
type	json11/json11.hpp	/^            int>::type = 0>$/;"	m	class:json11::final
type	json2.h	/^	jsontype type;$/;"	m	class:jsonnode
type	libstar/http.c	/^	char	type[40];	\/\/ text\/html $/;"	m	struct:__anon43	file:
type	libstar/loglib.h	/^	char		type[40];	\/\/ 파일 타입 $/;"	m	struct:__anon45
type	libstar/nflowlib.h	/^	uint16       type;$/;"	m	struct:template_field_v9
type	libstar/ocilib.h	/^	ub4		type;		\/* descriptor type *\/ $/;"	m	struct:__anon62
type	libstar/sflowlib.h	/^	uint            type;	\/* enum SFLExtended_as_path_segment_type *\/$/;"	m	struct:_SFLExtended_as_path_segment
type	libstar/sflowlib.h	/^	uint            type;	\/\/ enum SFLAddress_type $/;"	m	struct:_SFLAddress
type	libstar/sflowlib.h	/^  uint8_t type;		\/* message type *\/$/;"	m	struct:icmphdr
type	libstar/snmpdef.h	/^	char	type[20];		\/\/ "ipv4"$/;"	m	struct:__anon92
type	libstar/snmpdef.h	/^	char	type[32];		\/\/ "SERVER" "ROUTER" "SWITCH"...$/;"	m	struct:__anon76
type	libstar/snmpdef.h	/^	int	type;			\/\/ other(1), inval(2), dir(3), indir(4)	{ipRouteEntry 8 } RW $/;"	m	struct:__anon82
type	libstar/snmpdef.h	/^	int	type;		\/\/ other(1), inval(2), dyn(3), stat(4)	{ ipNetToMediaEntry 4 } RW $/;"	m	struct:__anon79
type	libstar/snmpdef.h	/^	uint	type;			\/\/ I\/F type 6=ethernet, 24=loopback $/;"	m	struct:__anon78
type	libstar/ssmtplib.h	/^	int             type;$/;"	m	struct:__anon102
type	libstar/worm.h	/^	char		type[16];$/;"	m	struct:__anon108
type	libstar/xsnmp.h	/^	char		type[80];$/;"	m	struct:__anon163
type	libstar/xsnmp.h	/^	char	type[40];		\/\/ "SWITCH" "ROUTER"... 일반 서버가 아니면 포트 차단 못하게...$/;"	m	struct:__anon161
type	libstar/xsnmp.h	/^	int	type;$/;"	m	struct:__anon160
type	libstar/xsnmpif.c	/^	int	type;			\/\/ 1..22 I\/F 정보 번호 $/;"	m	struct:__anon164	file:
type	myjson/json.h	/^	const string type(int tt)$/;"	f	class:json
type	myjson/json.h	/^	int	type;$/;"	m	struct:jsonnode
type	myjson/json2.c	/^string json::type(const jsontype type)$/;"	f	class:json
type	myjson/json2.h	/^	jsontype type;$/;"	m	class:jsonnode
u_int16_t	libstar/type.h	/^typedef uint16			u_int16_t;$/;"	t
u_int32_t	libstar/type.h	/^typedef uint32			u_int32_t;$/;"	t
u_int64_t	libstar/type.h	/^typedef uint64			u_int64_t;$/;"	t
u_int8_t	libstar/type.h	/^typedef uint8			u_int8_t;$/;"	t
ucastPkts	libstar/sflowlib.h	/^	uint            ucastPkts;$/;"	m	struct:_SFLVlan_counters
uchar	libstar/type.h	/^typedef unsigned char		uchar;$/;"	t
uchar_t	libstar/type.h	/^typedef unsigned char		uchar_t;$/;"	t
udp	libstar/xpcap.h	/^	struct udphdr	*udp;			\/\/ UDP protocol$/;"	m	struct:__anon153	typeref:struct:__anon153::udphdr
udp_client_init	libstar/udp.c	/^udp_t	*udp_client_init(uint addr, uint port)$/;"	f
udp_close	libstar/udp.c	/^void	udp_close(udp_t *ufp)$/;"	f
udp_flush	libstar/udp.c	/^int	udp_flush(udp_t *ufp)$/;"	f
udp_hasdata	libstar/udp.c	/^int	udp_hasdata(int fd, int waitMS)$/;"	f
udp_mcast_client_init	libstar/udp.c	/^udp_t	*udp_mcast_client_init(uint addr, uint port)$/;"	f
udp_mcast_server_init	libstar/udp.c	/^udp_t	*udp_mcast_server_init(char *groupip, uint port)$/;"	f
udp_pduLen	libstar/sflowlib.h	/^	uint            udp_pduLen;$/;"	m	struct:_SFSample
udp_peek	libstar/udp.c	/^int	udp_peek(udp_t *ufp, void *buf, int bufsz)$/;"	f
udp_recv	libstar/udp.c	/^int	udp_recv(udp_t *ufp, void *buf, int bufsz)$/;"	f
udp_send	libstar/udp.c	/^int	udp_send(udp_t *ufp, void *buf, uint bufsz)$/;"	f
udp_server_init	libstar/udp.c	/^udp_t	*udp_server_init(uint port)$/;"	f
udp_t	libstar/udp.h	/^}	udp_t;$/;"	t	typeref:struct:__anon104
udpcount	libstar/snmpdef.h	/^	int	udpcount;$/;"	m	struct:__anon92
udphdrlen	libstar/xpcap.h	/^	int		udphdrlen;		\/\/ UDP 헤더 길이 $/;"	m	struct:__anon153
udplen	libstar/xpcap.h	/^	int		udplen;			\/\/ UDP 데이터 길이 $/;"	m	struct:__anon153
ufp	libstar/xflowlib.h	/^	udp_t		*ufp;		\/\/ Default netflow port 9995, sflow port 6343$/;"	m	struct:xflow
uint	libstar/type.h	/^typedef unsigned int		uint;$/;"	t
uint16	libstar/idea.c	/^typedef unsigned short	uint16;$/;"	t	file:
uint16	libstar/type.h	/^typedef unsigned short		uint16;$/;"	t
uint16_t	libstar/snoop.h	/^typedef ushort	uint16_t;$/;"	t
uint16_t	libstar/type.h	/^typedef uint16			uint16_t;$/;"	t
uint16_t	libstar/type.h	/^typedef unsigned short		uint16_t;$/;"	t
uint32	libstar/type.h	/^typedef unsigned int		uint32;$/;"	t
uint32_t	libstar/snoop.h	/^typedef uint	uint32_t;$/;"	t
uint32_t	libstar/type.h	/^typedef uint32			uint32_t;$/;"	t
uint64	libstar/type.h	/^typedef ULONGLONG		uint64;$/;"	t
uint64	libstar/type.h	/^typedef unsigned long long	uint64;$/;"	t
uint64_t	libstar/type.h	/^typedef uint64			uint64_t;$/;"	t
uint8	libstar/type.h	/^typedef unsigned char		uint8;$/;"	t
uint8_t	libstar/snoop.h	/^typedef uchar	uint8_t;$/;"	t
uint8_t	libstar/type.h	/^typedef uint8			uint8_t;$/;"	t
uint_t	libstar/type.h	/^typedef unsigned int		uint_t;$/;"	t
ulong	libstar/type.h	/^typedef unsigned long		ulong;$/;"	t
ulong_t	libstar/type.h	/^typedef unsigned long		ulong_t;$/;"	t
ulonglong	libstar/type.h	/^typedef unsigned long long	ulonglong;$/;"	t
ulonglong_t	libstar/type.h	/^typedef ULONGLONG		ulonglong_t;$/;"	t
ulonglong_t	libstar/type.h	/^typedef unsigned long long	ulonglong_t;$/;"	t
un	libstar/sflowlib.h	/^  } un;$/;"	m	struct:icmphdr	typeref:union:icmphdr::__anon67
unavailableAlarm	libstar/xsnmptrap.c	/^static oid      unavailableAlarm[] = { 1, 3, 6, 1, 6, 3, 2, 1, 1, 3, 3 };$/;"	v	file:
unique	libstar/netbios.c	/^	int		unique;$/;"	m	struct:__anon51	file:
unit	contract.h	/^	double	unit;				\/\/ smallest unit: 0.00000001$/;"	m	struct:__anon1
unitsize	libstar/xqueue.h	/^	int	unitsize;$/;"	m	struct:__anon156
unitsz	libstar/snmpdef.h	/^	int	unitsz[IDX_MAXDATA];	\/\/ 아래 데이타 블럭의 unit size $/;"	m	struct:__anon93
unix_nsecs	libstar/nflowlib.h	/^	uint32		unix_nsecs;	\/\/ residual nanoseconds since 0000 UTC 1970$/;"	m	struct:__anon56
unix_nsecs	libstar/nflowlib.h	/^	uint32		unix_nsecs;	\/\/ residual nanoseconds since 0000 UTC 1970$/;"	m	struct:__anon60
unix_nsecs	libstar/nflowlib.h	/^	uint32		unix_nsecs;$/;"	m	struct:__anon52
unix_nsecs	libstar/nflowlib.h	/^	uint32		unix_nsecs;$/;"	m	struct:__anon54
unix_nsecs	libstar/nflowlib.h	/^	uint32		unix_nsecs;$/;"	m	struct:__anon58
unix_secs	libstar/nflowlib.h	/^	uint32		unix_secs;	\/\/ current seconds since 0000 UTC 1970$/;"	m	struct:__anon56
unix_secs	libstar/nflowlib.h	/^	uint32		unix_secs;	\/\/ current seconds since 0000 UTC 1970$/;"	m	struct:__anon60
unix_secs	libstar/nflowlib.h	/^	uint32		unix_secs;$/;"	m	struct:__anon52
unix_secs	libstar/nflowlib.h	/^	uint32		unix_secs;$/;"	m	struct:__anon54
unix_secs	libstar/nflowlib.h	/^	uint32		unix_secs;$/;"	m	struct:__anon58
unlockfile	libstar/xlock.c	/^	char		unlockfile[40];$/;"	m	struct:__anon139	file:
unlockline	libstar/xlock.c	/^	int		unlockline;$/;"	m	struct:__anon139	file:
unsubscribe	rpc.h	/^	string unsubscribe(const char *json_id)$/;"	f	class:hdac
up	libstar/xsock.h	/^	int		up;$/;"	m	struct:__anon166
updated	libstar/xpcap.h	/^	int		updated;		\/\/ 내용이 변경된 경우 1 (thread_xpcap_read()에서 복사해야 하기 때문)$/;"	m	struct:__anon154
upsAdvBatteryCapacity	libstar/snmpdef.h	/^	int	upsAdvBatteryCapacity;			\/\/ 충전용량(%) 85% 이상이면 OK$/;"	m	struct:__anon97
upsAdvBatteryReplaceIndicator	libstar/snmpdef.h	/^	int	upsAdvBatteryReplaceIndicator;		\/\/ 배터리 교체 시기 != 2이면 OK$/;"	m	struct:__anon97
upsAdvOutputFrequency	libstar/snmpdef.h	/^	int	upsAdvOutputFrequency;			\/\/ 출력 주파수 (Hz) 55~65 OK$/;"	m	struct:__anon97
upsAdvOutputLoad	libstar/snmpdef.h	/^	int	upsAdvOutputLoad;			\/\/ UPS Load (%) <= 50 OK$/;"	m	struct:__anon97
upsAdvOutputVoltage	libstar/snmpdef.h	/^	int	upsAdvOutputVoltage;			\/\/ 출력 전압. 110~125 OK. 220~240 OK$/;"	m	struct:__anon97
upsBasicBatteryStatus	libstar/snmpdef.h	/^	int	upsBasicBatteryStatus	;		\/\/ 2이면 OK$/;"	m	struct:__anon97
upsBasicBatteryTimeOnBattery	libstar/snmpdef.h	/^	float	upsBasicBatteryTimeOnBattery;		\/\/ 배터리 사용시간 <= 12000 OK (100\/sec 단위)$/;"	m	struct:__anon97
upsBasicOutputStatus	libstar/snmpdef.h	/^	int	upsBasicOutputStatus;			\/\/ 2이면 OK$/;"	m	struct:__anon97
uptime	libstar/sflowlib.h	/^	uint            uptime;	\/* Current time (in milliseconds since device$/;"	m	struct:_SFLSample_datagram_hdr
uptime	libstar/snmpdef.h	/^	uint	uptime;			\/\/ 장비 가동 후 지난 시간으로 1\/100초 단위. [time(0) - sys->uptime \/ 100]으로 실제 부팅시간 계산 $/;"	m	struct:__anon76
url	libstar/sflowlib.h	/^	SFLExtended_url url;$/;"	m	union:_SFLFlow_type
url	libstar/sflowlib.h	/^	SFLString       url;	\/* URL associated with the packet flow.$/;"	m	struct:_SFLExtended_url
url	libstar/sflowlib.h	/^	char            url[SA_MAX_EXTENDED_URL_LEN + 1];$/;"	m	struct:_SFSample
url2addr	libstar/xsock.c	/^uint	url2addr(char *url)$/;"	f
url_direction	libstar/sflowlib.h	/^	uint            url_direction;$/;"	m	struct:_SFSample
url_len	libstar/sflowlib.h	/^	uint            url_len;$/;"	m	struct:_SFSample
use	libstar/fhash.h	/^	uint		use;			\/\/ 사용중이면 1$/;"	m	struct:__anon36
use	libstar/shash.h	/^	uint		use;			\/\/ 사용중이면 1$/;"	m	struct:__anon73
use	libstar/thrpool.h	/^	int		use;		\/\/ 1이면 사용중 $/;"	m	struct:thrdata
use	libstar/vhash.h	/^	uchar		use;		\/\/ 사용 중이면 1$/;"	m	struct:vhashentry
use	libstar/xnms.h	/^	int		use;			\/\/ 사용중이면 1 $/;"	m	struct:__anon151
usec	libstar/xpcap.h	/^	uint		usec;			\/\/ 캡쳐한 시각 (마이크로초) $/;"	m	struct:__anon152
user	libstar/sflowlib.h	/^	SFLExtended_user user;$/;"	m	union:_SFLFlow_type
userName	libstar/snmpdef.h	/^	char	userName[32];		\/\/ 사용자명$/;"	m	struct:__anon92
userdata	libstar/hash.h	/^	void		*userdata;	\/\/ 사용자 정의 데이터를 저장하기 위한 데이타 블럭$/;"	m	struct:hashentry
userdata	libstar/thrpool.h	/^	void		*userdata;	\/\/ Thread로 전달할 사용자 정의 데이터.$/;"	m	struct:thrdata
userdata	libstar/vhash.h	/^	void		*userdata;	\/\/ 사용자 정의 데이터를 저장하기 위한 데이타 블럭$/;"	m	struct:vhashentry
userdata	libstar/xlist.h	/^	void		*userdata;	\/\/ 데이터 블럭$/;"	m	struct:xlistnode
userdata	libstar/xpcap.h	/^	void		*userdata;		\/\/ 사용자 정의 구조체 $/;"	m	struct:__anon154
userdata	libstar/xsock.h	/^	char		userdata[504];	\/\/ sockdata_t가 들어갈 것임$/;"	m	struct:xsocket
userdatalen	libstar/hash.h	/^	int		userdatalen;	\/\/ 사용자 정의 데이터의 크기 $/;"	m	struct:hashentry
userdatalen	libstar/vhash.h	/^	int		userdatalen;	\/\/ 사용자 정의 데이터의 크기 $/;"	m	struct:vhashentry
userdatalen	libstar/xlist.h	/^	int		userdatalen;	\/\/ 데이터 블럭 크기$/;"	m	struct:xlistnode
userdef	libstar/xflowlib.h	/^	int		userdef;	\/\/ 1이면 항상 TopN 통계에 포함되어야 하는 raw packet$/;"	m	struct:__anon129
userid	libstar/ssmtplib.h	/^	char		userid[40];$/;"	m	struct:__anon103
userid	libstar/worm.h	/^	char		userid[40];		\/\/ 시스템 userid $/;"	m	struct:__anon109
userid	libstar/xapp.h	/^	char		userid[40];	\/\/ FTP userid$/;"	m	struct:__anon113
userid	libstar/xdb.h	/^	char		userid[32];$/;"	m	struct:__anon118
username	libstar/snmpdef.h	/^	char		username[32];$/;"	m	struct:__anon85
username	libstar/snmpdef.h	/^	char	username[32];$/;"	m	struct:__anon87
ushort	libstar/type.h	/^typedef unsigned short		ushort;$/;"	t
ushort_t	libstar/type.h	/^typedef unsigned short		ushort_t;$/;"	t
v1printf	libstar/xdebug.h	121;"	d
v2printf	libstar/xdebug.h	120;"	d
v3printf	libstar/xdebug.h	119;"	d
v4printf	libstar/xdebug.h	118;"	d
v5printf	libstar/xdebug.h	117;"	d
valid	libstar/snmpdef.h	/^	int	valid[IDX_MAXDATA];	\/\/ 들어간 데이터가 사용 가능한지..$/;"	m	struct:__anon93
valid_address	hdaclib.c	/^bool	valid_address(const char *addr)$/;"	f
validateaddress	rpc.h	/^	string validateaddress(const char *addr)$/;"	f	class:hdac
validp	libstar/xindex.h	/^	char	*validp;		\/\/ 데이터가 사용 가능하면 1 삭제된 것이면 0$/;"	m	struct:__anon137
value	hdaclib.h	/^	char	value[256];$/;"	m	struct:__anon4
value	json11/json11.hpp	/^        && std::is_constructible<Json, decltype(std::declval<M>().begin()->second)>::value,$/;"	m	class:json11::final
value	json2.h	/^	string	value;$/;"	m	class:jsonnode
value	libstar/xdebug.h	/^	int	value;$/;"	m	struct:__anon124
value	myjson/json.h	/^	struct jsonnode *value;$/;"	m	struct:jsonnode	typeref:struct:jsonnode::jsonnode
value	myjson/json2.h	/^	string	value;$/;"	m	class:jsonnode
valuetype	json2.h	/^	jsontype valuetype;$/;"	m	class:jsonnode
valuetype	myjson/json2.h	/^	jsontype valuetype;$/;"	m	class:jsonnode
var	libstar/fhash.h	/^	uchar		var[4];			\/\/ 64bit용으로 8바이트 align..$/;"	m	struct:__anon36
var	libstar/hash.h	/^	ulong		var[2];		\/\/ Instant data와 key를 저장하기 위한 공간.$/;"	m	struct:hashentry
var	libstar/shash.h	/^	uchar		var[4];			\/\/ 64bit용으로 8바이트 align..$/;"	m	struct:__anon73
var	libstar/vhash.h	/^	ulong		*var;		\/\/ 실제 데이터인 instance가 들어가는 곳.$/;"	m	struct:vhashentry
var	libstar/xlist.h	/^	uint		var[3];		\/\/ Instant data와 key를 저장하기 위한 공간.$/;"	m	struct:xlistnode
var	libstar/xlist.h	/^	ulong		var[3];		\/\/ Instant data와 key를 저장하기 위한 공간.$/;"	m	struct:xlistnode
vc_instance_name	libstar/sflowlib.h	/^	SFLString       vc_instance_name;	\/* VC instance name *\/$/;"	m	struct:_SFLExtended_mpls_vc
vc_label_cos	libstar/sflowlib.h	/^	uint            vc_label_cos;	\/* VC Label COS value *\/$/;"	m	struct:_SFLExtended_mpls_vc
vendor	libstar/snmpdef.h	/^	char	vendor[32];		\/\/ "CISCO"$/;"	m	struct:__anon76
vendor	libstar/xsnmp.h	/^	char		vendor[80];$/;"	m	struct:__anon163
vendor	libstar/xsnmp.h	/^	char	vendor[40];$/;"	m	struct:__anon161
vendor	libstar/xsnmptype.c	/^	char		vendor[50];$/;"	m	struct:__anon165	file:
verb	libstar/xtn.c	/^	_verb	verb;		\/\/ = VERB_SB;$/;"	m	struct:__anon177	file:
verifymessage	rpc.h	/^	string verifymessage(const char *addr, const char *signature, const char *message)$/;"	f	class:hdac
version	libstar/http.c	/^	char	version[20];	\/\/ HTTP\/1.1 $/;"	m	struct:__anon43	file:
version	libstar/nflowlib.h	/^	uint16		version;	\/\/  flow-export version number$/;"	m	struct:__anon52
version	libstar/nflowlib.h	/^	uint16		version;	\/\/  flow-export version number$/;"	m	struct:__anon54
version	libstar/nflowlib.h	/^	uint16		version;	\/\/  flow-export version number$/;"	m	struct:__anon58
version	libstar/nflowlib.h	/^	uint16		version;	\/\/ flow-export version number$/;"	m	struct:__anon60
version	libstar/nflowlib.h	/^	uint16		version;	\/\/ version$/;"	m	struct:__anon56
version	libstar/sflowlib.h	/^    uint8_t version:4;$/;"	m	struct:iphdr
version	libstar/xflowlib.h	/^	int		version;$/;"	m	struct:__anon129
version_major	libstar/netbios.c	/^	uchar		version_major;$/;"	m	struct:__anon49	file:
version_minor	libstar/netbios.c	/^	uchar		version_minor;$/;"	m	struct:__anon49	file:
vg	libstar/sflowlib.h	/^	SFLVg_counters  vg;$/;"	m	union:_SFLCounters_type
vhash_delete	libstar/vhash.c	/^void	vhash_delete(vhashent_t *he)$/;"	f
vhash_deleteall	libstar/vhash.c	/^void	vhash_deleteall(vhash_t *ht)$/;"	f
vhash_dump	libstar/vhash.c	/^void	vhash_dump(vhash_t *ht)$/;"	f
vhash_fast_func	libstar/vhash.c	/^uint32	vhash_fast_func(const char *data, size_t len)$/;"	f
vhash_find	libstar/vhash.h	125;"	d
vhash_findempty	libstar/vhash.c	/^static	int	vhash_findempty(vhash_t *ht, uint hashval, int *nthtable, int *nthentry)$/;"	f	file:
vhash_findloop	libstar/vhash.h	126;"	d
vhash_findnext	libstar/vhash.c	/^vhashent_t	*vhash_findnext(vhash_t *ht, vhashloop_t *vlp)$/;"	f
vhash_findsub	libstar/vhash.c	/^static vhashent_t	*vhash_findsub(vhash_t *ht, vhashloop_t *vlp, const void *key, const int keylen, uint hashval)$/;"	f	file:
vhash_first	libstar/vhash.c	/^vhashent_t	*vhash_first(register vhash_t *ht, vhashloop_t *vlp)$/;"	f
vhash_free	libstar/vhash.h	104;"	d
vhash_free_table	libstar/vhash.c	/^int	vhash_free_table(register vhash_t *ht, int idx)$/;"	f
vhash_func	libstar/vhash.c	/^uint	vhash_func(const void *key, size_t len)$/;"	f
vhash_getdata	libstar/vhash.c	/^void	*vhash_getdata(register vhashent_t *he, int *datalen)$/;"	f
vhash_getkey	libstar/vhash.c	/^void	*vhash_getkey(register vhashent_t *he, int *keylen)$/;"	f
vhash_getsize	libstar/vhash.c	/^int	vhash_getsize(vhash_t *ht)$/;"	f
vhash_init	libstar/vhash.h	99;"	d
vhash_init_table	libstar/vhash.c	/^int	vhash_init_table(const char *filename, const int lineno, register vhash_t *ht, int idx)$/;"	f
vhash_insert	libstar/vhash.h	115;"	d
vhash_insert_real	libstar/vhash.c	/^vhashent_t	*vhash_insert_real(const char *filename, const int lineno, const char *hashname, vhash_t *ht, const void *key, const int keylen)$/;"	f
vhash_lock	libstar/vhash.h	108;"	d
vhash_next	libstar/vhash.c	/^vhashent_t	*vhash_next(register vhash_t *ht, vhashloop_t *vlp)$/;"	f
vhash_savedata	libstar/vhash.c	/^void	vhash_savedata(vhashent_t *he, const void *val, const int len)$/;"	f
vhash_setdata	libstar/vhash.c	/^void	vhash_setdata(vhashent_t *he, const void *val, const int len)$/;"	f
vhash_setloop	libstar/vhash.c	/^void	vhash_setloop(vhash_t *ht, int cmpsize)$/;"	f
vhash_setmaxtable	libstar/vhash.c	/^void	vhash_setmaxtable(vhash_t *ht, int maxtablesize)$/;"	f
vhash_t	libstar/vhash.h	/^}	vhash_t;$/;"	t	typeref:struct:__anon105
vhash_unlock	libstar/vhash.h	109;"	d
vhash_update	libstar/vhash.h	116;"	d
vhash_update_real	libstar/vhash.c	/^vhashent_t	*vhash_update_real(const char *filename, const int lineno, const char *hashname, vhash_t *ht, const void *key, const int keylen)$/;"	f
vhashent_t	libstar/vhash.h	/^}	vhashent_t;$/;"	t	typeref:struct:vhashentry
vhashentry	libstar/vhash.h	/^typedef struct vhashentry {$/;"	s
vhashloop_t	libstar/vhash.h	/^}	vhashloop_t;$/;"	t	typeref:struct:__anon106
vht	libstar/xdb.h	/^	vhash_t		*vht;		\/\/ 결과 저장 hash table$/;"	m	struct:__anon119
vlan	libstar/sflowlib.h	/^	SFLVlan_counters vlan;$/;"	m	union:_SFLCounters_type
vlan_id	libstar/sflowlib.h	/^	uint            vlan_id;$/;"	m	struct:_SFLVlan_counters
vlan_tunnel	libstar/sflowlib.h	/^	SFLExtended_vlan_tunnel vlan_tunnel;$/;"	m	union:_SFLFlow_type
vlanidx	libstar/xsnmp.h	/^	int	vlanidx;$/;"	m	struct:__anon160
vlanidx	libstar/xsnmp.h	/^	int	vlanidx;$/;"	m	struct:__anon161
vlanindex	libstar/xnms.h	/^	int		vlanindex;		\/\/ .23	\/\/ VLAN index$/;"	m	struct:__anon148
vlanport	libstar/xsnmp.h	/^	int	vlanport;		\/\/ Net2Media에 나타나는 Vlan 포트 번호 (ifindex 번호와 유사)$/;"	m	struct:__anon161
vlanstate	libstar/xsnmp.h	/^	int	vlanstate;$/;"	m	struct:__anon161
vll_vc_id	libstar/sflowlib.h	/^	uint            vll_vc_id;	\/* VLL\/VC instance ID *\/$/;"	m	struct:_SFLExtended_mpls_vc
vmthr	hvm.c	/^VTHREAD	vmthr(void *arg)$/;"	f
vmthr_t	hvm.c	/^} vmthr_t;$/;"	t	typeref:struct:__anon11	file:
vprintf	libstar/xdebug.h	122;"	d
wait	libstar/proflib.c	/^	pthread_cond_t  wait;$/;"	m	struct:wrapper_s	file:
wait_thread_exit	libstar/xutil.c	/^void	wait_thread_exit(int sec)$/;"	f
waitstr	libstar/xapp.h	/^	char		waitstr[100];$/;"	m	struct:__anon113
walletpassphrase	rpc.h	/^	string walletpassphrase(const char *passphrase, const int timeout_sec)$/;"	f	class:hdac
weight	libstar/snmpdef.h	/^	int		weight;			\/\/ 서버 Weight$/;"	m	struct:__anon96
whois_query	libstar/whois.c	/^char	*whois_query(char *retbuf, int bufsz, char *host, char *port, char *query)$/;"	f
whois_query2	libstar/whois.c	/^static	char	*whois_query2(char *retbuf, int bufsz, char *host, char *port, char *query)$/;"	f	file:
wooinit	libstar/proflib.c	/^void wooinit(void)$/;"	f
word16	libstar/idea.c	/^typedef unsigned short	word16;$/;"	t	file:
word32	libstar/idea.c	/^typedef unsigned int	word32;$/;"	t	file:
worm	libstar/worm.h	/^	worm_t		*worm;$/;"	m	struct:__anon110
worm_change_passwd	libstar/worm.c	/^int	worm_change_passwd(worm_t *worm, char *userid, char *passwd)$/;"	f
worm_close	libstar/worm.h	28;"	d
worm_create_folder	libstar/worm.c	/^int	worm_create_folder(worm_t *worm, wormfile_t *rule)$/;"	f
worm_create_user	libstar/worm.c	/^int	worm_create_user(worm_t *worm, char *userid, char *passwd, int quota_mb, char *mode, char *expire)$/;"	f
worm_delete_path	libstar/worm.c	/^int	worm_delete_path(worm_t *worm, char *path, char *opt)$/;"	f
worm_delete_user	libstar/worm.c	/^int	worm_delete_user(worm_t *worm, char *userid)$/;"	f
worm_errmsg	libstar/worm.c	/^const	char	*worm_errmsg(int code)$/;"	f
worm_find	libstar/worm.c	/^char	*worm_find(worm_t *worm, char *ptn, char *pathname, char *opt)$/;"	f
worm_get_property	libstar/worm.c	/^int	worm_get_property(worm_t *worm, char *filename, char *filetype, char *filesize, char *filetime, char *fileperm)$/;"	f
worm_heartbeat	libstar/worm.c	/^int	worm_heartbeat(worm_t *worm)$/;"	f
worm_list	libstar/worm.c	/^char	*worm_list(worm_t *worm, char *opt, char *pathname)$/;"	f
worm_login	libstar/worm.c	/^worm_t	*worm_login(char *wormip, int worm_port, char *userid, char *passwd)$/;"	f
worm_logout	libstar/worm.h	29;"	d
worm_md5	libstar/worm.c	/^int	worm_md5(worm_t *worm, char *path, char *md5buf)$/;"	f
worm_open	libstar/worm.c	/^wormfile_t *worm_open(worm_t *worm, char *filename, char *mode, char *opt)$/;"	f
worm_read	libstar/worm.c	/^int	worm_read(wormfile_t *wormfile, char *buf, int bufsz)$/;"	f
worm_seek	libstar/worm.c	/^longlong_t	worm_seek(wormfile_t *wormfile, longlong_t offset64, int whence)$/;"	f
worm_send	libstar/worm.c	/^wormhdr_t *worm_send(worm_t *worm, char *type, void *buf, int bufsz, wormhdr_t *hp, char *readbuf, int *readbufsz)$/;"	f
worm_set_expire	libstar/worm.c	/^int	worm_set_expire(worm_t *worm, wormfile_t *rule)$/;"	f
worm_set_property	libstar/worm.c	/^int	worm_set_property(worm_t *worm, char *path, char *mode, char *opt)$/;"	f
worm_set_quota	libstar/worm.c	/^int	worm_set_quota(worm_t *worm, char *userid, char *quota_mb)$/;"	f
worm_t	libstar/worm.h	/^}	worm_t;$/;"	t	typeref:struct:__anon109
worm_write	libstar/worm.c	/^int	worm_write(wormfile_t *wormfile, char *buf, int bufsz)$/;"	f
wormfile_t	libstar/worm.h	/^}	wormfile_t;$/;"	t	typeref:struct:__anon110
wormhdr_t	libstar/worm.h	/^}	wormhdr_t;$/;"	t	typeref:struct:__anon108
wormip	libstar/worm.h	/^	char		wormip[20];$/;"	m	struct:__anon109
wormport	libstar/worm.h	/^	int		wormport;		\/\/ DEFAULT_WORM_PORT$/;"	m	struct:__anon109
wormsock	libstar/worm.h	/^	int		wormsock;		\/\/ WORM socket $/;"	m	struct:__anon109
wptr	libstar/xpcap.h	/^	char		*wptr;			\/\/ Write 위치 $/;"	m	struct:__anon154
wrapper_routine	libstar/proflib.c	/^static void    *wrapper_routine(void *data)$/;"	f	file:
wrapper_s	libstar/proflib.c	/^typedef struct wrapper_s$/;"	s	file:
wrapper_t	libstar/proflib.c	/^}	wrapper_t;$/;"	t	typeref:struct:wrapper_s	file:
writeconf	libstar/xstr.c	/^int	writeconf(char *filename, char *name, const char *data)$/;"	f
writefile	libstar/xutil.c	/^int	writefile(const char *fname, void *buf, int buflen)$/;"	f
writetime	libstar/dvdlib.h	/^	time32		writetime;		\/\/ 기록시간$/;"	m	struct:__anon31
writetime	libstar/oddlib.h	/^	time32		writetime;	\/\/ 기록시간$/;"	m	struct:__anon64
x1error	libstar/xdebug.h	93;"	d
x1printf	libstar/xdebug.h	99;"	d
x2error	libstar/xdebug.h	92;"	d
x2printf	libstar/xdebug.h	98;"	d
x3error	libstar/xdebug.h	91;"	d
x3printf	libstar/xdebug.h	97;"	d
x4printf	libstar/xdebug.h	96;"	d
x5printf	libstar/xdebug.h	95;"	d
xalarm	libstar/xtime.h	70;"	d
xalarm_catch	libstar/xtime.c	/^void	xalarm_catch(int signo)$/;"	f
xalarm_t	libstar/xtime.c	/^}	xalarm_t;$/;"	t	typeref:struct:__anon170	file:
xarp_del	libstar/xarp.c	/^int	xarp_del(char *host, char *dev)$/;"	f
xarp_get	libstar/xarp.c	/^char	*xarp_get(char *host, char *dev, char *eaddr, char *flags)$/;"	f
xarp_set	libstar/xarp.c	/^int	xarp_set(const char *host, const char *dev, char *eaddr, char *flags)$/;"	f
xarp_setfile	libstar/xarp.c	/^int	xarp_setfile(char *name)$/;"	f
xcalloc	libstar/xdebug.h	212;"	d
xcatchsig	libstar/xdebug.c	/^static	void	xcatchsig(int sig)$/;"	f	file:
xchecklock	libstar/xlock.c	/^void	xchecklock(const char *filename, const int lineno, xlock_t *lock, uint info)$/;"	f
xcheckunlock	libstar/xlock.c	/^void	xcheckunlock(const char *filename, const int lineno, xlock_t *lock, uint info)$/;"	f
xclose	libstar/xdebug.h	275;"	d
xconf_get	libstar/xstr.c	/^char	*xconf_get(vhash_t *vht, const char *section, const char *name, char *retbuf)$/;"	f
xconf_load_file	libstar/xstr.c	/^vhash_t	*xconf_load_file(char *filename, int keylen)$/;"	f
xconf_save_file	libstar/xstr.c	/^int	xconf_save_file(char *filename, vhash_t *vht)$/;"	f
xconf_set	libstar/xstr.c	/^int	xconf_set(vhash_t *vht, const char *section, const char *name, const char *value)$/;"	f
xcron_match_data	libstar/xtime.c	/^int	xcron_match_data(char *expr, int data, int first, int last)$/;"	f
xcron_matched	libstar/xtime.c	/^int	xcron_matched(char *cronstr, char *matchbuf, time32 curtm)$/;"	f
xcropen	libstar/xdebug.h	274;"	d
xdb	libstar/xdb.h	/^	xdb_t		xdb;		\/\/ DB 정보 $/;"	m	struct:__anon119
xdb_close	libstar/xdb.c	/^void	xdb_close(xdb_t *xdb)$/;"	f
xdb_exec	libstar/xdb.c	/^int	xdb_exec(xdb_t *xdb, char *sql)$/;"	f
xdb_find_column	libstar/xdb.c	/^int	xdb_find_column(vhash_t *vht, char *fieldname)$/;"	f
xdb_first	libstar/xdb.h	189;"	d
xdb_fixtopn	libstar/xdb.c	/^char	*xdb_fixtopn(xdb_t *xdb, char *sqlbuf, int topn)$/;"	f
xdb_free	libstar/xdb.h	175;"	d
xdb_get	libstar/xdb.c	/^xdbdata_t *xdb_get(vhash_t *vht, int nthrow, int nthcol)$/;"	f
xdb_get_byname	libstar/xdb.c	/^xdbdata_t *xdb_get_byname(vhash_t *vht, int nthrow, char *fieldname)$/;"	f
xdb_get_fieldname	libstar/xdb.c	/^char	*xdb_get_fieldname(vhash_t *vht, int ncol)$/;"	f
xdb_geterrstr	libstar/xdb.c	/^char	*xdb_geterrstr(xdb_t *xdb)$/;"	f
xdb_getint	libstar/xdb.c	/^int	xdb_getint(vhash_t *vht, int nthrow, int nthcol)$/;"	f
xdb_getint_byname	libstar/xdb.c	/^int	xdb_getint_byname(vhash_t *vht, int nthrow, char *fieldname)$/;"	f
xdb_getrow	libstar/xdb.c	/^xdbrowdata_t *xdb_getrow(vhash_t *vht, int nthrow, xdbrowdata_t *drp)$/;"	f
xdb_getsql	libstar/xdb.c	/^char	*xdb_getsql(vhash_t *vht)$/;"	f
xdb_getstr	libstar/xdb.c	/^char	*xdb_getstr(vhash_t *vht, int nthrow, int nthcol)$/;"	f
xdb_getstr_byname	libstar/xdb.c	/^char	*xdb_getstr_byname(vhash_t *vht, int nthrow, char *fieldname)$/;"	f
xdb_getuint	libstar/xdb.c	/^uint	xdb_getuint(vhash_t *vht, int nthrow, int nthcol)$/;"	f
xdb_getuint_byname	libstar/xdb.c	/^uint	xdb_getuint_byname(vhash_t *vht, int nthrow, char *fieldname)$/;"	f
xdb_lock	libstar/xdb.h	150;"	d
xdb_loop_close	libstar/xdb.c	/^void	xdb_loop_close(xdbloop_t *xdbloop)$/;"	f
xdb_loop_open	libstar/xdb.c	/^xdbloop_t	*xdb_loop_open(xdbloop_t *xdbloop, char *sql)$/;"	f
xdb_next	libstar/xdb.h	190;"	d
xdb_open	libstar/xdb.c	/^int     xdb_open(xdb_t *xdb)$/;"	f
xdb_scanf	libstar/xdb.c	/^int	xdb_scanf(vhash_t *vht, ...)$/;"	f
xdb_select	libstar/xdb.h	157;"	d
xdb_select_test	libstar/xdb.c	/^int	xdb_select_test(xdb_t *xdb, char *sqlbuf)$/;"	f
xdb_selectdb	libstar/xdb.c	/^int	xdb_selectdb(xdb_t *xdb, char *dbname)$/;"	f
xdb_setmaxrow	libstar/xdb.c	/^void	xdb_setmaxrow(xdb_t *xdb, int maxrow)$/;"	f
xdb_setretry	libstar/xdb.c	/^void	xdb_setretry(xdb_t *xdb, int failretry)$/;"	f
xdb_t	libstar/xdb.h	/^}	xdb_t;$/;"	t	typeref:struct:__anon118
xdb_unlock	libstar/xdb.h	151;"	d
xdbdata_t	libstar/xdb.h	/^}	xdbdata_t;$/;"	t	typeref:struct:__anon117
xdbkey_t	libstar/xdb.h	/^}	xdbkey_t;$/;"	t	typeref:struct:__anon115
xdbloop_t	libstar/xdb.h	/^}	xdbloop_t;$/;"	t	typeref:struct:__anon119
xdbrowdata_t	libstar/xdb.h	/^}	xdbrowdata_t;$/;"	t	typeref:struct:__anon116
xdiffms	libstar/xtime.c	/^uint	xdiffms(xtime_t *tv, xtime_t *tv2)$/;"	f
xdir_close	libstar/xutil.h	113;"	d
xdir_first	libstar/xutil.c	/^char	*xdir_first(xdir_t *xdp)$/;"	f
xdir_next	libstar/xutil.c	/^char	*xdir_next(xdir_t *xdp)$/;"	f
xdir_open	libstar/xutil.c	/^xdir_t	*xdir_open(char *path)$/;"	f
xdir_reopen	libstar/xutil.c	/^xdir_t	*xdir_reopen(xdir_t *xdp)$/;"	f
xdir_t	libstar/xutil.h	/^}	xdir_t;$/;"	t	typeref:struct:__anon180
xerror	libstar/xdebug.h	148;"	d
xfclose	libstar/xdebug.h	272;"	d
xfgets	libstar/xstr.c	/^char	*xfgets(char *buf, int buflen, FILE *fp)$/;"	f
xfindname	libstar/xstr.c	/^char   *xfindname(buffer_t *inbuf, const char *name1, const char *name2)$/;"	f
xflow	libstar/xflowlib.h	/^typedef struct xflow {$/;"	s
xflow_addqueue	libstar/xflowlib.c	/^static	void	xflow_addqueue(xflow_t *xfp, xflow_packet_t *rawp)$/;"	f	file:
xflow_free	libstar/xflowlib.c	/^void	xflow_free(xflow_t *xfp)$/;"	f
xflow_init	libstar/xflowlib.c	/^xflow_t	*xflow_init(int flowtype, int listen_port, int nthread, flow_callback_t callback, flow_rawcallback_t rawcallback)$/;"	f
xflow_packet_t	libstar/xflowlib.h	/^}	xflow_packet_t;$/;"	t	typeref:struct:__anon128
xflow_perfstat_t	libstar/xflowlib.h	/^}	xflow_perfstat_t;$/;"	t	typeref:struct:__anon130
xflow_rawdata_t	libstar/xflowlib.h	/^}	xflow_rawdata_t;$/;"	t	typeref:struct:__anon129
xflow_setmirror	libstar/xflowlib.c	/^void	xflow_setmirror(xflow_t *xfp, uint addr, int port)$/;"	f
xflow_setsampling	libstar/xflowlib.c	/^void	xflow_setsampling(xflow_t *xfp, int sampling)$/;"	f
xflow_start	libstar/xflowlib.c	/^void	xflow_start(xflow_t *xfp)$/;"	f
xflow_stop	libstar/xflowlib.c	/^void	xflow_stop(xflow_t *xfp)$/;"	f
xflow_t	libstar/xflowlib.h	/^}	xflow_t;$/;"	t	typeref:struct:xflow
xfopen	libstar/xdebug.h	271;"	d
xfree	libstar/xdebug.h	209;"	d
xfreev	libstar/xdebug.h	210;"	d
xftp_t	libstar/xapp.h	/^}	xftp_t;$/;"	t	typeref:struct:__anon113
xgetclock	libstar/xtime.c	/^double	xgetclock(xtime_t *xtm)$/;"	f
xgetfield	libstar/xstr.c	/^char  **xgetfield(char *buf, const char *fldbuf, const char sep)$/;"	f
xgetline	libstar/xstr.c	/^char   *xgetline(buffer_t *inbuf, char *buf, int buflen)$/;"	f
xgetstrclock	libstar/xtime.c	/^char	*xgetstrclock(char *opt, char *buf)$/;"	f
xgettoken	libstar/xstr.c	/^int	xgettoken(int ac, char *av[], char *inbuf, const char *ptn, int trimspace, int skip_multi_sep)$/;"	f
xgettokenv	libstar/xstr.h	96;"	d
xgwrule_t	libstar/gw.h	/^}	xgwrule_t;$/;"	t	typeref:struct:gwrule
xhash_func	libstar/xhash.c	/^uint32_t xhash_func( const void *key, size_t length, uint32_t initval)$/;"	f
xhash_func0	libstar/xhash.c	/^uint32_t xhash_func0( const void *key, size_t length)$/;"	f
xhash_func2	libstar/xhash.c	/^void	xhash_func2( $/;"	f
xicmp_close	libstar/xicmp.c	/^void	xicmp_close(xicmp_t *icmp)$/;"	f
xicmp_copy	libstar/xicmp.c	/^xicmp_t	*xicmp_copy(xicmp_t *icmp)$/;"	f
xicmp_getchecksum	libstar/xicmp.c	/^static	ushort	xicmp_getchecksum(ushort *pBuf, int Len)$/;"	f	file:
xicmp_gettimeout	libstar/xicmp.c	/^void	xicmp_gettimeout(xicmp_t *xp, int *recvMS, int *sendMS)$/;"	f
xicmp_getttl	libstar/xicmp.c	/^void	xicmp_getttl(xicmp_t *xp, int *ttl)$/;"	f
xicmp_open	libstar/xicmp.c	/^xicmp_t	*xicmp_open(int nRecvimeoutMS, int nSendTimeoutMS)$/;"	f
xicmp_ping	libstar/xicmp.c	/^int	xicmp_ping(xicmp_t *icmp)$/;"	f
xicmp_ready	libstar/xicmp.c	/^int     xicmp_ready(int sock, int waitMS)$/;"	f
xicmp_recv	libstar/xicmp.c	/^int	xicmp_recv(xicmp_t *icmp)$/;"	f
xicmp_recvany	libstar/xicmp.c	/^int	xicmp_recvany(xicmp_t *icmp)$/;"	f
xicmp_setip	libstar/xicmp.c	/^uint	xicmp_setip(xicmp_t *icmp, char *pHostName)$/;"	f
xicmp_settimeout	libstar/xicmp.c	/^int	xicmp_settimeout(xicmp_t *icmp, int nRecvimeoutMS, int nSendTimeoutMS)$/;"	f
xicmp_setttl	libstar/xicmp.c	/^int		xicmp_setttl(xicmp_t *icmp, int ttl)$/;"	f
xicmp_t	libstar/xicmp.h	/^}	xicmp_t;$/;"	t	typeref:struct:__anon136
xicmpdata_t	libstar/xicmp.h	/^}	xicmpdata_t;$/;"	t	typeref:struct:__anon133
xicmpres_t	libstar/xicmp.h	/^}	xicmpres_t;$/;"	t	typeref:struct:__anon134
xicmpsimul_t	libstar/xicmp.h	/^}	xicmpsimul_t;$/;"	t	typeref:struct:__anon135
xid_frame	libstar/snoop.h	/^	int xid_frame;	\/* Packet number *\/$/;"	m	struct:cache_struct
xid_gss_proc	libstar/snoop.h	/^	unsigned int xid_gss_proc; \/* control procedure *\/$/;"	m	struct:cache_struct
xid_gss_service	libstar/snoop.h	/^	int xid_gss_service; \/* none, integ, priv *\/$/;"	m	struct:cache_struct
xid_num	libstar/snoop.h	/^	int xid_num;	\/* RPC transaction id *\/$/;"	m	struct:cache_struct
xid_proc	libstar/snoop.h	/^	int xid_proc;	\/* RPC procedure number *\/$/;"	m	struct:cache_struct
xid_prog	libstar/snoop.h	/^	int xid_prog;	\/* RPC program number *\/$/;"	m	struct:cache_struct
xid_vers	libstar/snoop.h	/^	int xid_vers;	\/* RPC version number *\/$/;"	m	struct:cache_struct
xifinfo_t	libstar/xsock.h	/^}	xifinfo_t;$/;"	t	typeref:struct:__anon166
xindex_delete	libstar/xindex.c	/^void	xindex_delete(register xindex_t *ap, uint key)$/;"	f
xindex_deleteall	libstar/xindex.c	/^void	xindex_deleteall(register xindex_t *ap)$/;"	f
xindex_find	libstar/xindex.c	/^int	xindex_find(register xindex_t *ap, uint key)$/;"	f
xindex_free	libstar/xindex.h	40;"	d
xindex_getsize	libstar/xindex.c	/^int	xindex_getsize(register xindex_t *ap)$/;"	f
xindex_init	libstar/xindex.c	/^xindex_t	*xindex_init(int maxsize, int instsize)$/;"	f
xindex_insert	libstar/xindex.c	/^int	xindex_insert(register xindex_t *ap, uint key, register char *instp, int instsize)$/;"	f
xindex_lock	libstar/xindex.c	/^void	xindex_lock(xindex_t *ap)$/;"	f
xindex_numitem	libstar/xindex.c	/^int	xindex_numitem(register xindex_t *ap)$/;"	f
xindex_t	libstar/xindex.h	/^}	xindex_t;$/;"	t	typeref:struct:__anon137
xindex_unlock	libstar/xindex.c	/^void	xindex_unlock(xindex_t *ap)$/;"	f
xindex_update	libstar/xindex.c	/^int	xindex_update(register xindex_t *ap, uint key, register char *instp, int instsize)$/;"	f
xisspace	libstar/xstr.h	59;"	d
xlist	libstar/xlist.h	/^typedef struct xlist {$/;"	s
xlist_addhead	libstar/xlist.c	/^xlistnode_t	*xlist_addhead(xlist_t *xl)$/;"	f
xlist_addnext	libstar/xlist.c	/^xlistnode_t	*xlist_addnext(xlist_t *xl, xlistnode_t *node)$/;"	f
xlist_addprev	libstar/xlist.c	/^xlistnode_t	*xlist_addprev(xlist_t *xl, xlistnode_t *node)$/;"	f
xlist_addtail	libstar/xlist.h	80;"	d
xlist_allocpool	libstar/xlist.c	/^int	xlist_allocpool(register xlist_t *xl, uint nnode)$/;"	f
xlist_attachhead	libstar/xlist.c	/^xlistnode_t	*xlist_attachhead(xlist_t *xl, xlistnode_t *node)$/;"	f
xlist_attachnext	libstar/xlist.c	/^xlistnode_t	*xlist_attachnext(xlist_t *xl, xlistnode_t *base, xlistnode_t *node)$/;"	f
xlist_attachprev	libstar/xlist.c	/^xlistnode_t	*xlist_attachprev(xlist_t *xl, xlistnode_t *base, xlistnode_t *node)$/;"	f
xlist_attachtail	libstar/xlist.c	/^xlistnode_t	*xlist_attachtail(xlist_t *xl, xlistnode_t *node)$/;"	f
xlist_current	libstar/xlist.c	/^xlistnode_t	*xlist_current(xlist_t *xl, xlistloop_t *xloop)$/;"	f
xlist_delete	libstar/xlist.c	/^xlistnode_t	*xlist_delete(xlist_t *xl, xlistloop_t *xloop)$/;"	f
xlist_deleteall	libstar/xlist.c	/^void	xlist_deleteall(xlist_t *xl)$/;"	f
xlist_delnode	libstar/xlist.c	/^xlistnode_t	*xlist_delnode(xlist_t *xl, xlistnode_t *node, xlistloop_t *xloop)$/;"	f
xlist_detach	libstar/xlist.c	/^xlistnode_t	*xlist_detach(xlist_t *xl, xlistnode_t *node)$/;"	f
xlist_first	libstar/xlist.c	/^xlistnode_t	*xlist_first(xlist_t *xl, xlistloop_t *xloop)$/;"	f
xlist_free	libstar/xlist.h	62;"	d
xlist_freenode	libstar/xlist.c	/^void	xlist_freenode(xlistnode_t *xn)$/;"	f
xlist_get	libstar/xlist.c	/^xlistnode_t	*xlist_get(xlist_t *xl, int nth)$/;"	f
xlist_getdata	libstar/xlist.c	/^void	*xlist_getdata(xlistnode_t *xn, int *datalen)$/;"	f
xlist_getsize	libstar/xlist.c	/^int	xlist_getsize(xlist_t *xl)$/;"	f
xlist_init	libstar/xlist.h	60;"	d
xlist_last	libstar/xlist.c	/^xlistnode_t	*xlist_last(xlist_t *xl, xlistloop_t *xloop)$/;"	f
xlist_lock	libstar/xlist.h	68;"	d
xlist_next	libstar/xlist.c	/^xlistnode_t	*xlist_next(xlist_t *xl, xlistloop_t *xloop)$/;"	f
xlist_prev	libstar/xlist.c	/^xlistnode_t	*xlist_prev(xlist_t *xl, xlistloop_t *xloop)$/;"	f
xlist_savedata	libstar/xlist.c	/^xlistnode_t	*xlist_savedata(xlistnode_t *xn, void *data, int datalen)$/;"	f
xlist_setdata	libstar/xlist.c	/^xlistnode_t	*xlist_setdata(xlistnode_t *xn, void *data, int datalen)$/;"	f
xlist_setdata2	libstar/xlist.c	/^xlistnode_t	*xlist_setdata2(xlistnode_t *xn, void *data, int datalen)$/;"	f
xlist_t	libstar/xlist.h	/^}	xlist_t;$/;"	t	typeref:struct:xlist
xlist_unlock	libstar/xlist.h	69;"	d
xlistloop_t	libstar/xlist.h	/^}	xlistloop_t;$/;"	t	typeref:struct:__anon138
xlistnode	libstar/xlist.h	/^typedef struct xlistnode {$/;"	s
xlistnode_t	libstar/xlist.h	/^}	xlistnode_t;$/;"	t	typeref:struct:xlistnode
xlocaltime	libstar/xtime.h	64;"	d
xlock	libstar/xlock.h	52;"	d
xlock2	libstar/xlock.h	53;"	d
xlock_check	libstar/xlock.c	/^void	xlock_check(int limit)$/;"	f
xlock_check_enable	libstar/xlock.c	/^void	xlock_check_enable(int on)$/;"	f
xlock_count	libstar/xlock.c	/^static	void	xlock_count(const char *filename, const int lineno, xlock_t *lock, int islock, uint info)$/;"	f	file:
xlock_t	libstar/xlock.h	/^}	xlock_t;$/;"	t	typeref:struct:__anon140
xlockfree	libstar/xlock.c	/^void	xlockfree(xlock_t *lock)$/;"	f
xlockinit	libstar/xlock.c	/^void	xlockinit(xlock_t *lock)$/;"	f
xlogcallback	libstar/xdebug.c	/^void	xlogcallback(void (*logfunc) (char *buf))$/;"	f
xmalloc	libstar/xdebug.h	208;"	d
xmalloc_debug	libstar/xdebug.c	/^void	xmalloc_debug(int itv)$/;"	f
xmalloc_dump	libstar/xdebug.c	/^void	xmalloc_dump()$/;"	f
xmkdir	libstar/xdebug.h	266;"	d
xmkdir	libstar/xdebug.h	268;"	d
xmkpath	libstar/xutil.c	/^int	xmkpath(char *path, int path_has_filename)$/;"	f
xmonitor	libstar/xdebug.h	257;"	d
xmonitor_check	libstar/xdebug.c	/^int	xmonitor_check(int master_restart_timeout)$/;"	f
xnms	libstar/xnms.h	/^	xnms_t		*xnms;$/;"	m	struct:xnmsnode
xnms_add	libstar/xnms.c	/^int	xnms_add(xnms_t *xnms, xnmsnode_t *xn)$/;"	f
xnms_cfg_scan	libstar/xnms.c	/^char	*xnms_cfg_scan(xnmsauth_t *authp, float *runsec)$/;"	f
xnms_delete	libstar/xnms.c	/^int	xnms_delete(xnms_t *xnms, uint addr)$/;"	f
xnms_delete_node	libstar/xnms.c	/^void	xnms_delete_node(vhashent_t *vhe)$/;"	f
xnms_finduplink	libstar/xnms.c	/^int	xnms_finduplink(char *ipaddr, char *community, int loop, int nretry)$/;"	f
xnms_free	libstar/xnms.c	/^void	xnms_free(xnms_t *xnms)$/;"	f
xnms_get	libstar/xnms.c	/^xnmsnode_t	*xnms_get(xnms_t *xnms, uint addr)$/;"	f
xnms_geteventname	libstar/xnms.c	/^const	char	*xnms_geteventname(int ev)$/;"	f
xnms_init	libstar/xnms.c	/^xnms_t	*xnms_init(int max_nodes, int num_snmp_threads)$/;"	f
xnms_modify	libstar/xnms.c	/^int	xnms_modify(xnms_t *xnms, xnmsnode_t *xn)$/;"	f
xnms_ping_result	libstar/xnms.c	/^void	xnms_ping_result(xnms_t *xnms, char *nodeip, int responseUS)$/;"	f
xnms_setiflist	libstar/xnms.c	/^int	xnms_setiflist(xnms_t *xnms, uint addr, int *getiflist, int ngetiflist)$/;"	f
xnms_start	libstar/xnms.c	/^int	xnms_start(xnms_t *xnms)$/;"	f
xnms_stop	libstar/xnms.c	/^void	xnms_stop(xnms_t *xnms)$/;"	f
xnms_t	libstar/xnms.h	/^}	xnms_t;$/;"	t	typeref:struct:__anon149
xnms_telnet_exec	libstar/xnms.c	/^char	*xnms_telnet_exec(xtn_t *tn, char *cmds)$/;"	f
xnms_telnet_login	libstar/xnms.c	/^int	xnms_telnet_login(xtn_t *tn, char *userid, char *passwd, char *enpasswd)$/;"	f
xnmsauth_t	libstar/xnms.h	/^}	xnmsauth_t;$/;"	t	typeref:struct:__anon145
xnmsnode	libstar/xnms.h	/^typedef struct xnmsnode {$/;"	s
xnmsnode_t	libstar/xnms.h	/^}	xnmsnode_t;$/;"	t	typeref:struct:xnmsnode
xnullprintf	libstar/xdebug.h	/^inline void		xnullprintf(char *fmt, ...) { }$/;"	f
xnumfield	libstar/xstr.c	/^int	xnumfield(char *fldbuf, char sep)$/;"	f
xontime	libstar/xtime.h	142;"	d
xontime_real	libstar/xtime.c	/^int	xontime_real(char *filename, int lineno, int sec)$/;"	f
xopen	libstar/xdebug.h	273;"	d
xpcap_free	libstar/xpcap.h	173;"	d
xpcap_parse_t	libstar/xpcap.h	/^}	xpcap_parse_t;$/;"	t	typeref:struct:__anon153
xpcap_t	libstar/xpcap.h	/^}	xpcap_t;$/;"	t	typeref:struct:__anon154
xpcapcbf_t	libstar/xpcap.h	/^typedef	void	(*xpcapcbf_t) (void *xp);	\/\/ (xpcap_t *)가 넘어감 $/;"	t
xping	libstar/xping.c	/^int	xping(uint addr, int timeoutMS, int retry)$/;"	f
xping	libstar/xping.h	/^typedef struct xping {$/;"	s
xping_addaddr	libstar/xping.c	/^int	xping_addaddr(xping_t *xp, uint addr)$/;"	f
xping_addbclass	libstar/xping.c	/^int	xping_addbclass(xping_t *xp, char *bclass)$/;"	f
xping_addcclass	libstar/xping.c	/^int	xping_addcclass(xping_t *xp, char *cclass)$/;"	f
xping_addip	libstar/xping.c	/^int	xping_addip(xping_t *xp, char *ip)$/;"	f
xping_addrange	libstar/xping.c	/^int	xping_addrange(xping_t *xp, char *ip1, char *ip2)$/;"	f
xping_deladdr	libstar/xping.c	/^int	xping_deladdr(xping_t *xp, uint addr)$/;"	f
xping_delbclass	libstar/xping.c	/^int	xping_delbclass(xping_t *xp, char *bclass)$/;"	f
xping_delcclass	libstar/xping.c	/^int	xping_delcclass(xping_t *xp, char *cclass)$/;"	f
xping_deleteall	libstar/xping.c	/^void	xping_deleteall(xping_t *xp)$/;"	f
xping_delip	libstar/xping.c	/^int	xping_delip(xping_t *xp, char *ip)$/;"	f
xping_delrange	libstar/xping.c	/^int	xping_delrange(xping_t *xp, char *ip1, char *ip2)$/;"	f
xping_free	libstar/xping.h	115;"	d
xping_getaddrlist	libstar/xping.c	/^uint	*xping_getaddrlist(xping_t *xp, int *naddr, int type)$/;"	f
xping_getcount	libstar/xping.c	/^int	xping_getcount(xping_t *xp)$/;"	f
xping_getevtype	libstar/xping.c	/^const	char	*xping_getevtype(int evtype)$/;"	f
xping_getflag	libstar/xping.c	/^char	*xping_getflag(int flag)$/;"	f
xping_getpps	libstar/xping.c	/^int	xping_getpps(xping_t *xp)$/;"	f
xping_getresponselist	libstar/xping.c	/^xicmpres_t	*xping_getresponselist(xping_t *xp, int *naddr, int type)$/;"	f
xping_gettimeout	libstar/xping.c	/^int	xping_gettimeout(xping_t *xp)$/;"	f
xping_init	libstar/xping.c	/^xping_t	*xping_init()$/;"	f
xping_multi	libstar/xping.c	/^int	xping_multi(uint *addrlist, int naddr, xicmpres_t *res, int timeoutMS, int retry, int pps)$/;"	f
xping_setcallback	libstar/xping.c	/^void	xping_setcallback(xping_t *xp, void (*callback) (int evtype, xping_t *xp, uint addr, int responseUS))$/;"	f
xping_setpps	libstar/xping.c	/^void	xping_setpps(xping_t *xp, int pps)$/;"	f
xping_settimeout	libstar/xping.c	/^void	xping_settimeout(xping_t *xp, int timeoutMS)$/;"	f
xping_start	libstar/xping.c	/^int	xping_start(xping_t *xp)$/;"	f
xping_stop	libstar/xping.c	/^void	xping_stop(xping_t *xp)$/;"	f
xping_t	libstar/xping.h	/^}	xping_t;$/;"	t	typeref:struct:xping
xping_wait	libstar/xping.c	/^void	xping_wait(xping_t *xp)$/;"	f
xpingip	libstar/xping.c	/^int	xpingip(char *hostname, int timeoutMS, int retry)$/;"	f
xpingip_multi	libstar/xping.c	/^int	xpingip_multi(char *hostlist[], int nhost, xicmpres_t *res, int timeoutMS, int retry, int pps)$/;"	f
xportmap_t	libstar/xsnmp.h	/^}	xportmap_t;$/;"	t	typeref:struct:__anon161
xportmapkey_t	libstar/xsnmp.h	/^}	xportmapkey_t;$/;"	t	typeref:struct:__anon160
xprintdate	libstar/xdebug.h	173;"	d
xprintf	libstar/xdebug.h	147;"	d
xprof	libstar/xtime.c	/^double	xprof(char *id)$/;"	f
xprof_clear	libstar/xtime.c	/^void	xprof_clear(int idx)$/;"	f
xprof_disable	libstar/xtime.c	/^void	xprof_disable()$/;"	f
xprof_enable	libstar/xtime.c	/^void	xprof_enable()$/;"	f
xprof_end	libstar/xtime.c	/^void	xprof_end(int idx)$/;"	f
xprof_print	libstar/xtime.c	/^void	xprof_print(int idx, int nth)$/;"	f
xprof_start	libstar/xtime.h	119;"	d
xprof_t	libstar/xtime.h	/^}	xprof_t;$/;"	t	typeref:struct:__anon173
xprofclk_t	libstar/xtime.c	/^}	xprofclk_t;$/;"	t	typeref:struct:__anon171	file:
xprofdiff	libstar/xtime.c	/^double	xprofdiff(char *id)$/;"	f
xprofend	libstar/xtime.c	/^double	xprofend(char *id)$/;"	f
xprofprint	libstar/xtime.c	/^void	xprofprint(char *id, char *prompt)$/;"	f
xqueue_free	libstar/xqueue.h	31;"	d
xqueue_init	libstar/xqueue.c	/^xqueue_t *xqueue_init(int qlen, int unitsize)$/;"	f
xqueue_lock	libstar/xqueue.c	/^void	xqueue_lock(xqueue_t *xq)$/;"	f
xqueue_t	libstar/xqueue.h	/^}	xqueue_t;$/;"	t	typeref:struct:__anon156
xqueue_unlock	libstar/xqueue.c	/^void	xqueue_unlock(xqueue_t *xq)$/;"	f
xread64	libstar/xutil.c	/^int	xread64(int fd, void *buf, size_t buflen)$/;"	f
xrealgettokenv	libstar/xstr.c	/^_ALLOC	char	**xrealgettokenv(const char *filename, const int lineno, char *instr, const char *ptn, int trimspace)$/;"	f
xrealloc	libstar/xdebug.h	213;"	d
xreallock	libstar/xlock.c	/^void	xreallock(xlock_t *lock)$/;"	f
xrealstrdup	libstar/xstr.c	/^_ALLOC	char	*xrealstrdup(const char *file, const int line, const char *src)$/;"	f
xrealstrndup	libstar/xstr.c	/^_ALLOC	char	*xrealstrndup(const char *file, const int line, register char *src, size_t len)$/;"	f
xrealsystem	libstar/xutil.c	/^int	xrealsystem(char *file, int line, char *cmd)$/;"	f
xrealunlock	libstar/xlock.c	/^void	xrealunlock(xlock_t *lock)$/;"	f
xsetbuffer	libstar/xstr.c	/^int	xsetbuffer(buffer_t *inbuf, char *data)$/;"	f
xsetlogfile	libstar/xdebug.c	/^void	xsetlogfile(char *logfile, uint logsize)$/;"	f
xsetprint	libstar/xdebug.c	/^void	xsetprint(int print)$/;"	f
xsleep	libstar/xtime.c	/^int	xsleep(int sec)$/;"	f
xsnmp_addoid	libstar/xsnmp.c	/^int	xsnmp_addoid(xsnmp_t *xs, oid *oidval, int oidsz)$/;"	f
xsnmp_addsetoid	libstar/xsnmp.c	/^int	xsnmp_addsetoid(xsnmp_t *xs, oid *oidval, int oidsz, char type, char *value)$/;"	f
xsnmp_alteon_getl4idx	libstar/xsnmpl4.c	/^int	xsnmp_alteon_getl4idx(xsnmp_t *xs, int *idxlist, int maxidxlist, char *vendor)$/;"	f
xsnmp_cisco_vlanstate	libstar/xsnmp2.c	/^int	xsnmp_cisco_vlanstate(xsnmp_t *xs, int *vlanlist, int *nvlanlist)$/;"	f
xsnmp_clearfailhash	libstar/xsnmpif.c	/^void	xsnmp_clearfailhash(uint addr)$/;"	f
xsnmp_close	libstar/xsnmp.h	206;"	d
xsnmp_failhash	libstar/xsnmp.c	/^hash_t	*xsnmp_failhash = NULL;		\/\/ 포트 정보가 없는 index 번호$/;"	v
xsnmp_flush_data	libstar/xsnmp.c	/^int	xsnmp_flush_data(xsnmp_t *xs)$/;"	f
xsnmp_free	libstar/xsnmp.h	201;"	d
xsnmp_get	libstar/xsnmp.c	/^int	xsnmp_get(xsnmp_t *xs)$/;"	f
xsnmp_get_alteon_l4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_get_alteon_l4sess(xsnmp_t *xs, int *nsess, char *vendor)$/;"	f
xsnmp_get_alteon_real	libstar/xsnmpl4.c	/^int	xsnmp_get_alteon_real(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_alteon_virt	libstar/xsnmpl4.c	/^int	xsnmp_get_alteon_virt(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_cisco_ace_l4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_get_cisco_ace_l4sess(xsnmp_t *xs, int *nsess, char *vendor)$/;"	f
xsnmp_get_cisco_ace_real	libstar/xsnmpl4.c	/^int	xsnmp_get_cisco_ace_real(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_cisco_card	libstar/xsnmp2.c	/^nmsmodule_t	*xsnmp_get_cisco_card(xsnmp_t *xs, int *ncard)$/;"	f
xsnmp_get_cisco_chassis	libstar/xsnmp2.c	/^nmschassis_t	*xsnmp_get_cisco_chassis(xsnmp_t *xs)$/;"	f
xsnmp_get_cisco_module	libstar/xsnmp2.c	/^nmsmodule_t	*xsnmp_get_cisco_module(xsnmp_t *xs, int *nmodule)$/;"	f
xsnmp_get_f5_bigip_all	libstar/xsnmpl4.c	/^int	xsnmp_get_f5_bigip_all(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_f5_bigip_l4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_get_f5_bigip_l4sess(xsnmp_t *xs, int *nsess, char *vendor)$/;"	f
xsnmp_get_foundry_all	libstar/xsnmpl4.c	/^int	xsnmp_get_foundry_all(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_foundry_l4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_get_foundry_l4sess(xsnmp_t *xs, int *nsess, char *vendor)$/;"	f
xsnmp_get_netscaler_l4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_get_netscaler_l4sess(xsnmp_t *xs, int *nsess, char *vendor)$/;"	f
xsnmp_get_netscaler_real	libstar/xsnmpl4.c	/^int	xsnmp_get_netscaler_real(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_netscaler_virt	libstar/xsnmpl4.c	/^int	xsnmp_get_netscaler_virt(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_oid_map	libstar/xsnmptype.c	/^char	*xsnmp_get_oid_map(char *oidbuf, int reqvalue)$/;"	f
xsnmp_get_piolink_all	libstar/xsnmpl4.c	/^int	xsnmp_get_piolink_all(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_piolink_l4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_get_piolink_l4sess(xsnmp_t *xs, int *nsess, char *vendor, snmpsys_t *sysp)$/;"	f
xsnmp_get_piolink_pas_all	libstar/xsnmpl4.c	/^int	xsnmp_get_piolink_pas_all(xsnmp_t *xs, l4sess_t *sesslist, int maxentry)$/;"	f
xsnmp_get_privoid	libstar/xsnmptype.c	/^privoid_t	*xsnmp_get_privoid(char *vendor, char *type, privoid_t *prevoid)$/;"	f
xsnmp_get_result	libstar/xsnmpif.c	/^static	int	xsnmp_get_result(xsnmp_t *xs, int *getiflist, int ngetiflist, $/;"	f	file:
xsnmp_get_xtable_result	libstar/xsnmpif.c	/^static	int	xsnmp_get_xtable_result(xsnmp_t *xs, int *getiflist, int ngetiflist, $/;"	f	file:
xsnmp_getaddrstr	libstar/xsnmp.c	/^char	*xsnmp_getaddrstr(xsnmp_t *xs, char *buf, int buflen, uint idx)$/;"	f
xsnmp_getallsnmp	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getallsnmp(xsnmp_t *xs)$/;"	f
xsnmp_getat	libstar/xsnmp.c	/^snmpat_t	*xsnmp_getat(xsnmp_t *xs, int *retnat)$/;"	f
xsnmp_getatcount	libstar/xsnmp.c	/^uint	xsnmp_getatcount(xsnmp_t *xs)$/;"	f
xsnmp_getcache	libstar/xsnmpif.c	/^snmpif_t *xsnmp_getcache(xsnmp_t *xs, int *retnif)$/;"	f
xsnmp_getcache2	libstar/xsnmpif.c	/^snmpif_t *xsnmp_getcache2(xsnmp_t *xs, int *retnif, int *getiflist, int ngetiflist)$/;"	f
xsnmp_getcisco	libstar/xsnmptype.c	/^int	xsnmp_getcisco(int *layer, char *ldescr, char *model, char *type)$/;"	f
xsnmp_getcounter	libstar/xsnmp.c	/^uint	xsnmp_getcounter(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getdatastr	libstar/xsnmp.c	/^char	*xsnmp_getdatastr(xsnmp_t *xs, char *buf, int buflen, uint idx)$/;"	f
xsnmp_getdouble	libstar/xsnmp.c	/^double	xsnmp_getdouble(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getentry	libstar/xsnmp.c	/^void	xsnmp_getentry(xsnmp_t *xs, snmpinfo_t *numi)$/;"	f
xsnmp_getfailoid	libstar/xsnmpif.c	/^int	xsnmp_getfailoid(xsnmp_t *xs)$/;"	f
xsnmp_getfloat	libstar/xsnmp.c	/^float	xsnmp_getfloat(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getgauge	libstar/xsnmp.c	/^uint	xsnmp_getgauge(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_geticmp	libstar/xsnmp.c	/^snmpicmp_t *xsnmp_geticmp(xsnmp_t *xs)$/;"	f
xsnmp_getif	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getif(xsnmp_t *xs, int *retnif)$/;"	f
xsnmp_getif2	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getif2(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif, int bulksz, int flag)$/;"	f
xsnmp_getif2_assign	libstar/xsnmpif.c	/^static	int	xsnmp_getif2_assign(xsnmp_t *xs, snmpif_t *iflist, int *getiflist, int ngetiflist)$/;"	f	file:
xsnmp_getifalias	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifalias(xsnmp_t *xs, snmpif_t *iflist, snmpxif_t *xiflist, int niflist)$/;"	f
xsnmp_getifall	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifall(xsnmp_t *xs, int *retnif)$/;"	f
xsnmp_getifbpspps	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifbpspps(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif)$/;"	f
xsnmp_getifbyindex	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifbyindex(xsnmp_t *xs, int ifindex, int flag)$/;"	f
xsnmp_getifcount	libstar/xsnmpif.c	/^uint	xsnmp_getifcount(xsnmp_t *xs)$/;"	f
xsnmp_getifindexbymac	libstar/xsnmpif.c	/^int	xsnmp_getifindexbymac(xsnmp_t *xs, char *mac)$/;"	f
xsnmp_getiflist	libstar/xsnmpif.c	/^int	xsnmp_getiflist(xsnmp_t *xs, int *getiflist)$/;"	f
xsnmp_getifmib	libstar/xsnmpif.c	/^static	snmpif_t	*xsnmp_getifmib(xsnmp_t *xs, snmpif_t *iflist, int *getiflist, int ngetiflist, oid **oidlist, int noidlist, int numoid)$/;"	f	file:
xsnmp_getifspec	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifspec(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif)$/;"	f
xsnmp_getifspeed	libstar/xsnmpif.c	/^float	xsnmp_getifspeed(xsnmp_t *xs, snmpif_t *ifp)$/;"	f
xsnmp_getiftraffic	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getiftraffic(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif)$/;"	f
xsnmp_getifv1_all	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifv1_all(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif, int flag)$/;"	f
xsnmp_getifv2	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifv2(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif, int flag)$/;"	f
xsnmp_getifv2_all	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifv2_all(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif, int flag)$/;"	f
xsnmp_getifv2_getnext	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_getifv2_getnext(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnif, int flag)$/;"	f
xsnmp_getifxtable	libstar/xsnmpif.c	/^snmpxif_t	*xsnmp_getifxtable(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnumxif, int flag)$/;"	f
xsnmp_getifxtablev2	libstar/xsnmpif.c	/^snmpxif_t	*xsnmp_getifxtablev2(xsnmp_t *xs, int *getiflist, int ngetiflist, int *retnumxif, int flag)$/;"	f
xsnmp_getint	libstar/xsnmp.c	/^int	xsnmp_getint(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getint64	libstar/xsnmp.c	/^longlong_t	xsnmp_getint64(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getip	libstar/xsnmp.c	/^snmpip_t *xsnmp_getip(xsnmp_t *xs)$/;"	f
xsnmp_getiptable	libstar/xsnmp.c	/^snmpiptable_t	*xsnmp_getiptable(xsnmp_t *xs, int *retnip)$/;"	f
xsnmp_getiptablecount	libstar/xsnmp.c	/^uint	xsnmp_getiptablecount(xsnmp_t *xs)$/;"	f
xsnmp_getl4_alteon_group	libstar/xsnmpl4.c	/^l4sess_group_t *xsnmp_getl4_alteon_group(xsnmp_t *xs, int *ngroup)$/;"	f
xsnmp_getl4_alteon_metric_name	libstar/xsnmpl4.c	/^char	*xsnmp_getl4_alteon_metric_name(int metric)$/;"	f
xsnmp_getl4_alteon_svrstate	libstar/xsnmpl4.c	/^char	*xsnmp_getl4_alteon_svrstate(int state)$/;"	f
xsnmp_getl4sess	libstar/xsnmpl4.c	/^l4sess_t	*xsnmp_getl4sess(xsnmp_t *xs, int *nsess, char *vendor, snmpsys_t *sysp)$/;"	f
xsnmp_getnet2media	libstar/xsnmp.c	/^snmpat_t	*xsnmp_getnet2media(xsnmp_t *xs, int *retnat)$/;"	f
xsnmp_getnet2mediacount	libstar/xsnmp.c	/^uint	xsnmp_getnet2mediacount(xsnmp_t *xs)$/;"	f
xsnmp_getnext	libstar/xsnmp.c	/^int	xsnmp_getnext(xsnmp_t *xs)$/;"	f
xsnmp_getoid	libstar/xsnmp.c	/^oid	*xsnmp_getoid(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getoidstr	libstar/xsnmp.c	/^char	*xsnmp_getoidstr(xsnmp_t *xs, char *buf, int buflen, uint idx)$/;"	f
xsnmp_getoidval	libstar/xsnmp.c	/^oid	*xsnmp_getoidval(xsnmp_t *xs, uint idx, int *len)$/;"	f
xsnmp_getopaquestr	libstar/xsnmp.c	/^char	*xsnmp_getopaquestr(SnmpVarList *var, char *buf, int buflen)$/;"	f
xsnmp_getproperty	libstar/xsnmptype.c	/^void	xsnmp_getproperty(xsnmp_t *xs, snmpsys_t *sysi, char *vendor, char *model, char *type, char *layerstr, char *iosver)$/;"	f
xsnmp_getroute	libstar/xsnmp.c	/^snmproute_t *xsnmp_getroute(xsnmp_t *xs, int *retnroute)$/;"	f
xsnmp_getroutecount	libstar/xsnmp.c	/^uint	xsnmp_getroutecount(xsnmp_t *xs)$/;"	f
xsnmp_getsize	libstar/xsnmp.h	229;"	d
xsnmp_getsnmp	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmp(xsnmp_t *xs, snmpinfo_t *snmpi, int *ncollect)$/;"	f
xsnmp_getsnmpat	libstar/xsnmp.c	/^snmpinfo_t	*xsnmp_getsnmpat(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpicmp	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmpicmp(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpif	libstar/xsnmp.c	/^snmpinfo_t	*xsnmp_getsnmpif(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpip	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmpip(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpnet2media	libstar/xsnmp.c	/^snmpinfo_t	*xsnmp_getsnmpnet2media(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmproute	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmproute(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpsys	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmpsys(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmptcp	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmptcp(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmptcpconn	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmptcpconn(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpudp	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmpudp(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getsnmpudpconn	libstar/xsnmp.c	/^snmpinfo_t *xsnmp_getsnmpudpconn(xsnmp_t *xs, snmpinfo_t *snmpi)$/;"	f
xsnmp_getstr	libstar/xsnmp.c	/^char	*xsnmp_getstr(xsnmp_t *xs, char *buf, int buflen, uint idx)$/;"	f
xsnmp_getstr2	libstar/xsnmp.c	/^char	*xsnmp_getstr2(SnmpVarList *var, char *buf, int buflen)$/;"	f
xsnmp_getsys	libstar/xsnmp.c	/^snmpsys_t *xsnmp_getsys(xsnmp_t *xs)$/;"	f
xsnmp_gettcpconncount	libstar/xsnmp.c	/^uint	xsnmp_gettcpconncount(xsnmp_t *xs)$/;"	f
xsnmp_gettimeout	libstar/xsnmp.c	/^void	xsnmp_gettimeout(xsnmp_t *xs, int *timeoutMS, int *retries)$/;"	f
xsnmp_gettimeticks	libstar/xsnmp.c	/^uint	xsnmp_gettimeticks(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getudpconncount	libstar/xsnmp.c	/^uint	xsnmp_getudpconncount(xsnmp_t *xs)$/;"	f
xsnmp_getuint	libstar/xsnmp.c	/^uint	xsnmp_getuint(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getuint64	libstar/xsnmp.c	/^ulonglong_t	xsnmp_getuint64(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getuint64str	libstar/xsnmp.c	/^double	xsnmp_getuint64str(xsnmp_t *xs, uint idx, char *retbuf)$/;"	f
xsnmp_getvar	libstar/xsnmp.c	/^SnmpVarList	*xsnmp_getvar(xsnmp_t *xs, uint idx)$/;"	f
xsnmp_getvarstr	libstar/xsnmp.c	/^char	*xsnmp_getvarstr(SnmpVarList *var, char *buf, int buflen)$/;"	f
xsnmp_getvartype	libstar/xsnmp.c	/^const	char    *xsnmp_getvartype(int vartype)$/;"	f
xsnmp_getvendor	libstar/xsnmptype.c	/^int	xsnmp_getvendor(xsnmp_t *xs, char *vendor, int buflen)$/;"	f
xsnmp_getvendor_byoid	libstar/xsnmptype.c	/^void	xsnmp_getvendor_byoid(xsnmp_t *xs, char *vendor, char *model, char *type, char *iosver)$/;"	f
xsnmp_init	libstar/xsnmp.h	199;"	d
xsnmp_ipmachash	libstar/xsnmp2.c	/^hash_t	*xsnmp_ipmachash = NULL;$/;"	v
xsnmp_is64	libstar/xsnmp.c	/^int	xsnmp_is64(int type)$/;"	f
xsnmp_loadportmap	libstar/xsnmp2.c	/^int	xsnmp_loadportmap(xsnmp_t *xs, hash_t *ht)$/;"	f
xsnmp_netscaler_getvif	libstar/xsnmpif.c	/^snmpif_t	*xsnmp_netscaler_getvif(xsnmp_t *xs, int *nviflist)$/;"	f
xsnmp_oid2name	libstar/xsnmp.c	/^char	*xsnmp_oid2name(oid *ids, int oidlen, char *buf)$/;"	f
xsnmp_oid2str	libstar/xsnmp.c	/^char	*xsnmp_oid2str(char *buf, int buflen, oid *ids, uint idlen)$/;"	f
xsnmp_open	libstar/xsnmp.h	205;"	d
xsnmp_open_node	libstar/xnms.h	436;"	d
xsnmp_portmaphash	libstar/xsnmp2.c	/^hash_t	*xsnmp_portmaphash = NULL;$/;"	v
xsnmp_readnet2media	libstar/xsnmp2.c	/^int	xsnmp_readnet2media(xsnmp_t *xs, hash_t *ht)$/;"	f
xsnmp_readportmac	libstar/xsnmp2.c	/^int	xsnmp_readportmac(xsnmp_t *xs, hash_t *ht, int *vlanlist, int *nvlanlist)$/;"	f
xsnmp_readportmap	libstar/xsnmp2.c	/^int	xsnmp_readportmap(xsnmp_t *xs, hash_t *ht, int *vlanlist, int *nvlanlist)$/;"	f
xsnmp_set	libstar/xsnmp.c	/^int	xsnmp_set(xsnmp_t *xs)$/;"	f
xsnmp_set_v3_param	libstar/xsnmp.c	/^void	xsnmp_set_v3_param(xsnmp_t *xs, char *name, char *passwd, char *proto)$/;"	f
xsnmp_setbulk_rept	libstar/xsnmp.c	/^void	xsnmp_setbulk_rept(xsnmp_t *xs, int nonrep, int maxrep)$/;"	f
xsnmp_setpdu	libstar/xsnmp.c	/^int	xsnmp_setpdu(xsnmp_t *xs, int type)$/;"	f
xsnmp_settimeout	libstar/xsnmp.c	/^void	xsnmp_settimeout(xsnmp_t *xs, int timeoutMS, int retries)$/;"	f
xsnmp_snmpok	libstar/xsnmp.c	/^int	xsnmp_snmpok(xsnmp_t *xs)$/;"	f
xsnmp_str2oid	libstar/xsnmp.c	/^int	xsnmp_str2oid(char *buf, oid *ids)$/;"	f
xsnmp_t	libstar/xsnmp.h	/^}	xsnmp_t;$/;"	t	typeref:struct:__anon158
xsnmp_trap_description	libstar/xsnmptrap.c	/^const char *xsnmp_trap_description(int trap)$/;"	f
xsnmp_v1support	libstar/xsnmp.c	/^int	xsnmp_v1support(xsnmp_t *xs)$/;"	f
xsnmp_v2support	libstar/xsnmp.c	/^int	xsnmp_v2support(xsnmp_t *xs)$/;"	f
xsnprintf	libstar/xdebug.h	151;"	d
xsock_close	libstar/xsock.h	133;"	d
xsock_hasdata	libstar/xsock.c	/^int	xsock_hasdata(xsock_t *sock, int waitMS)$/;"	f
xsock_recv	libstar/xsock.c	/^int	xsock_recv(int sockfd, void *buf, int bufsize, int timeoutMS)$/;"	f
xsock_recvline	libstar/xsock.c	/^int	xsock_recvline(int fd, char *buf, int buflen)$/;"	f
xsock_send	libstar/xsock.c	/^int	xsock_send(int sockfd, void *buf, int bufsize, int timeoutMS)$/;"	f
xsock_t	libstar/xsock.h	/^}	xsock_t;$/;"	t	typeref:struct:xsocket
xsock_valid	libstar/xsock.c	/^int	xsock_valid(xsock_t *sock)$/;"	f
xsocket	libstar/xsock.h	/^typedef struct xsocket {$/;"	s
xsockkey_t	libstar/gw.h	/^}	xsockkey_t;$/;"	t	typeref:struct:__anon40
xsprintf	libstar/xdebug.h	150;"	d
xsslsock_t	libstar/xssl.h	/^}	xsslsock_t;$/;"	t	typeref:struct:__anon167
xstr2time	libstar/xtime.c	/^time_t	xstr2time(char *timestr)$/;"	f
xstralnum	libstar/xstr.c	/^int	xstralnum(char *str)$/;"	f
xstralpha	libstar/xstr.c	/^int	xstralpha(char *str)$/;"	f
xstrcat	libstar/xstr.h	55;"	d
xstrcount	libstar/xstr.c	/^int	xstrcount(char *string, const char *ptn)$/;"	f
xstrcpy	libstar/xstr.h	53;"	d
xstrcpyline	libstar/xstr.h	54;"	d
xstrdiff	libstar/xstr.c	/^int	xstrdiff(char *ofile, char *nfile, char *opts, int **olist, int **nlist, char *result, int resultlen)$/;"	f
xstrdigit	libstar/xstr.c	/^int	xstrdigit(char *str)$/;"	f
xstrdup	libstar/xstr.h	67;"	d
xstrfloat	libstar/xstr.c	/^int	xstrfloat(char *str)$/;"	f
xstrireplace	libstar/xstr.c	/^char	*xstrireplace(char *src, char *dest, char *fromptn, char *toptn)$/;"	f
xstrlen	libstar/xstr.h	56;"	d
xstrlower	libstar/xstr.c	/^int	xstrlower(char *str)$/;"	f
xstrncat	libstar/xstr.c	/^void	xstrncat(char *dest, const char *src, size_t size)$/;"	f
xstrncpy	libstar/xstr.c	/^void	xstrncpy(char *dest, const char *src, const size_t size)$/;"	f
xstrncpyline	libstar/xstr.c	/^void	xstrncpyline(char *dest, char *src, size_t size)$/;"	f
xstrndup	libstar/xstr.h	68;"	d
xstrreplace	libstar/xstr.c	/^char	*xstrreplace(char *src, char *dest, const char *fromptn, const char *toptn)$/;"	f
xstrspcl	libstar/xstr.c	/^int	xstrspcl(char *str)$/;"	f
xstrtime	libstar/xtime.c	/^char  *xstrtime(time_t tim, char *buf)$/;"	f
xstrupper	libstar/xstr.c	/^int	xstrupper(char *str)$/;"	f
xstrvar	libstar/xstr.c	/^int	xstrvar(char *str)$/;"	f
xsystem	libstar/xutil.h	63;"	d
xtelnet_init	libstar/xtn.c	/^int	xtelnet_init(int sock, int timeout_sec)$/;"	f
xtelnet_proto	libstar/xtn.c	/^void	xtelnet_proto(SOCKET server, uchar code, xtn_state_t *data)$/;"	f
xtime	libstar/xtime.h	63;"	d
xtime_t	libstar/xtime.h	/^typedef struct timeval	xtime_t;$/;"	t	typeref:struct:timeval
xtime_t	libstar/xtime.h	/^} xtime_t;$/;"	t	typeref:struct:__anon172
xtimesync	libstar/xtime.c	/^void	xtimesync(time_t basetime)$/;"	f
xtm_t	libstar/xtime.c	/^}       xtm_t;$/;"	t	typeref:struct:__anon169	file:
xtn	libstar/xtn.h	/^typedef struct xtn {$/;"	s
xtn_capture	libstar/xtn.c	/^int	xtn_capture(void (*tn_callback) (struct xtn *tnp, int type, char *buf), char *opt, char *nodeip, int port, char *prompt_sep, char *prompt[], char *cmd[], char *cmdopt[], char *outbuf, int outbufsz)$/;"	f
xtn_clear	libstar/xtn.c	/^void	xtn_clear(xtn_t *tnp)$/;"	f
xtn_close	libstar/xtn.h	51;"	d
xtn_end	libstar/xtn.c	/^char	*xtn_end(xtn_t *tnp)$/;"	f
xtn_get	libstar/xtn.c	/^char	*xtn_get(xtn_t *tnp)$/;"	f
xtn_getclean	libstar/xtn.c	/^char	*xtn_getclean(xtn_t *tnp, char *frombuf, char *copybuf, int copylen)$/;"	f
xtn_lastline	libstar/xtn.c	/^char	*xtn_lastline(xtn_t *tnp, int trim)$/;"	f
xtn_nextline	libstar/xtn.c	/^char	*xtn_nextline(xtn_t *tnp)$/;"	f
xtn_open	libstar/xtn.c	/^xtn_t	*xtn_open(uint addr, int port, int bufsz)$/;"	f
xtn_process_escape	libstar/xtn.c	/^int	xtn_process_escape(char *buf, int buflen, char *replace)$/;"	f
xtn_prompt_cmd	libstar/xtn.c	/^char	*xtn_prompt_cmd(xtn_t *tnp, char *prompt_sep, char *prompt, char *cmd, char *cmdopt, char **delline)$/;"	f
xtn_search_prompt	libstar/xtn.c	/^int	xtn_search_prompt(xtn_t *tnp, char *pv[], char *popt[])$/;"	f
xtn_send	libstar/xtn.c	/^int	xtn_send(xtn_t *tnp, char *buf)$/;"	f
xtn_setbuf	libstar/xtn.c	/^void	xtn_setbuf(xtn_t *tnp, int bufsize)$/;"	f
xtn_setcallback	libstar/xtn.c	/^void	xtn_setcallback(xtn_t *tnp, void (*func) (struct xtn *tnp, int type, char *buf))$/;"	f
xtn_settimeout	libstar/xtn.c	/^void	xtn_settimeout(xtn_t *tnp, int timeout_ms)$/;"	f
xtn_state_t	libstar/xtn.c	/^}	xtn_state_t;$/;"	t	typeref:struct:__anon177	file:
xtn_t	libstar/xtn.h	/^}	xtn_t;$/;"	t	typeref:struct:xtn
xtn_wait	libstar/xtn.c	/^int	xtn_wait(xtn_t *tnp, char **promptv, int waitMS)$/;"	f
xtn_waitany	libstar/xtn.c	/^int	xtn_waitany(xtn_t *tnp, int prevlen, int count, int waitMS)$/;"	f
xtn_waitprompt	libstar/xtn.c	/^char	*xtn_waitprompt(xtn_t *tnp, char **promptv, int waitMS)$/;"	f
xtraceroute	libstar/xping.c	/^int	xtraceroute(char *hostname, int timeoutMS, int ttl, void (*callback) (int hops, xicmpres_t *rp), xicmpres_t *res)$/;"	f
xtrimspace	libstar/xstr.c	/^char   *xtrimspace(char *ss)$/;"	f
xtrimtag	libstar/xstr.c	/^char	*xtrimtag(char *ss, char *outbuf, int outlen)$/;"	f
xunlock	libstar/xlock.h	54;"	d
xunlock2	libstar/xlock.h	55;"	d
xurlencode	libstar/xstr.c	/^char	*xurlencode(char *src, char *dst, int dstlen, int encode_ampersand)$/;"	f
xwinsock_cleanup	libstar/xsock.c	/^void	xwinsock_cleanup()$/;"	f
xwinsock_startup	libstar/xsock.c	/^char	*xwinsock_startup()$/;"	f
xwrite64	libstar/xutil.c	/^int	xwrite64(int fd, void *buf, size_t buflen)$/;"	f
year	libstar/xtime.c	/^	uchar    year;			\/\/ 2000을 더해야 함 $/;"	m	struct:__anon169	file:
yesreply	libstar/xtn.c	/^inline void yesreply(SOCKET server, _verb verb,_option option)$/;"	f
~CHash	libstar/hash.h	/^	~CHash()	{ hash_free(m_ht); }$/;"	f	class:CHash
~CXList	libstar/xlist.h	/^	~CXList()					{ xlist_free(m_xl); }$/;"	f	class:CXList
~CXNms	libstar/xnms.h	/^	virtual ~CXNms()				{ xnms_stop(m_xnms); }$/;"	f	class:CXNms
~CXSnmp	libstar/xsnmp.h	/^	virtual ~CXSnmp()							{ xsnmp_close(m_xs); xsnmp_free(m_xs); }$/;"	f	class:CXSnmp
~JsonValue	json11/json11.hpp	/^    virtual ~JsonValue() {}$/;"	f	class:json11::JsonValue
~hdac	rpc.h	/^	~hdac()$/;"	f	class:hdac
~hdac_admin	contract.h	/^	~hdac_admin()$/;"	f	class:hdac_admin
~hdac_contract	contract.h	/^	~hdac_contract()$/;"	f	class:hdac_contract
~hdac_node	node.h	/^	~hdac_node()$/;"	f	class:hdac_node
~hdac_virtual_device	node.h	/^	~hdac_virtual_device()$/;"	f	class:hdac_virtual_device
~json	json2.h	/^	~json()		{ clear(); }$/;"	f	class:json
~json	myjson/json.h	/^	~json() { cleanup(); }$/;"	f	class:json
~json	myjson/json2.h	/^	~json()		{ clear(); }$/;"	f	class:json
